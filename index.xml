<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>&lt;jack-gdn/&gt;</title>
    <link>https://jackgdn.github.io/</link>
    <description>Recent content on &lt;jack-gdn/&gt;</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Sat, 19 Apr 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://jackgdn.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ROS 学习记录（四）——ROS 自定义头文件/模块，更改日志输出级别</title>
      <link>https://jackgdn.github.io/post/bundle-ros/ros-lib/</link>
      <pubDate>Sat, 19 Apr 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-ros/ros-lib/</guid>
      <description>自定义 C++ 头文件 当前包名为 libtest，自定义头文件 libtest/include/libtest/hello.h：&#xA;1#pragma once 2 3#include &amp;#34;ros/ros.h&amp;#34; 4 5namespace Hello 6{ 7 void hello(); 8} 编辑 .vscode/c_cpp_properties.json 文件，添加头文件搜索路径，确保 IntelliSense 能够识别自定义头文件：&#xA;1{ 2 &amp;#34;configurations&amp;#34;: [ 3 { 4 &amp;#34;browse&amp;#34;: { 5 &amp;#34;databaseFilename&amp;#34;: &amp;#34;${default}&amp;#34;, 6 &amp;#34;limitSymbolsToIncludedHeaders&amp;#34;: false 7 }, 8 &amp;#34;includePath&amp;#34;: [ 9 &amp;#34;/opt/ros/noetic/include/**&amp;#34;, 10 &amp;#34;/home/jackgdn/ros-project/src/**/include/**&amp;#34;, // 将这一项添加到 includePath 中 11 &amp;#34;/usr/include/**&amp;#34;, 12 &amp;#34;/home/jackgdn/ros-project/devel/include/**&amp;#34; 13 ], 14 &amp;#34;name&amp;#34;: &amp;#34;ROS&amp;#34;, 15 &amp;#34;intelliSenseMode&amp;#34;: &amp;#34;gcc-x64&amp;#34;, 16 &amp;#34;compilerPath&amp;#34;: &amp;#34;/usr/bin/gcc&amp;#34;, 17 &amp;#34;cStandard&amp;#34;: &amp;#34;gnu11&amp;#34;, 18 &amp;#34;cppStandard&amp;#34;: &amp;#34;c++14&amp;#34; 19 } 20 ], 21 &amp;#34;version&amp;#34;: 4 22} 编写 hello_cpp.</description>
    </item>
    <item>
      <title>ROS 学习记录（三）——ROS 通信机制实践</title>
      <link>https://jackgdn.github.io/post/bundle-ros/ros-comm-prac/</link>
      <pubDate>Wed, 16 Apr 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-ros/ros-comm-prac/</guid>
      <description>话题通信 话题发布 在安装完 ROS 的测试样例中，系统提供了一个 turtlesim_node 节点，用于显示乌龟移动路径。我们要尝试的就是向这个节点发布话题，让它显示我们自定义的移动轨迹。&#xA;首先运行 ros 和 turtlesim_node 节点：&#xA;1roscore &amp;amp; 2rosrun turtlesim turtlesim_node 查看当前可用话题：&#xA;1rostopic list 输出：&#xA;1/rosout 2/rosout_agg 3/turtle1/cmd_vel 4/turtle1/color_sensor 5/turtle1/pose 可以看到，turtlesim_node 节点提供了三个话题，而我们要发布的轨迹信息就发布在 /turtle1/cmd_vel 话题上。&#xA;用下面的命令查看 /turtle1/cmd_vel 话题的类型：&#xA;1rostopic type /turtle1/cmd_vel 输出：&#xA;1geometry_msgs/Twist 可以看到，/turtle1/cmd_vel 话题的类型是 geometry_msgs/Twist。再查看一下这个类型的定义：&#xA;1rosmsg show geometry_msgs/Twist 输出：&#xA;1geometry_msgs/Vector3 linear 2 float64 x 3 float64 y 4 float64 z 5geometry_msgs/Vector3 angular 6 float64 x 7 float64 y 8 float64 z 可以看到，/turtle1/cmd_vel 话题的消息类型是 geometry_msgs/Twist，其中包含两个成员变量 linear 和 angular，分别表示线速度和角速度。我们希望乌龟做匀速圆周运动，因此设定其线速度为 1，角速度为 0.</description>
    </item>
    <item>
      <title>ROS 学习记录（二）——ROS 的通信机制</title>
      <link>https://jackgdn.github.io/post/bundle-ros/ros-comm/</link>
      <pubDate>Sun, 13 Apr 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-ros/ros-comm/</guid>
      <description>话题通信 模型 ROS 话题通信中涉及三个角色：&#xA;ROS Master（管理者） Talker（发布者） Listener（订阅者） 话题通信由以下步骤实现：&#xA;Talker 注册 Listener 注册 ROS Master 匹配已注册的 Talker 和 Listener Listener 向 Talker 发送请求 Talker 确认请求 Listener 与 Talker 建立连接 Talker 向 Lkstener 发送消息 Note&#xA;通信步骤的前五步使用 RPC 协议，后两步使用 TCP 协议。 Talker 和 Listener 启动顺序无要求。 一个 Talker 可以与多个 Listener 建立连接，反之亦然。 Talker 与 Listener 建立连接后，不再需要 ROS Master。此时即使关闭 ROS Master 也不会影响通信。 C++ 实现话题通信 创建一个新的包 communication_package，通信部分的脚本都在这个包中测试。&#xA;1catkin_create_pkg communication_package roscpp rospy std_msgs 在 communication_package/src/ 下创建 topic_talker_cpp.cpp 作为 C++ 实现的 Talker：</description>
    </item>
    <item>
      <title>ROS 学习记录（一）——快速体验</title>
      <link>https://jackgdn.github.io/post/bundle-ros/ros-basic/</link>
      <pubDate>Sat, 12 Apr 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-ros/ros-basic/</guid>
      <description>创建并初始化工作空间 安装完 ROS 后，创建工作空间。假设工作空间名称为 ros-project，依次输入下面的命令创建并且初始化工作空间：&#xA;1mkdir -p ./ros-project/src/ 2cd ros-project 3catkin_make 创建 ROS 包 进入 src/ 目录并且创建一个 ROS 包，一般 ROS 包的名称为 *_package：&#xA;1cd src 2catkin_create_pkg test_package roscpp rospy std_msgs 上述命令会在 ros-project/src/ 下创建一个名为 test_package 的文件夹，文件夹的结构如下：&#xA;1. 2├── CMakeLists.txt 3├── include 4│ └── test_package 5├── package.xml 6└── src 参数中的 roscpp rospy std_msgs 是 ROS 中的常用模块。&#xA;创建源码并且输出 Hello World C++ 实现 在当前包的 src/ 目录下创建 test_package_node.cpp：&#xA;1cd test_package/ 2touch src/test_package_node.cpp 在当前 C++ 源文件中写入如下代码：&#xA;1#include &amp;#34;ros/ros.</description>
    </item>
    <item>
      <title>日志-2025-04-10</title>
      <link>https://jackgdn.github.io/post/bundle-%E6%97%A5%E5%BF%97/log-2025-04-10/</link>
      <pubDate>Thu, 10 Apr 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E6%97%A5%E5%BF%97/log-2025-04-10/</guid>
      <description>这次我给页面添加了 vim 键位，按键绑定如下：&#xA;按键 功能 gg 回到顶部 Shift+G 回到底部 / 搜索 j 向上滚动半屏 k 向下滚动半屏 也加了一些非 vim 快捷键：&#xA;按键 功能 Shift+M 向我发邮件 Shift+H 访问我的 Github 主页 Shift+D 打开我的 Discord 页面 Shift+N 切换显示模式 </description>
    </item>
    <item>
      <title>2025春季算法练习——Week 5</title>
      <link>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025spring-week5/</link>
      <pubDate>Sat, 05 Apr 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025spring-week5/</guid>
      <description>题目来自 蓝桥云课 19714 数字诗意 | 原题链接 假设数字 $n$ 可以被表示为从 $a$ 到 $a+k-1$ 共 $k$ 个数字的和，则 $n=\frac{k(2a+k-1)}2$，通过观察不难发现，$n$ 一定有奇数因子。也就是说，如果一个数是 $2$ 的幂，那么它一定没有诗意。&#xA;令 $n=o\cdot e$，$o$ 为 $n$ 的奇数因子，$e$ 为 $n$ 的偶数因子。当 $o&amp;gt;e$ 时，令 $k=e$，则 $a=\frac{o+1-e}2$，此时 $a\in \mathbb{N_+}$；当 $o&amp;lt;e$ 时，令 $k=o$，则 $a=\frac{e+1-o}2$，此时 $a\in \mathbb{N_+}$。&#xA;因此当且仅当 $n\neq2^k$ 时，$n$ 有诗意。&#xA;1_ = int(input().strip()) 2nums = tuple(map(int, input().strip().split())) 3p2 = set() 4p = 1 5while p &amp;lt;= 1e16: 6 p2.add(p) 7 p *= 2 8count = 0 9for num in nums: 10 if num in p2: 11 count += 1 12print(count) 19715 回文数组 | 原题链接 模拟一下就行。</description>
    </item>
    <item>
      <title>2025春季算法练习——Week 4</title>
      <link>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025spring-week4/</link>
      <pubDate>Sun, 30 Mar 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025spring-week4/</guid>
      <description>题目来自 AcWing 842. 排列数字 | 原题链接 做做板子。&#xA;1n = int(input().strip()) 2 3nums = [i + 1 for i in range(n)] 4used = [False] * (n + 1) 5used[0] = True 6res = list() 7 8 9def dfs(path): 10 if all(used): 11 res.append(path) 12 return 13 14 for num in nums: 15 if not used[num]: 16 used[num] = True 17 dfs(path + [num]) 18 used[num] = False 19 20 21dfs(list()) 22for arr in res: 23 print(*arr) 或者</description>
    </item>
    <item>
      <title>图论练习</title>
      <link>https://jackgdn.github.io/post/bundle-%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/algo-graphtheory/</link>
      <pubDate>Sun, 30 Mar 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/algo-graphtheory/</guid>
      <description>题目来自 AcWing 848. 有向图的拓扑序列 | 原题链接 拓扑排序已经做过好几遍了，而且这还是一道模板题。如果一个有向图中有环（自环也是环），那么它一定无法拓扑排序。如果一个图拓扑排序得到的节点数和图中的节点数不同，那么这个图无法被拓扑排序。又因为“有向图可以被拓扑排序”和“图是有向无环图”互为充要条件，所以，则这个图一定不是有向无环图。&#xA;1import sys 2from collections import defaultdict, deque 3 4data = sys.stdin.read().strip().splitlines() 5n, m = map(int, data[0].strip().split()) 6 7indegree = [0 for _ in range(n + 1)] 8graph = defaultdict(list) 9ans = list() 10 11for i in range(1, m + 1): 12 u, v = map(int, data[i].strip().split()) 13 graph[u].append(v) 14 indegree[v] += 1 15 16q = deque() 17for node in range(1, n + 1): 18 if indegree[node] == 0: 19 q.</description>
    </item>
    <item>
      <title>2025春季算法练习——Week 3</title>
      <link>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025spring-week3/</link>
      <pubDate>Wed, 26 Mar 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025spring-week3/</guid>
      <description>这些题看上去较简单，但是实操起来还有很多细节需要注意。&#xA;题目来自 AcWing 830. 单调栈 | 原题链接 遍历原数组中的每个数，然后作如下操作：&#xA;将栈顶元素出栈直到栈顶元素小于列表当前元素 将栈顶元素添加到答案列表中 将列表当前元素入栈 在栈中，如果一个元素小于前一个元素，那么这个元素后面所有元素的“左边第一个比它小的数”就不可能是当前这个元素前面的元素。&#xA;1from collections import deque 2 3n = int(input().strip()) 4nums = tuple(map(int, input().strip().split())) 5stack = deque() 6ans = list() 7for num in nums: 8 while stack and stack[-1] &amp;gt;= num: 9 stack.pop() 10 ans.append(-1 if not stack else stack[-1]) 11 stack.append(num) 12 13print(*ans) 154. 滑动窗口 | 原题链接 这道题像是上一道题的进阶版，区别是这道题只能在一个区间范围内找最大/最小值。解决这道题的流程如下：&#xA;将已经离开窗口的元素从队首弹出 确保队尾元素大于/小于列表当前元素，否则将元素从队尾出队 将列表当前元素入队 队首元素即为当前窗口的最大/最小值，将这个值添加到答案列表中 为了方便判断某个元素是否已经离开窗口，队列中存储的是元素的下标。&#xA;1from collections import deque 2 3n, k = map(int, input().</description>
    </item>
    <item>
      <title>动态规划练习（二）</title>
      <link>https://jackgdn.github.io/post/bundle-%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/algo-dp-2/</link>
      <pubDate>Thu, 20 Mar 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/algo-dp-2/</guid>
      <description>题目来自 AcWing 1050. 鸣人的影分身 | 原题链接 数据量很小，深搜可以 AC。&#xA;1t = int(input().strip()) 2 3 4def dfs(last_pow, rest_pow, rest_cnt): 5 global plans 6 if rest_pow == 0 and rest_cnt == 0: 7 plans += 1 8 return 9 10 if rest_pow &amp;lt; 0 or rest_cnt &amp;lt; 0: 11 return 12 13 if rest_cnt * last_pow &amp;gt; rest_pow: 14 return 15 16 for p in range(last_pow, rest_pow + 1): 17 dfs(p, rest_pow - p, rest_cnt - 1) 18 19 20for _ in range(t): 21 m, n = map(int, input().</description>
    </item>
    <item>
      <title>数学与数论类题目练习</title>
      <link>https://jackgdn.github.io/post/bundle-%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/algo-numbertheory/</link>
      <pubDate>Sun, 16 Mar 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/algo-numbertheory/</guid>
      <description>前几天光往医院跑，没大抽出时间做题。&#xA;题目来自 AcWing Info&#xA;对于任意大于 $1$ 的整数 $N$，分解质因数得 $N=p_1^{a_1}\cdot p_2^{a_2}\cdots p_k^{a_k}$，$N$ 的因数个数为 $(a_1+1)(a_2+1)\cdots(a_k+1)$，$N$ 的因数之和为 $(1+p_1+p_1^2+\cdots+p_1^{a_1})(1+p_2+p_2^2+\cdots+p_2^{a_2})\cdots(1+p_k+p_k^2+\cdots+p_k^{a_k})$。&#xA;1246. 等差数列 | 原题链接 给出的数据中，令其中的最小项为首项，最大项为末项，且公差最大时，项数最少。对给出的数据排序并两两作差，当公差为这些差的最大公约数时最大，此时项数最少。&#xA;1n = int(input()) 2nums = list(map(int, input().strip().split())) 3nums.sort() 4 5if nums[-1] == nums[0]: 6 print(n) 7 exit() 8 9def gcd(a, b): 10 return a if b == 0 else gcd(b, a % b) 11 12b = list() 13for i in range(1, n): 14 b.append(nums[i] - nums[i - 1]) 15 16g = b[0] 17for i in range(n - 1): 18 g = gcd(g, b[i]) 19print((nums[-1] - nums[0]) // g + 1) 1295.</description>
    </item>
    <item>
      <title>每日一题 3.10-3.16</title>
      <link>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-3.10-3.16/</link>
      <pubDate>Fri, 14 Mar 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-3.10-3.16/</guid>
      <description>题目来自 AcWing 刚说完上周题简单，这周一的题就给我干碎了……&#xA;5589. 哞语言逻辑 | 原题链接 首先用 Python 特有的 eval 来试一下：&#xA;1true, false = True, False 2n, q = map(int, input().strip().split()) 3exp = input().strip().split() 4 5ans = list() 6for _ in range(q): 7 a, b, bl = input().strip().split() 8 a = int(a) - 1 9 b = int(b) - 1 10 if eval(&amp;#39; &amp;#39;.join(exp[:a] + [&amp;#34;true&amp;#34;] + exp[b + 1:])) == eval(bl) or eval(&amp;#39; &amp;#39;.join(exp[:a] + [&amp;#34;false&amp;#34;] + exp[b + 1:])) == eval(bl): 11 ans.</description>
    </item>
    <item>
      <title>二分查找与前缀和练习（二）</title>
      <link>https://jackgdn.github.io/post/bundle-%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/algo-binarysearch&#43;prefixsum-2/</link>
      <pubDate>Sun, 09 Mar 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/algo-binarysearch&#43;prefixsum-2/</guid>
      <description>题目来自洛谷题单【算法1-6】二分查找与二分答案&#xA;P2249 【深基13.例1】查找 题目描述 输入 $n$ 个不超过 $10^9$ 的单调不减的（就是后面的数字不小于前面的数字）非负整数 $a_1,a_2,\dots,a_{n}$，然后进行 $m$ 次询问。对于每次询问，给出一个整数 $q$，要求输出这个数字在序列中第一次出现的编号，如果没有找到的话输出 $-1$ 。&#xA;输入格式 第一行 $2$ 个整数 $n$ 和 $m$，表示数字个数和询问次数。&#xA;第二行 $n$ 个整数，表示这些待查询的数字。&#xA;第三行 $m$ 个整数，表示询问这些数字的编号，从 $1$ 开始编号。&#xA;输出格式 输出一行，$m$ 个整数，以空格隔开，表示答案。&#xA;输入输出样例 #1 输入 #1 111 3 21 3 3 3 5 7 9 11 13 15 15 31 3 6 输出 #1 11 2 -1 说明/提示 数据保证，$1 \leq n \leq 10^6$，$0 \leq a_i,q \leq 10^9$，$1 \leq m \leq 10^5$</description>
    </item>
    <item>
      <title>每日一题 3.3-3.9</title>
      <link>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-3.3-3.9/</link>
      <pubDate>Sat, 08 Mar 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-3.3-3.9/</guid>
      <description>题目来自 AcWing 感觉每日一题越来越简单，代码量也越来越短。第一周优化暴力枚举的题目兼具创新性和挑战性，而这周的题目几乎不需要“深度求索”。&#xA;5525. 炮弹 | 原题链接 只需要把情况模拟一下就行了。唯一要注意的是，如果 Bessie 陷入了死循环就直接输出。判断死循环的方式也特别简单，每次弹跳后将当前的位置、能量、方向存储进一个集合（in 关键字访问集合的时间复杂度为 $O(1)$），同时每次弹跳前查看此次弹跳是否已经被记录。&#xA;1N, S = map(int, input().strip().split()) 2field = [0] * N 3cate = [0] * N 4S -= 1 5targets = 0 6for i in range(N): 7 qi, vi = map(int, input().strip().split()) 8 cate[i] = qi 9 field[i] = vi 10 targets += qi 11 12memo = set() 13count = 0 14power = 1 15directions = {1: -1, -1: 1} 16d = 1 17while 0 &amp;lt;= S &amp;lt; N: 18 if cate[S] == 1: 19 if field[S] &amp;gt;= 0 and power &amp;gt;= field[S]: 20 field[S] = -1 21 count += 1 22 S += d * power 23 else: 24 power += field[S] 25 d = directions[d] 26 S += d * power 27 28 if (S, d, power) in memo: 29 break 30 memo.</description>
    </item>
    <item>
      <title>双指针、广搜与图论练习</title>
      <link>https://jackgdn.github.io/post/bundle-%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/algo-doublepointers&#43;bfs&#43;graphs/</link>
      <pubDate>Fri, 07 Mar 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/algo-doublepointers&#43;bfs&#43;graphs/</guid>
      <description>题目来自 AcWing 1238. 日志统计 | 原题链接 暴力做法：存储每个帖子在对应时间的点赞数，并计算前缀和，再遍历前缀和数组得到答案。时间复杂度和空间复杂度 $O(ND)$，可以通过 13/15 个测试点。&#xA;1from collections import defaultdict 2 3 4def check(nums, D, K): 5 prefs = [0] * int(1e5 + 1) 6 for i in range(1, int(1e5 + 1)): 7 prefs[i] = prefs[i - 1] + nums[i - 1] 8 if i &amp;gt;= D and prefs[i] - prefs[i - D] &amp;gt;= K: 9 return True 10 return False 11 12 13N, D, K = map(int, input().</description>
    </item>
    <item>
      <title>每日一题 2.24-3.2</title>
      <link>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-2.24-3.2/</link>
      <pubDate>Wed, 05 Mar 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-2.24-3.2/</guid>
      <description>上周忙着返校所以没来得及做题，这几天把上周的题目补上。&#xA;题目来自 AcWing 6131. 农夫约翰最喜欢的操作 | 原题链接 $M\mid a_i-x$ 对任意 $1\leq i\leq N$ 成立亦可以理解为对任意 $1\leq i,j\leq N$ 有 $a_i\equiv a_j\space(mod\space M)$。使原数列每一个数对 $m$ 取模得到模数列 $b$，再找一个数 $k$ 使得模数列中每一个值与 $k$ 的差的绝对值之和最小，即 $\sum^n_{i=1}|b_i-k|$ 最小，这个最小值就是题目要求的值。看起来这就是 货仓选址 的翻版，只要找到中位数即可。但情况真的如此吗？&#xA;实际情况是，由于 $a_i\equiv a_i\pm m\space(mod\space m)$，所有的同余类实际组成了一个环，在这个环上有 $n$ 中不同的取法，也就是说最多可能有 $n$ 个不同的中位数，而题目要求找到这 $n$ 中情况中找到最小的 $\sum^n_{i=1}|b_i-k|$。&#xA;如果将每种情况的模数列算出来，再遍历数列求出答案，时间复杂度为 $O(n^2)$ 必然超时。因此使用滑动窗口优化。首先找出最小的模数列，即每一项都小于 $m$，求出这一个模数列的最小 $\sum^n_{i=1}|b_i-k|$，这个值等于$中位数 \times 中位数左侧元素个数 - 中位数左侧元素之和 + 中位数右侧元素之和 - 中位数 \times 中位数右侧元素个数$。当窗口滑动时，中位数右移一位，中位数左右元素数量不变，而左右元素之和只需各自加减对应边界值。这样的时间复杂度为 $O(n)$。&#xA;1t = int(input().strip()) 2while t &amp;gt; 0: 3 n, m = map(int, input().</description>
    </item>
    <item>
      <title>树状数组、线段树与差分练习</title>
      <link>https://jackgdn.github.io/post/bundle-%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/algo-segmenttree/</link>
      <pubDate>Mon, 03 Mar 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/algo-segmenttree/</guid>
      <description>Info&#xA;树状数组与线段树的适用范围是“单点修改，区间查询”。树状数组更适合用于动态维护前缀和，而线段树还可用于求区间最值 树状数组和线段树都是在线方法，支持动态修改与维护。&#xA;题目来自 AcWing 1264. 动态求连续区间和 | 原题链接 这是一道树状数组模板题。树状数组最基础的用法就是动态维护前缀和。下面出现的 lowbit add query 操作都是维护树状数组的基本函数。&#xA;1import sys 2 3 4def lowbit(x): 5 return x &amp;amp; -x 6 7 8def add(x, val): 9 while x &amp;lt;= n: 10 tree[x] += val 11 x += lowbit(x) 12 13 14def query(x): 15 res = 0 16 while x &amp;gt; 0: 17 res += tree[x] 18 x -= lowbit(x) 19 return res 20 21 22data = sys.</description>
    </item>
    <item>
      <title>枚举、模拟与排序练习</title>
      <link>https://jackgdn.github.io/post/bundle-%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/algo-enumeration&#43;simulation&#43;sorting/</link>
      <pubDate>Wed, 26 Feb 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/algo-enumeration&#43;simulation&#43;sorting/</guid>
      <description>题目来自 AcWing 1210. 连号区间数 | 原题链接 暴力枚举的做法就是遍历 l 和 r 并对区间排序，判断区间内的数字是否连续递增。这样做的时间复杂度是 $O(n^3logn)$， 而 $1\leq N\leq10^4$ 的范围显然不支持这样的算法。经过观察发现，一段连续递增的数列中，其最大值减去最小值一定与数列长度相等。利用这个特点，在遍历 l 与 r 时，只需要维护区间内最大值和最小值，然后随时做判断，这样做的时间复杂度为 $O(n^2)$，在 $N$ 的数据范围内够用。&#xA;1n = int(input().strip()) 2nums = tuple(map(int, input().strip().split())) 3 4count = 0 5for l in range(n): 6 max_val = nums[l] 7 min_val = nums[l] 8 for r in range(l, n): 9 if nums[r] &amp;gt; max_val: 10 max_val = nums[r] 11 elif nums[r] &amp;lt; min_val: 12 min_val = nums[r] 13 14 if max_val - min_val == r - l: 15 count += 1 16 17print(count) 1236.</description>
    </item>
    <item>
      <title>2025寒假算法练习——Week 8</title>
      <link>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025winter-week8/</link>
      <pubDate>Mon, 24 Feb 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025winter-week8/</guid>
      <description>前段时间做的搜索练习题&#xA;习题均来自 NEFU OJ Problem 784 | 白与黑-搜索 Description 有一间长方形的房子，地上铺了白色、黑色两种颜色的正方形瓷砖。你站在其中一块黑色的瓷砖上，只能向相邻的黑色瓷砖移动。请写一个程序，计算你总共能够到达多少块黑色的瓷砖。&#xA;Input 包括多个数据集合。每个数据集合的第一行是两个整数W 和H，分别表示x 方向 和y 方向瓷砖的数量。W 和H 都不超过20。在接下来的H 行中，每行包括W 个字符。 每个字符表示一块瓷砖的颜色，规则如下： 1）‘.’：黑色的瓷砖； 2）‘#’：白色的瓷砖； 3）‘@’：黑色的瓷砖，并且你站在这块瓷砖上。该字符在每个数据集合中唯一出现一次。 当在一行中读入的是两个零时，表示输入结束。&#xA;Output 对每个数据集合，分别输出一行，显示你从初始位置出发能到达的瓷砖数(记数时包括初始位置的瓷砖)。&#xA;Sample Input 16 9 2....#. 3.....# 4...... 5...... 6...... 7...... 8...... 9#@...# 10.#..#. 110 0 Sample Output 145 广搜找连通块。&#xA;1import java.util.Scanner; 2import java.util.Queue; 3import java.util.LinkedList; 4 5public class Main { 6 public static void main(String[] args) { 7 int[] directions = { 1, 0, -1, 0, 0, 1, 0, -1 }; 8 try (Scanner sc = new Scanner(System.</description>
    </item>
    <item>
      <title>每日一题 2.17-2.23</title>
      <link>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-2.17-2.23/</link>
      <pubDate>Sun, 23 Feb 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-2.17-2.23/</guid>
      <description>题目来自 AcWing AcWing 6122. 农夫约翰的奶酪块 | 原题链接 最容易想到的是开一个三维数l组用于记录方块状态，如果此时需要判断是否有一整个 $1\times1\times N$ 的区域被挖空，则对三个方向分别求前缀和，当 $(N,y,z)=0$ 或 $(x,N,z)=0$ 或 $(z,y,N)=0$ 时，可以填充的砖块方案数 $+1$。&#xA;这样看来，能否填充砖块实际上只与 $x=N$ 或 $y=N$ 或 $z=N$ 处的前缀和有关，因此做出优化：用三个二维数组分别表示三个维度的前缀和，或者说对应位置的剩余方块数量，例如 yz_projection[0][1] 就表示 $y=0,\space z=1$ 区域中剩余方块数量。当一个区域中剩余方块数为 0 时，可以填充的砖块方案数 $+1$。&#xA;1n, q = map(int, input().strip().split(&amp;#34; &amp;#34;)) 2yz_projection = [[n for _ in range(n)] for _ in range(n)] 3xz_projection = [[n for _ in range(n)] for _ in range(n)] 4xy_projection = [[n for _ in range(n)] for _ in range(n)] 5 6count = 0 7for _ in range(q): 8 x, y, z = map(int, input().</description>
    </item>
    <item>
      <title>2025寒假算法练习——Week 7</title>
      <link>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025winter-week7/</link>
      <pubDate>Sat, 22 Feb 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025winter-week7/</guid>
      <description>习题均来自 NEFU OJ Problem 1632 | 周末舞会-队列 Description 假设在周末舞会上，男士们和女士们进入舞厅时，各自排成一队。跳舞开始时，依次从男队和女队的队头上各出一人配成舞伴。规定每个舞曲只能有一对跳舞者。若两队初始人数不相同，则较长的那一队中未配对者等待下一轮舞曲。现要求写一个程序，模拟上述舞伴配对问题。&#xA;Input 第 1 行两个正整数，表示男士人数 m 和女士人数 n，1≤m，n≤1000； 第 2 行一个正整数，表示舞曲的数目 k，k≤1000。&#xA;Output 共 k 行，每行两个数，之间用一个空格隔开，表示配对舞伴的序号，男士在前，女士在后。&#xA;Sample Input 12 4 26 Sample Output 11 1 22 2 31 3 42 4 51 1 62 2 用队列反而时空消耗大，不如直接取模。&#xA;1import java.util.Scanner; 2 3public class Main { 4 public static void main(String[] args) { 5 try (Scanner sc = new Scanner(System.in)) { 6 int m = sc.</description>
    </item>
    <item>
      <title>2025寒假算法练习——Week 6</title>
      <link>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025winter-week6/</link>
      <pubDate>Fri, 21 Feb 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025winter-week6/</guid>
      <description>前段时间做 DP 有些头晕，今天做些水题。&#xA;习题均来自 NEFU OJ Problem 1624 | 栈-程序员输入问题 Description 程序员输入程序出现差错时，可以采取以下的补救措施：按错了一个键时，可以补按一个退格符“#”，以表示前一个字符无效；发现当前一行有错，可以按一个退行符“@”，以表示“@”与前一个换行符之间的字符全部无效。&#xA;Input 输入一行字符，个数不超过 100。&#xA;Output 输出一行字符，表示实际有效字符。&#xA;Sample Input 1sdfosif@for (ii#=1,#;i&amp;lt;.#=8;i+++#); Sample Output 1for (i=1;i&amp;lt;=8;i++); Hint 例子输入2：1234## 例子输出2：12&#xA;也许是不同语言对字符串的处理有差异，用 Java 会 WA。&#xA;1#include &amp;lt;iostream&amp;gt; 2#include &amp;lt;stack&amp;gt; 3#include &amp;lt;string&amp;gt; 4 5using namespace std; 6 7int main() { 8 string s; 9 getline(cin, s); 10 stack&amp;lt;char&amp;gt; st; 11 12 for (char ch : s) { 13 if (ch == &amp;#39;#&amp;#39;) { 14 st.</description>
    </item>
    <item>
      <title>动态规划练习（一）</title>
      <link>https://jackgdn.github.io/post/bundle-%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/algo-dp-1/</link>
      <pubDate>Fri, 21 Feb 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/algo-dp-1/</guid>
      <description>下面的题目来自洛谷题单【动态规划1】动态规划的引入&#xA;解决动态规划问题的三个核心：dp 数组含义、状态转移方程、初始值。&#xA;P1216 [IOI 1994] 数字三角形 Number Triangles 题目描述 观察下面的数字金字塔。&#xA;写一个程序来查找从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以走到左下方的点也可以到达右下方的点。&#xA;在上面的样例中，从 $7 \to 3 \to 8 \to 7 \to 5$ 的路径产生了最大权值。&#xA;输入格式 第一个行一个正整数 $r$ ,表示行的数目。&#xA;后面每行为这个数字金字塔特定行包含的整数。&#xA;输出格式 单独的一行,包含那个可能得到的最大的和。&#xA;输入输出样例 #1 输入 #1 15 27 33 8 48 1 0 52 7 4 4 64 5 2 6 5 输出 #1 130 说明/提示 【数据范围】 对于 $100%$ 的数据，$1\le r \le 1000$，所有输入在 $[0,100]$ 范围内。&#xA;题目翻译来自NOCOW。&#xA;USACO Training Section 1.5&#xA;IOI1994 Day1T1</description>
    </item>
    <item>
      <title>背包问题练习（五）——分组背包问题</title>
      <link>https://jackgdn.github.io/post/bundle-%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/algo-knapsackproblem-5/</link>
      <pubDate>Fri, 21 Feb 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/algo-knapsackproblem-5/</guid>
      <description>题目来自洛谷题单背包问题&#xA;分组背包中的每一组都只能选择一种物品。从外向内的遍历顺序依次是：组号 $i$、当前背包重量 $j$ 和当前组内物品 $g_i$。&#xA;P1757 通天之分组背包 题目背景 直达通天路·小 A 历险记第二篇&#xA;题目描述 自 $01$ 背包问世之后，小 A 对此深感兴趣。一天，小 A 去远游，却发现他的背包不同于 $01$ 背包，他的物品大致可分为 $k$ 组，每组中的物品相互冲突，现在，他想知道最大的利用价值是多少。&#xA;输入格式 两个数 $m,n$，表示一共有 $n$ 件物品，总重量为 $m$。&#xA;接下来 $n$ 行，每行 $3$ 个数 $a_i,b_i,c_i$，表示物品的重量，利用价值，所属组数。&#xA;输出格式 一个数，最大的利用价值。&#xA;输入输出样例 #1 输入 #1 145 3 210 10 1 310 5 1 450 400 2 输出 #1 110 说明/提示 $0 \leq m \leq 1000$，$1 \leq n \leq 1000$，$1\leq k\leq 100$，$a_i, b_i, c_i$ 在 int 范围内。</description>
    </item>
    <item>
      <title>Log-2025-02-19</title>
      <link>https://jackgdn.github.io/post/bundle-%E6%97%A5%E5%BF%97/log-2025-02-19/</link>
      <pubDate>Wed, 19 Feb 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E6%97%A5%E5%BF%97/log-2025-02-19/</guid>
      <description>The friend link cards were not visually appealing, so I removed them.&#xA;Additionally, all nav-link classes now have hover effects:&#xA;1.nav-link 2 position: relative 3 &amp;amp;:after 4 content: &amp;#39;&amp;#39; 5 position: absolute 6 left: 0 7 bottom: -5px 8 display: inline-block 9 height: 1px 10 background-color: #0077b8 11 width: 0 12 opacity: 0 13 transition: opacity 0.35s, width 0.35s 14 &amp;amp;:hover:after 15 opacity: 1 16 width: 100% Non-Stop - Hamilton (Original Broadway Cast Recording)&#xD;</description>
    </item>
    <item>
      <title>数学与动态规划练习</title>
      <link>https://jackgdn.github.io/post/bundle-%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/algo-math&#43;dp/</link>
      <pubDate>Mon, 17 Feb 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/algo-math&#43;dp/</guid>
      <description>题目来自 AcWing 1205. 买不到的数目 | 原题链接 首先说暴力做法。假设存在非负整数 $x,\space y$ 使得 $k=nx+my$。同时存在两组数非负整数 $(a_0,b_0)$ 与 $(a_1,b_1)$ 使得 $a_0n-b_0m=1,\space b_1m-a_1n=1$，这样可以得到 $k-1=(x-a_0)n+(y+b_0)m=(x+a_1)n+(y-b_1)m$。从大到小遍历 $k$ 时，第一个无法使 $x-a_0,\space y+b_0$ 或 $x+a_1,\space y-b_1$ 同时为正的 $k$ 即为所求值。&#xA;例如对样例中 $n=4,\space m=7$ 来说，$2\times4-1\times7=1,\space3\times7-5\times4=1$。当 $k=4x+7y,\space x,y\geq0$ 时，$k-1=4(x-2)+7(y+1)=4(x+5)-7(y-3)$。当 $k=18$ 时，$k=1\times4+2\times7$；而当 $k=17$ 时，$k=(-1)\times4+3\times7=6\times4+(-1)\times7$，无法满足条件。&#xA;根据上面的思路写出代码：&#xA;1n, m = map(int, input().strip().split(&amp;#34; &amp;#34;)) 2if n &amp;gt; m: 3 n, m = m, n 4 5i = 0 6while True: 7 if (i * m - 1) % n == 0: 8 km = ((i * m - 1) // n, i) 9 break 10 i += 1 11 12i = 0 13while True: 14 if (i * m + 1) % n == 0: 15 kn = ((i * m + 1) // n, i) 16 break 17 i += 1 18 19k = [0, n] 20for i in range(1, n * m)[::-1]: 21 if k[0] - kn[0] &amp;gt;= 0: 22 k[0] -= kn[0] 23 k[1] += kn[1] 24 elif k[1] - km[1] &amp;gt;= 0: 25 k[0] += km[0] 26 k[1] -= km[1] 27 else: 28 print(i) 29 break 经过观察发现，$k=18$ 能够表示而 $k=17$ 时不能够被表示，是因为 $1-2&amp;lt;0,\space 2-3&amp;lt;0$，推广后可以表示为 $k=nx+my,\space x-a_0&amp;lt;0,\space y-b_1&amp;lt;0$。那么当 $x-a_0=y-b_1=-1$ 时，$k$ 刚好不满足条件且最大，因此可以用 $(a_0-1)n+(b_1-1)m-1$ 来求出这个值。</description>
    </item>
    <item>
      <title>2025寒假算法练习——Week 5</title>
      <link>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025winter-week5/</link>
      <pubDate>Sat, 15 Feb 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025winter-week5/</guid>
      <description>前几天出去旅游所以没咋做题。&#xA;习题均来自 NEFU OJ Problem 75 | 老鼠的旅行 Description 一只老鼠有M磅猫食，然后在N个房间里面用猫食换JavaBean，房间i中能用F[i]磅的猫食来换J[i]磅的JavaBean，而且老鼠可以在一个房间里根据一定比例a%来换取JavaBean. 现在他是这任务分配给你：告诉他，他的JavaBeans的获取能最多。&#xA;Input The input consists of multiple test cases. Each test case begins with a line containing two non-negative integers M and N. Then N lines follow, each contains two non-negative integers J[i] and F[i] respectively. The last test case is followed by two -1′s. All integers are not greater than 1000. M是开始时老鼠有的猫食！&#xA;Output For each test case, print in a single line a real number accurate up to 3 decimal places, which is the maximum amount of JavaBeans that FatMouse can obtain.</description>
    </item>
    <item>
      <title>贪心策略练习</title>
      <link>https://jackgdn.github.io/post/bundle-%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/algo-greedy/</link>
      <pubDate>Sat, 15 Feb 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/algo-greedy/</guid>
      <description>题目来自 AcWing 贪心更像是一种策略和思想，而不是某一种特定的算法。&#xA;1055. 股票买卖 II | 原题链接 这道题的解决思路就是的低价卖高价卖。因为可以买卖多次，因此通过追求局部最优解得到答案。&#xA;1n = int(input()) 2nums = tuple(map(int, input().split(&amp;#34; &amp;#34;))) 3 4profit = 0 5for i in range(1, n): 6 if nums[i] &amp;gt; nums[i - 1]: 7 profit += nums[i] - nums[i - 1] 8 9print(profit) 104. 货仓选址 | 原题链接 货仓的在数轴上的位置一定在最小值和最大值之间，以确保总距离最近。当只有两个商店时，只要货仓的位置在两个商店中间，则总距离一定最小且相等；如果再增加两个商店，当货仓的位置位于所有商店的中间时，总距离依然最小且相等……再假设商店 $A_1,A_2,\cdots A_n$ 的位置升序排列，则货仓的位置一定在编号最中间的商店。&#xA;1n = int(input()) 2nums = list(map(int, input().strip().split(&amp;#34; &amp;#34;))) 3 4if n == 1: 5 print(0) 6 exit() 7 8if n == 2: 9 print(abs(nums[1] - nums[0])) 10 exit() 11 12nums.</description>
    </item>
    <item>
      <title>二分查找与前缀和练习（一）</title>
      <link>https://jackgdn.github.io/post/bundle-%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/algo-binarysearch&#43;prefixsum-1/</link>
      <pubDate>Sun, 09 Feb 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/algo-binarysearch&#43;prefixsum-1/</guid>
      <description>题目来自 AcWing 789. 数的范围 | 原题链接 这道题做法很多。&#xA;使用双指针将每一段的信息存储到字典中：&#xA;1n, q = map(int, input().strip().split(&amp;#34; &amp;#34;)) 2nums = tuple(map(int, input().strip().split(&amp;#34; &amp;#34;))) 3d = dict() 4l = len(nums) 5 6front = 0 7rear = 0 8while front &amp;lt; l: 9 if nums[front] != nums[rear]: 10 d[nums[rear]] = (rear, front - 1) 11 rear = front 12 front += 1 13 14d[nums[rear]] = (rear, front - 1) 15 16result = list() 17for _ in range(q): 18 k = int(input().</description>
    </item>
    <item>
      <title>递归与递推练习</title>
      <link>https://jackgdn.github.io/post/bundle-%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/algo-recursion&#43;iteration/</link>
      <pubDate>Sat, 08 Feb 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/algo-recursion&#43;iteration/</guid>
      <description>题目来自 AcWing 92. 递归实现指数型枚举 | 原题链接 使用 AcWing 上的挑战模式做题，所以码风看上去比较乱。&#xA;1n = int(input()) 2nums = list(range(1, n + 1)) 3 4def dfs(current, nums): 5 if len(nums) == 0: 6 print(&amp;#34; &amp;#34;.join(current)) 7 return 8 9 dfs(current, nums[1:]) 10 dfs(current + [str(nums[0])], nums[1:]) 11 12dfs(list(), nums) 94. 递归实现排列型枚举 | 原题链接 全排列，一般做法：&#xA;1n = int(input()) 2nums = {k: True for k in range(1, n + 1)} 3result = list() 4 5def dfs(current): 6 if not any(nums.</description>
    </item>
    <item>
      <title>2025寒假算法练习——Week 4</title>
      <link>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025winter-week4/</link>
      <pubDate>Thu, 06 Feb 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025winter-week4/</guid>
      <description>习题均来自 NEFU OJ Problem 1077 | 最大公约数和最小公倍数 Description 请计算2个数的最大公约数和最小公倍数；（最大公约数可以使用辗转相除法，最小公倍数=2个数的乘积/它们的最大公约数；）&#xA;Input 输入数据有多组，每组2个正整数a,b(2&amp;lt;a,b&amp;lt;1000)&#xA;Output 在一行内输出a和b的最大公约数和最小公倍数；&#xA;Sample Input 115 10 Sample Output 15 30 1import java.util.Scanner; 2 3public class Main { 4 public static void main(String[] args) { 5 Scanner scanner = new Scanner(System.in); 6 while (scanner.hasNextInt()) { 7 int a = scanner.nextInt(); 8 int b = scanner.nextInt(); 9 int d = gcd(a, b); 10 int m = a * b / d; 11 System.</description>
    </item>
    <item>
      <title>搜索练习</title>
      <link>https://jackgdn.github.io/post/bundle-%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/algo-searching/</link>
      <pubDate>Tue, 04 Feb 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/algo-searching/</guid>
      <description>Info&#xA;深度优先搜索适合用于查找路径、解决组合问题，缺点是递归调用的时间复杂度高。 广度优先搜索适合用于找最短路径，缺点是空间复杂度高。 [NOIP2001 普及组] 求先序排列 题目描述 给出一棵二叉树的中序与后序排列。求出它的先序排列。（约定树结点用不同的大写字母表示，且二叉树的节点个数 $ \le 8$）。&#xA;输入格式 共两行，均为大写字母组成的字符串，表示一棵二叉树的中序与后序排列。&#xA;输出格式 共一行一个字符串，表示一棵二叉树的先序。&#xA;样例 #1 样例输入 #1 1BADC 2BDCA 样例输出 #1 1ABCD 提示 【题目来源】&#xA;NOIP 2001 普及组第三题&#xA;题解 中序遍历是以左-&amp;gt;中-&amp;gt;右的顺序遍历树，后续遍历是以左-&amp;gt;右-&amp;gt;中的顺序遍历树。根据定义我们可以知道以下规律：&#xA;后序遍历的最后一个节点一定是根节点，对子树同样成立 中序遍历左子节点一定在根节点前，根节点一定在右子节点前，对子树同样成立 后序遍历左子节点一定在右子节点前，对子树同样成立 随后可以按照这些规律设计算法，还原一颗二叉树：&#xA;从后向前读取后序遍历字符串，每一个字符都是某个树的根节点 在中序遍历字符串中找到这个根节点字符，这个字符前面的 n 个字符都属于左子树，后面的 m 个字符都属于右子树 后序遍历字符串的前 n 个字符属于左子树，紧接着的 m 个字符属于右子树 按照上述规律处理子树 1class Node: 2 3 def __init__(self, left=None, right=None, value=str()): 4 self.left = left 5 self.right = right 6 self.value = value 7 8 9def dfs(inorder, postorder): 10 if not postorder: 11 return None 12 node = Node() 13 root = postorder[-1] 14 node.</description>
    </item>
    <item>
      <title>2025寒假算法练习——Week 3</title>
      <link>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025winter-week3/</link>
      <pubDate>Tue, 28 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025winter-week3/</guid>
      <description>习题均来自 NEFU OJ Problem 8 | 二倍的问题 Description 给定2到15个不同的正整数，你的任务是计算这些数里面有多少个数对满足：数对中一个数是另一个数的两倍。比如给定1 4 3 2 9 7 18 22，得到的答案是3，因为2是1的两倍，4是2个两倍，18是9的两倍。&#xA;Input 输入包括n组测试数据。每组数据包括一行，给出2到15个两两不同且小于100的正整数。每一行最后一个数是0，表示这一行的结束后，这个数不属于那2到15个给定的正整数。&#xA;Output 对每组输入数据，输出一行，给出有多少个数对满足其中一个数是另一个数的两倍。&#xA;Sample Input 13 21 4 3 2 9 7 18 22 0 32 4 8 10 0 47 5 11 13 1 3 0 Sample Output 13 22 30 简单题。唯一奇怪的是使用 bitset 比直接用 int* 的内存开销大。&#xA;1#define _CRT_SECURE_NO_WARNINGS 2 3#include &amp;lt;cstdio&amp;gt; 4#include &amp;lt;cstring&amp;gt; 5 6using namespace std; 7 8int max_value, i, value, n, cnt; 9int values[100]; 10 11int main() { 12 scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); 13 while (n--) { 14 memset(values, 0, sizeof(values)); 15 max_value = -1; 16 cnt = 0; 17 18 while (scanf(&amp;#34;%d&amp;#34;, &amp;amp;value) &amp;amp;&amp;amp; value !</description>
    </item>
    <item>
      <title>背包问题练习（四）——多维背包问题</title>
      <link>https://jackgdn.github.io/post/bundle-%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/algo-knapsackproblem-4/</link>
      <pubDate>Sun, 26 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/algo-knapsackproblem-4/</guid>
      <description>题目来自洛谷题单背包问题 和 NEFU OJ&#xA;QWQ 和 QAQ (reprise) 之前遇见过的 QWQ 和 QAQ 这道题，实际上也可以按照三维完全背包的方式来解（时间复杂度和空间复杂度更高，但是可以 AC）。&#xA;题解 1#define _CRT_SECURE_NO_WARNINGS 2 3#include &amp;lt;cstdio&amp;gt; 4#include &amp;lt;cstring&amp;gt; 5#include &amp;lt;algorithm&amp;gt; 6 7using namespace std; 8 9int t, a[4] = { 0 }, b[4] = { 0 }, c[4] = { 0 }, d[4] = { 0 }, dp[205][205][205], i, j, k, l; 10 11int main() { 12 scanf(&amp;#34;%d&amp;#34;, &amp;amp;t); 13 14 while (t--) { 15 for (i = 1; i &amp;lt;= 4; i++) { 16 scanf(&amp;#34;%d%d%d&amp;#34;, &amp;amp;a[i % 4], &amp;amp; b[i % 4], &amp;amp;c[i % 4]); 17 } 18 scanf(&amp;#34;%d%d%d&amp;#34;, &amp;amp;d[1], &amp;amp;d[2], &amp;amp;d[3]); 19 20 memset(dp, 0, sizeof(dp)); 21 for (i = 1; i &amp;lt;= 3; i++) { 22 for (j = a[i]; j &amp;lt;= a[0]; j++) { 23 for (k = b[i]; k &amp;lt;= b[0]; k++) { 24 for (l = c[i]; l &amp;lt;= c[0]; l++) { 25 dp[j][k][l] = max(dp[j][k][l], dp[j - a[i]][k - b[i]][l - c[i]] + d[i]); 26 } 27 } 28 } 29 } 30 31 printf(&amp;#34;%d\n&amp;#34;, dp[a[0]][b[0]][c[0]]); 32 } 33} 榨取kkksc03 题目描述 洛谷 2 的团队功能是其他任何 OJ 和工具难以达到的。借助洛谷强大的服务器资源，任何学校都可以在洛谷上零成本的搭建 OJ 并高效率的完成训练计划。</description>
    </item>
    <item>
      <title>背包问题练习（三）——多重背包问题</title>
      <link>https://jackgdn.github.io/post/bundle-%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/algo-knapsackproblem-3/</link>
      <pubDate>Sat, 25 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/algo-knapsackproblem-3/</guid>
      <description>多重背包问题讲解视频：多重背包两种解法硬头皮算和二进制优化 动态规划&#xA;题目来自洛谷题单背包问题&#xA;樱花 题目背景 《爱与愁的故事第四弹·plant》第一章。&#xA;题目描述 爱与愁大神后院里种了 $n$ 棵樱花树，每棵都有美学值 $C_i(0 \le C_i \le 200)$。爱与愁大神在每天上学前都会来赏花。爱与愁大神可是生物学霸，他懂得如何欣赏樱花：一种樱花树看一遍过，一种樱花树最多看 $P_i(0 \le P_i \le 100)$ 遍，一种樱花树可以看无数遍。但是看每棵樱花树都有一定的时间 $T_i(0 \le T_i \le 100)$。爱与愁大神离去上学的时间只剩下一小会儿了。求解看哪几棵樱花树能使美学值最高且爱与愁大神能准时（或提早）去上学。&#xA;输入格式 共 $n+1$行：&#xA;第 $1$ 行：现在时间 $T_s$（几时：几分），去上学的时间 $T_e$（几时：几分），爱与愁大神院子里有几棵樱花树 $n$。这里的 $T_s$，$T_e$ 格式为：hh:mm，其中 $0 \leq hh \leq 23$，$0 \leq mm \leq 59$，且 $hh,mm,n$ 均为正整数。&#xA;第 $2$ 行到第 $n+1$ 行，每行三个正整数：看完第 $i$ 棵树的耗费时间 $T_i$，第 $i$ 棵树的美学值 $C_i$，看第 $i$ 棵树的次数 $P_i$（$P_i=0$ 表示无数次，$P_i$ 是其他数字表示最多可看的次数 $P_i$）。&#xA;输出格式 只有一个整数，表示最大美学值。&#xA;样例 #1 样例输入 #1 16:50 7:00 3 22 1 0 33 3 1 44 5 4 样例输出 #1 111 提示 $100%$ 数据：$T_e-T_s \leq 1000$（即开始时间距离结束时间不超过 $1000$ 分钟），$n \leq 10000$。保证 $T_e,T_s$ 为同一天内的时间。</description>
    </item>
    <item>
      <title>2025寒假算法练习——Week 2</title>
      <link>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025winter-week2/</link>
      <pubDate>Fri, 24 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025winter-week2/</guid>
      <description>习题均来自 NEFU OJ Problem 1481 | 谁考了第k名-排序 Description 在一次考试中，每个学生的成绩都不相同，现知道了每个学生的学号和成绩，求考第k名学生的学号和成绩。&#xA;Input 第一行有两个整数，分别是学生的人数n（1≤n≤100），和求第k名学生的k（1≤k≤n）。 其后有n行数据，每行包括一个学号（整数）和一个成绩（浮点数），中间用一个空格分隔。&#xA;Output 输出第k名学生的学号和成绩，中间用空格分隔。（注：请用%g输出成绩）&#xA;Sample Input 15 3 290788001 67.8 390788002 90.3 490788003 61 590788004 68.4 690788005 73.9 Sample Output 190788004 68.4 Source 奥赛一本通&#xA;这道题可以自己搓一个排序，也可以用结构体排序解决。&#xA;1#include &amp;lt;iostream&amp;gt; 2#include &amp;lt;algorithm&amp;gt; 3 4using namespace std; 5 6struct Student { 7 int id;z 8 float score; 9}; 10 11bool cmp(Student a, Student b) { 12 return a.score &amp;gt; b.score; 13} 14 15int main() { 16 Student students[100]; 17 int n, k; 18 cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k; 19 for (int i = 0; i &amp;lt; n; i++) { 20 cin &amp;gt;&amp;gt; students[i].</description>
    </item>
    <item>
      <title>Java 练习（七）</title>
      <link>https://jackgdn.github.io/post/bundle-java%E7%BB%83%E4%B9%A0/java%E7%BB%83%E4%B9%A07/</link>
      <pubDate>Tue, 21 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-java%E7%BB%83%E4%B9%A0/java%E7%BB%83%E4%B9%A07/</guid>
      <description>源代码：Java-OOP-Practice&#xA;题目网页截图如下：</description>
    </item>
    <item>
      <title>背包问题练习（二）——完全背包问题</title>
      <link>https://jackgdn.github.io/post/bundle-%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/algo-knapsackproblem-2/</link>
      <pubDate>Tue, 21 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/algo-knapsackproblem-2/</guid>
      <description>完全背包问题讲解视频：新手向 再冲完全背包两种解法 二维数组 滚动数组&#xA;题目来自洛谷题单背包问题&#xA;疯狂的采药 题目背景 此题为纪念 LiYuxiang 而生。&#xA;题目描述 LiYuxiang 是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同种类的草药，采每一种都需要一些时间，每一种也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”&#xA;如果你是 LiYuxiang，你能完成这个任务吗？&#xA;此题和原题的不同点：&#xA;$1$. 每种草药可以无限制地疯狂采摘。&#xA;$2$. 药的种类眼花缭乱，采药时间好长好长啊！师傅等得菊花都谢了！&#xA;输入格式 输入第一行有两个整数，分别代表总共能够用来采药的时间 $t$ 和代表山洞里的草药的数目 $m$。&#xA;第 $2$ 到第 $(m + 1)$ 行，每行两个整数，第 $(i + 1)$ 行的整数 $a_i, b_i$ 分别表示采摘第 $i$ 种草药的时间和该草药的价值。&#xA;输出格式 输出一行，这一行只包含一个整数，表示在规定的时间内，可以采到的草药的最大总价值。&#xA;样例 #1 样例输入 #1 170 3 271 100 369 1 41 2 样例输出 #1 1140 提示 数据规模与约定 对于 $30%$ 的数据，保证 $m \le 10^3$ 。 对于 $100%$ 的数据，保证 $1 \leq m \le 10^4$，$1 \leq t \leq 10^7$，且 $1 \leq m \times t \leq 10^7$，$1 \leq a_i, b_i \leq 10^4$。 题解 完全背包模板题，用 Python 写的话，不管是用二维数组还是一维滚动数组都会 MLE，所以使用 Java。 另外这道题的数据范围比较大，dp 数组使用 long 类型。</description>
    </item>
    <item>
      <title>Java 练习（六）</title>
      <link>https://jackgdn.github.io/post/bundle-java%E7%BB%83%E4%B9%A0/java%E7%BB%83%E4%B9%A06/</link>
      <pubDate>Mon, 20 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-java%E7%BB%83%E4%B9%A0/java%E7%BB%83%E4%B9%A06/</guid>
      <description>已知高斯随机数的公式为：$w=sin(2\pi v)(-21lnu)^{\frac12}$，从键盘输入一个（0,1）范围内的u，再输入一个（0,1）范围内的v。计算并输出w的值。 1example: 2 3input: 40.2 50.3 6 7output: 85.529082710300016 1package com.jackgdn; 2 3import java.util.Scanner; 4 5public class Main { 6 public static void main(String[] args) { 7 Scanner scanner = new Scanner(System.in); 8 double u = scanner.nextDouble(); 9 double v = scanner.nextDouble(); 10 scanner.close(); 11 12 double w = Math.sin(2 * Math.PI * v) * Math.sqrt(-21.0 * Math.log(u)); 13 System.out.println(w); 14 } 15} 从键盘依次读入两个整数字符，判断一下，他们是否互素。如果互素打印True，不互素打印False。 1example: 2 3input： 49 56 6 7output: 8False 1package com.</description>
    </item>
    <item>
      <title>2025寒假算法练习——Week 1</title>
      <link>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025winter-week1/</link>
      <pubDate>Sun, 19 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025winter-week1/</guid>
      <description>习题均来自 NEFU OJ Problem 357 | 天下无双 Description 太极生两仪,两仪生四象,四象生八卦,八卦生万物。天地初开，万物皆欲成双成对；芸芸丛生，谁愿孤苦伶仃。知音难觅，阳春白雪绕梁何久，千古一绝，神雕侠女驰骋九洲。 天下岂无双？千古绝唱为知音。情寄雨丝丝，述相思之意；梦随风万里，寻同道之人。共聚一堂，为梦想而努力；携手共进，为程序而疯狂！ 夜夜编程不漫长，只因与君共拼搏…… 给定n个数，其数值范围在1到n-1中，已知其中必有两个数是相同的，要求你找出并输出。（2&amp;lt;=n&amp;lt;=1，000,000）&#xA;Input 多组数据输入. 每组输入第一行一个数n。第二行n个数，其数值范围为1..n-1。&#xA;Output 每组输出一行一个数，即出现过两次的数。&#xA;Sample Input 15 22 3 1 4 2 38 47 6 1 2 3 5 4 7 Sample Output 12 27 第一眼看到这道题的时候，我想到了力扣两数之和，因而选择使用哈希表来解决这一问题：&#xA;1import java.util.Scanner; 2import java.util.Map; 3import java.util.HashMap; 4 5public class Main { 6 public static void main(String[] args) { 7 try (Scanner scanner = new Scanner(System.in)) { 8 while (scanner.hasNextInt()) { 9 Map&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); 10 int n = scanner.</description>
    </item>
    <item>
      <title>背包问题练习（一）——01背包问题</title>
      <link>https://jackgdn.github.io/post/bundle-%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/algo-knapsackproblem-1/</link>
      <pubDate>Sat, 18 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/algo-knapsackproblem-1/</guid>
      <description>通俗易懂的 0-1 背包问题讲解视频：带你学透0-1背包问题！| 关于背包问题，你不清楚的地方，这里都讲了！| 动态规划经典问题 | 数据结构与算法&#xA;题目来自洛谷题单背包问题&#xA;[NOIP2005 普及组] 采药 题目描述 辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”&#xA;如果你是辰辰，你能完成这个任务吗？&#xA;输入格式 第一行有 $2$ 个整数 $T$（$1 \le T \le 1000$）和 $M$（$1 \le M \le 100$），用一个空格隔开，$T$ 代表总共能够用来采药的时间，$M$ 代表山洞里的草药的数目。&#xA;接下来的 $M$ 行每行包括两个在 $1$ 到 $100$ 之间（包括 $1$ 和 $100$）的整数，分别表示采摘某株草药的时间和这株草药的价值。&#xA;输出格式 输出在规定的时间内可以采到的草药的最大总价值。&#xA;样例 #1 样例输入 #1 170 3 271 100 369 1 41 2 样例输出 #1 13 提示 【数据范围】&#xA;对于 $30%$ 的数据，$M \le 10$； 对于全部的数据，$M \le 100$。 【题目来源】&#xA;NOIP 2005 普及组第三题</description>
    </item>
    <item>
      <title>Java 练习（五）</title>
      <link>https://jackgdn.github.io/post/bundle-java%E7%BB%83%E4%B9%A0/java%E7%BB%83%E4%B9%A05/</link>
      <pubDate>Tue, 14 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-java%E7%BB%83%E4%B9%A0/java%E7%BB%83%E4%B9%A05/</guid>
      <description>从键盘输入一个m，代表二维矩阵A的行和列，然后输入m行数据，每行数据用空格分割。再输入一个n，代表矩阵的幂运算次数，即n = 2输出A * A 的值。n = 3 输出A * A *A的值。 1example： 2 3input： 42 51 1 61 1 72 8 9output： 10[[2, 2], [2, 2]] 1package com.jackgdn; 2 3import java.util.Scanner; 4import java.util.Arrays; 5 6public class Main { 7 public static void main(String[] args) { 8 Scanner scanner = new Scanner(System.in); 9 int order = scanner.nextInt(); 10 int[][] matrix = new int[order][order]; 11 for (int i = 0; i &amp;lt; order; i++) { 12 for (int j = 0; j &amp;lt; order; j++) { 13 matrix[i][j] = scanner.</description>
    </item>
    <item>
      <title>Java 练习（四）</title>
      <link>https://jackgdn.github.io/post/bundle-java%E7%BB%83%E4%B9%A0/java%E7%BB%83%E4%B9%A04/</link>
      <pubDate>Fri, 10 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-java%E7%BB%83%E4%B9%A0/java%E7%BB%83%E4%B9%A04/</guid>
      <description>从键盘接收一个长字符串，统计其中的元音字母（包括大写和小写的），并按照字母表的顺序，把元音和元音的个数组成一个一位数组元素存在二维数组中。假设元音a的个数为0个，应该在数组中添加元素[&amp;quot;a&amp;quot;, 0]。（注意：大写和小写的元音，统一转换为小写字母计算元音个数） 1example: 2 3input: 4diwisniisiaidiengiowiwiOAIANAIDID 5 6output: 7[[&amp;#39;a&amp;#39;, 4], [&amp;#39;e&amp;#39;, 1], [&amp;#39;i&amp;#39;, 13], [&amp;#39;o&amp;#39;, 2], [&amp;#39;u&amp;#39;, 0]] 1package com.jackgdn; 2 3import java.util.Scanner; 4import java.util.Map; 5import java.util.TreeMap; 6import java.util.List; 7import java.util.ArrayList; 8 9public class Main { 10 public static void main(String[] args) { 11 String s; 12 try (Scanner scanner = new Scanner(System.in)) { 13 s = scanner.nextLine(); 14 } 15 16 Map&amp;lt;Character, Integer&amp;gt; result = new TreeMap&amp;lt;&amp;gt;(); // TreeMap 将 key 按字典序排序 17 for (char c : new char[] { &amp;#39;a&amp;#39;, &amp;#39;e&amp;#39;, &amp;#39;i&amp;#39;, &amp;#39;o&amp;#39;, &amp;#39;u&amp;#39; }) { 18 result.</description>
    </item>
    <item>
      <title>Java 练习（三）</title>
      <link>https://jackgdn.github.io/post/bundle-java%E7%BB%83%E4%B9%A0/java%E7%BB%83%E4%B9%A03/</link>
      <pubDate>Thu, 09 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-java%E7%BB%83%E4%B9%A0/java%E7%BB%83%E4%B9%A03/</guid>
      <description>从键盘输入一个n，代表二维数组的行和列，依次读入n行由空格和数字字符组成的字符串，将字符串中的每个数字字符转换成整形数据，存成二维数组的一行，如果输入的数字字符数目少于n个，以0补足，如果超过n个，截取前n位。 1example: 2 3input: 45 53 2 1 7 6 8 611 2 4 12 5 74 3 1 87 6 5 91 10 11output: 12[[3, 2, 1, 7, 6], [11, 2, 4, 12, 5], [4, 3, 1, 0, 0], [7, 6, 5, 0, 0], [1, 0, 0, 0, 0]] 1import java.util.Scanner; 2import java.util.Arrays; 3 4public class Main { 5 public static void main(String[] args) { 6 Scanner scanner = new Scanner(System.</description>
    </item>
    <item>
      <title>Java 练习（二）</title>
      <link>https://jackgdn.github.io/post/bundle-java%E7%BB%83%E4%B9%A0/java%E7%BB%83%E4%B9%A02/</link>
      <pubDate>Sun, 29 Dec 2024 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-java%E7%BB%83%E4%B9%A0/java%E7%BB%83%E4%B9%A02/</guid>
      <description>从键盘接收两个数据，一个代表鸡和兔子的头数，一个代表，鸡和兔子的腿数。编写一个程序，计算有多少只鸡，多少只兔子。如果无解，则输出：No solution. 1input: 235 394 4 5output: 6rabbit: 12 chicken: 23 7 8input: 920 1040 11 12output: 13only have chicken: 20 14 15input: 1615 1760 18 19output: 20only have rabbit: 15 21 22input: 2310 24100 25 26output: 27No solution 1import java.util.Scanner; 2 3public class Main { 4 public static void main(String[] args) { 5 try (Scanner scanner = new Scanner(System.in)) { 6 int heads = scanner.nextInt(); 7 int legs = scanner.</description>
    </item>
    <item>
      <title>Java 练习（一）</title>
      <link>https://jackgdn.github.io/post/bundle-java%E7%BB%83%E4%B9%A0/java%E7%BB%83%E4%B9%A01/</link>
      <pubDate>Sat, 28 Dec 2024 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-java%E7%BB%83%E4%B9%A0/java%E7%BB%83%E4%B9%A01/</guid>
      <description>小明在银行的存款有1万元，已知，银行的年利率是1.9%，请问，不取出钱的情况下，存五年后，小明一共可以取出多少钱？ 注意：输出的钱数单位为元。&#xA;1public class Main { 2 public static void main(String[] args) { 3 double principal = 10000; 4 double savingPeriod = 5; 5 for (int i = 1; i &amp;lt;= savingPeriod; i++){ 6 principal *= 1.019; 7 } 8 System.out.println(principal); 9 } 10} 如上题，小明有一笔存款，存款的钱数由键盘来录入，存款的利率是1.9%，输入存款年限，根据年限和本金，给出最终取出的钱数。 以下为给出的测试样例。&#xA;1example： 2 3input： 410000 55 6 7output： 810986.792440810985 1import java.util.Scanner; 2 3public class Main { 4 public static void main(String[] args) { 5 Scanner scanner = new Scanner(System.</description>
    </item>
    <item>
      <title>Rust 练习（三）</title>
      <link>https://jackgdn.github.io/post/bundle-rust%E7%BB%83%E4%B9%A0/rust3/</link>
      <pubDate>Wed, 04 Dec 2024 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-rust%E7%BB%83%E4%B9%A0/rust3/</guid>
      <description>已知高斯随机数的公式为：$w=sin(2\pi v)(-21lnu)^{\frac{1}{2}}$,从键盘输入一个（0,1）范围内的u，再输入一个（0,1）范围内的v。计算并输出w的值。 example:&#xA;input:&#xA;0.2&#xA;0.3&#xA;output:&#xA;5.529082710300016&#xA;1use std::f64::consts::PI; 2use std::io::stdin; 3 4fn main() { 5 let mut input = String::new(); 6 stdin().read_line(&amp;amp;mut input).expect(&amp;#34;Failed to read line&amp;#34;); 7 let u: f64 = input.trim().parse().expect(&amp;#34;Failed to parse input&amp;#34;); 8 input.clear(); 9 stdin().read_line(&amp;amp;mut input).expect(&amp;#34;Failed to read line&amp;#34;); 10 let v: f64 = input.trim().parse().expect(&amp;#34;Failed to parse input&amp;#34;); 11 12 let w = (2.0 * PI * v).sin() * (-21.0 * u.ln()).powf(0.5); 13 println!</description>
    </item>
    <item>
      <title>Rust 练习（二）</title>
      <link>https://jackgdn.github.io/post/bundle-rust%E7%BB%83%E4%B9%A0/rust2/</link>
      <pubDate>Sat, 30 Nov 2024 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-rust%E7%BB%83%E4%B9%A0/rust2/</guid>
      <description>从键盘输入一个n，代表一维数组包含的元素数，从键盘读入一个由数字字符和空格组成的字符串，并将它们转换成int型存入到一维数组中。如果得到的数字不足n位，剩余的几个数组元素由0补足，如果超过n位截取前n位组成的数组，并输出该数组。 example:&#xA;input:&#xA;5&#xA;2 3 1 7 10 15&#xA;output:&#xA;[2, 3, 1, 7, 10]&#xA;input:&#xA;4&#xA;10 2&#xA;output:&#xA;[10, 2, 0, 0]&#xA;1use std::io::stdin; 2 3fn main() { 4 let mut input = String::new(); 5 stdin().read_line(&amp;amp;mut input).expect(&amp;#34;Failed to read line&amp;#34;); 6 let n: i32 = input.trim().parse().expect(&amp;#34;Failed to parse input&amp;#34;); 7 8 input.clear(); 9 stdin().read_line(&amp;amp;mut input).expect(&amp;#34;Failed to read line&amp;#34;); 10 let mut nums: Vec&amp;lt;i32&amp;gt; = input 11 .</description>
    </item>
    <item>
      <title>Rust 练习（一）</title>
      <link>https://jackgdn.github.io/post/bundle-rust%E7%BB%83%E4%B9%A0/rust/</link>
      <pubDate>Thu, 28 Nov 2024 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-rust%E7%BB%83%E4%B9%A0/rust/</guid>
      <description>从键盘接收一个整数，判断一下该整数是奇数还是偶数，如果是奇数，输出“odd&amp;quot;，如果是偶数，输出“even” example:&#xA;input:&#xA;20&#xA;output:&#xA;even&#xA;1use std::io::stdin; 2 3fn main() { 4 let mut num: String = String::new(); 5 stdin().read_line(&amp;amp;mut num).expect(&amp;#34;Failed to read line&amp;#34;); 6 let num: i32 = num.trim().parse().expect(&amp;#34;Failed to parse number&amp;#34;); 7 if num % 2 == 0 { 8 println!(&amp;#34;even&amp;#34;); 9 } else { 10 println!(&amp;#34;odd&amp;#34;); 11 } 12} 从键盘输入一个代表年份的四位数，判断一下当前输入的年份是不是闰年，是闰年返回“is leap year”，不是闰年返回“is not leap year” example:&#xA;input:&#xA;2024&#xA;output:&#xA;is leap year&#xA;1use std::io::stdin; 2 3fn main() { 4 let mut year: String = String::new(); 5 stdin().</description>
    </item>
    <item>
      <title>Python 一句话代码技巧（三）</title>
      <link>https://jackgdn.github.io/post/bundle-python-%E5%AD%A6%E4%B9%A0/python%E4%B8%80%E5%8F%A5%E8%AF%9D%E4%BB%A3%E7%A0%81-pt-3/</link>
      <pubDate>Sat, 16 Nov 2024 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-python-%E5%AD%A6%E4%B9%A0/python%E4%B8%80%E5%8F%A5%E8%AF%9D%E4%BB%A3%E7%A0%81-pt-3/</guid>
      <description>前面两篇笔记里介绍的内容都不过是开胃小菜，这一篇笔记里记录的才是硬菜，写一句话代码时真正实用的技巧。&#xA;lambda 匿名函数 lambda 关键字的用法如下 lambda [parameters]: expression，其中 expression 的结果直接作为返回值。这一结构决定了：&#xA;lambda 定义的匿名函数中只能有一个表达式 lambda 定义的匿名函数一定有返回值 下面是一个 lambda 的使用示例： 1print(list(map(lambda x: x + 1, [1, 1, 4, 5, 1, 4]))) 2 3# output: [2, 2, 5, 6, 2, 5] lambda函数经常与 map() 函数及其他需要以函数作为为参数的函数共同使用，用于提高代码的简洁性与灵活性。因为 lambda 会创建一个函数，这个匿名函数也可以使用常规的 function([parameters]) 的方式调用：&#xA;1print((lambda x: [i + 1 if i % 2 else i for i in x])([1, 1, 4, 5, 1, 4])) 2 3# output: [2, 2, 4, 6, 2, 4] 在上面这个例子中，x 为匿名函数的形式参数，后面的列表 [1, 1, 4, 5, 1, 4] 是传入函数的实际参数。</description>
    </item>
    <item>
      <title>超星学习通自动化完成任务点（GUI 版）项目介绍</title>
      <link>https://jackgdn.github.io/post/chaoxing-gui/</link>
      <pubDate>Sun, 10 Nov 2024 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/chaoxing-gui/</guid>
      <description>过去一星期，我开发了一个名为 chaoxing-GUI 的项目，并将其上传至 Github。这个项目基于 Github 上的 Samueli924/chaoxing 项目开发。原项目的描述为“超星学习通自动化完成任务点(命令行版)”，而我在这个命令行程序基础上，使用 PySide6 模块为其添加了图形化的界面。目前程序的功能较为单一，我会在后续更新中，逐步合并原项目中程序提供的功能。&#xA;项目的详细信息可见 README 文档。</description>
    </item>
    <item>
      <title>Python 一句话代码技巧（二）</title>
      <link>https://jackgdn.github.io/post/bundle-python-%E5%AD%A6%E4%B9%A0/python%E4%B8%80%E5%8F%A5%E8%AF%9D%E4%BB%A3%E7%A0%81-pt-2/</link>
      <pubDate>Thu, 31 Oct 2024 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-python-%E5%AD%A6%E4%B9%A0/python%E4%B8%80%E5%8F%A5%E8%AF%9D%E4%BB%A3%E7%A0%81-pt-2/</guid>
      <description>使用 sum() 函数或 list.count() 方法统计数量 sum() 函数的常规用法是求一个可迭代对象里面各元素的和（如果可求和的话）。当然，如果我们对一个只有 1 和 0 的列表求和，那么就可以求出列表中 1 的数量。根据这个思路，我们可以先将待处理的列表转换为一个仅存储布尔值的列表，再对其求和，就可以统计出其中满足条件元素的数量。例如还是上一篇文章中的例子：&#xA;1value = 7 2count = 0 3lst = [1, 1, 4, 5, 1, 4, 1, 9, 1, 9, 8, 10] 4for i in lst: 5 if i &amp;gt; value: 6 count += 1 7print(count) 8 9# output: 4 我们结合推导式创建一个新的列表，将满足条件的存储为 1，这样再求和。&#xA;1print(sum(1 if i &amp;gt; 7 else 0 for i in [1, 1, 4, 5, 1, 4, 1, 9, 1, 9, 8, 10])) 2# 如果只有 if 语句，则将 if 语句放到 for 后。如果是 if-else 三元表达式，则将 if-else 前置。 3# 也可以写成 4print([1 for i in [1, 1, 4, 5, 1, 4, 1, 9, 1, 9, 8, 10] if i &amp;gt; 7].</description>
    </item>
    <item>
      <title>Python 一句话代码技巧（一）</title>
      <link>https://jackgdn.github.io/post/bundle-python-%E5%AD%A6%E4%B9%A0/python%E4%B8%80%E5%8F%A5%E8%AF%9D%E4%BB%A3%E7%A0%81-pt-1/</link>
      <pubDate>Sun, 27 Oct 2024 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-python-%E5%AD%A6%E4%B9%A0/python%E4%B8%80%E5%8F%A5%E8%AF%9D%E4%BB%A3%E7%A0%81-pt-1/</guid>
      <description>我还在学习 CTF 时，我接触到了一些 Python 的有趣特性，例如使用 NFKC 进行沙箱逃逸以及 Python 存储对象时的一些机制。最近我对 Python 的“一句话代码”产生了兴趣，具体来说就是使用一些特别的 Python 编程技巧以及语法糖将大段代码压缩到一行或少数几行中，用几行短短的代码（但是每一行都会很长）实现一个完整的功能。例如说下面这三行代码分别时冒泡排序、选择排序和插入排序算法的“一句话代码”形式。&#xA;1print((bubble_sort := lambda lst: ([(tmp := lst.__getitem__(i), lst.__setitem__(i, lst.__getitem__(j)), lst.__setitem__(j, tmp), None)[-1] for i in range(len(lst) - 1) for j in range(i, len(lst)) if lst[j] &amp;lt; lst[i]] + lst)[-len(lst):])([int(i) for i in input().split()])) 2# 冒泡排序 3 4print((selection_sort := lambda lst: ([(index := i, j := i + 1, index := (my_while := lambda index, lst, j: my_while(index := j if lst[j] &amp;lt; lst[index] else index, lst, j := j + 1) if j &amp;lt; len(lst) else index)(index, lst, j), tmp := lst.</description>
    </item>
    <item>
      <title>终端播放视频</title>
      <link>https://jackgdn.github.io/post/%E7%BB%88%E7%AB%AF%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91/</link>
      <pubDate>Sat, 12 Oct 2024 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/%E7%BB%88%E7%AB%AF%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91/</guid>
      <description>之前见过使用 telnet towel.blinkenlights.nl 命令在终端中播放《星球大战》。于是想自己也做一个。我选择的是《米奇妙妙屋》的片头。&#xA;我的思路是这样的：下载视频 -&amp;gt; 将视频提取成一张张图片 -&amp;gt; 将图片转化为像素画 -&amp;gt; 连续播放像素画 -&amp;gt; 放到服务器上使其他人也可以连接&#xA;视频切片 使用 FFmpeg 工具将视频切片。我选择将帧率定为 16，即每秒钟播放 16 张“图片”。如果帧率太高，终端会由于自身绘制速度及网络带宽导致刷新缓慢，进而导致视频看起来“很慢”。最后尝试时，Electerm 以及 Termux 的表现都很差，而 Windows 原生的 Shell（无论是 cmd 还是 Powershell）都有更优秀的表现。&#xA;使用 FFmpeg 视频切片的命令如下：&#xA;1sudo ffmpeg -i vid/vid.mp4 -vf fps=16 pic/frame_%04d.png 参数 解释 -i 输入文件 -v 设置视频限制 执行完上面的命令，我得到了 1354 张图片，这些图片名称依次为 frame_0001.png 到 frame_1354.png。&#xA;图像转字符 我使用 jp2a 工具将图片转化为字符。命令为：&#xA;1counter=1; 2for img in pic/frame_*.png; do 3 sudo jp2a --colors --color-depth=24 --height=77 &amp;#34;$img&amp;#34; --fill --chars=&amp;#34; ░&amp;#34; --output=&amp;#34;txt/frame_$(printf &amp;#39;%04d&amp;#39; $counter).</description>
    </item>
    <item>
      <title>日志-2024-09-18</title>
      <link>https://jackgdn.github.io/post/bundle-%E6%97%A5%E5%BF%97/log-2024-09-18/</link>
      <pubDate>Wed, 18 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E6%97%A5%E5%BF%97/log-2024-09-18/</guid>
      <description>我又给 &amp;lt;a&amp;gt; 标签加了一个酷酷的 hover 效果，有下面两种 &amp;lt;a&amp;gt; 标签使用了 hover 效果：&#xA;没有 class 和 title 属性 class 属性中有 nav_item 但没有 nav_brand 我把自定义的效果写成 SASS 格式并写到主题给的 _custom.sass 文件里。&#xA;1a 2 &amp;amp;:not([class]):not([title]) 3 position: relative 4 &amp;amp;:after 5 content: &amp;#39;&amp;#39; 6 position: absolute 7 left: 0 8 bottom: -5px 9 display: inline-block 10 height: 1px 11 background-color: #0077b8 12 width: 0 13 opacity: 0 14 transition: opacity 0.35s, width 0.35s 15 &amp;amp;:hover:after 16 opacity: 1 17 width: 100% 18 &amp;amp;.</description>
    </item>
    <item>
      <title>Log-2024-09-16</title>
      <link>https://jackgdn.github.io/post/bundle-%E6%97%A5%E5%BF%97/log-2024-09-16/</link>
      <pubDate>Mon, 16 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E6%97%A5%E5%BF%97/log-2024-09-16/</guid>
      <description>Testing new shortcode audio. Bury the Light - Victor Borba&#xD;Devil Trigger - Ali Edwards&#xD;shortcode is as below:&#xD;1{{/* audio.html */}} 2 3&amp;lt;link rel=&amp;#34;stylesheet&amp;#34; href=&amp;#34;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css&amp;#34;&amp;gt; 4 5{{ $link := .Get &amp;#34;link&amp;#34; }} 6{{ $img := .Get &amp;#34;img&amp;#34; }} 7{{ $txt := .Get &amp;#34;txt&amp;#34; }} 8{{ $src := .Get &amp;#34;src&amp;#34; }} 9{{ $uniqueID := .Get &amp;#34;id&amp;#34; }} 10 11&amp;lt;div class=&amp;#34;player&amp;#34; id=&amp;#34;{{ $uniqueID }}&amp;#34;&amp;gt; 12 &amp;lt;div class=&amp;#34;imgBx&amp;#34;&amp;gt; 13 &amp;lt;img src=&amp;#34;{{ $img }}&amp;#34;&amp;gt; 14 &amp;lt;/div&amp;gt; 15 &amp;lt;div class=&amp;#34;text-content&amp;#34;&amp;gt; 16 &amp;lt;a href=&amp;#34;{{ $link }}&amp;#34; class=&amp;#34;button mt-1&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;noopener noreferrer&amp;#34;&amp;gt;{{ $txt }}&amp;lt;/a&amp;gt; &amp;lt;!</description>
    </item>
    <item>
      <title>Python 中函数的参数</title>
      <link>https://jackgdn.github.io/post/bundle-python-%E5%AD%A6%E4%B9%A0/args-and-kwargs-in-python/</link>
      <pubDate>Thu, 12 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-python-%E5%AD%A6%E4%B9%A0/args-and-kwargs-in-python/</guid>
      <description>必选参数 初学者必会的参数类型，也是 Python 函数参数传递最基础的方式。函数在定义中要求传入，调用时必须传入的参数就是必选参数。&#xA;1def foo(aParam, bParam): 2 print(aParam, bParam) 3 4foo(114514, 1919810) 5 6# output: 114514 1919810 函数定义中要求传入两个参数，那么在调用时就必须传入两个参数，如果出入过多或者过少参数均会报错。&#xA;1def foo(aParam, bParam): 2 print(aParam, bParam) 3 4foo(114514) 5 6&amp;#34;&amp;#34;&amp;#34; 7output: 8Traceback (most recent call last): 9 File &amp;#34;/home/jackgdn/python-script/test.py&amp;#34;, line 4, in &amp;lt;module&amp;gt; 10 foo(114514) 11TypeError: foo() missing 1 required positional argument: &amp;#39;bParam&amp;#39; 12&amp;#34;&amp;#34;&amp;#34; 传入过少参数&#xA;1def foo(aParam, bParam): 2 print(aParam, bParam) 3 4foo(114514, 1919810, &amp;#34;Hello, World!&amp;#34;) 5 6&amp;#34;&amp;#34;&amp;#34; 7Traceback (most recent call last): 8 File &amp;#34;/home/jackgdn/python-script/test.</description>
    </item>
    <item>
      <title>正则表达式学习记录（一）——正则表达式的编写</title>
      <link>https://jackgdn.github.io/post/regex-pt-1/</link>
      <pubDate>Sat, 10 Aug 2024 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/regex-pt-1/</guid>
      <description>正则表达式的编写 交互式学习正则表达式：RegexOne 中文&#xA;正则表达式练习：RegExr&#xA;正则表达式文档：MDN Web Docs 正则表达式&#xA;基础篇 标记&#xA;说明 样例 直接匹配，输入什么匹配什么。 RegEx: abc&#xA;Match: abc&#xA;Match: xyzabcdef . 匹配任何单个字符。 RegEx: .a&#xA;Match: 123abc \ 转义字符，用于匹配某个用于标记的原始字符。 RegEx: \.&#xA;Match: Hi.&#xA;Match: 3.14 [] 匹配特定范围内的单个字符 RegEx: [abc]an&#xA;Match: banana&#xA;Match: abcan [-] 用简略的方式表示范围。例如 [2-6] 等价于 [23456] RegEx: [0-3][a-c]&#xA;Match: 1a​2b8y9z [^] 排除特定范围内的单个字符 RegEx: b[^e]r&#xA;Match: barber \d 匹配 0-9 中的单个数字字符，相当于 [0-9] RegEx: \da&#xA;Match: 01a2b34 \D 匹配单个非数字字符，相当于 [^0-9] RegEx: \D2</description>
    </item>
    <item>
      <title>Links</title>
      <link>https://jackgdn.github.io/links/</link>
      <pubDate>Thu, 08 Aug 2024 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/links/</guid>
      <description>Docs &amp;amp; Tutorials Esolang&#xA;Markdown Tutorial&#xA;Python Documentation&#xA;Runoob Chinese Language Only&#xA;代码随想录 Chinese Language Only&#xA;Tools CodePen&#xA;Compiler Explorer&#xA;Convertio - File Converter&#xA;CyberChef&#xA;DeepL Translate&#xA;DNS Leak Test&#xA;Draw.io&#xA;Easy 6502&#xA;Factordb&#xA;Git History&#xA;HoLaTeX&#xA;IT Tools&#xA;Magic Data 5&#xA;Mermaid Live Editor&#xA;Photopea&#xA;PYC Decompile&#xA;Pyinstxtractor WEB&#xA;Unicode Steganography with 0-Width Characters&#xA;Vigenere Solver</description>
    </item>
    <item>
      <title>Log-2024-08-06</title>
      <link>https://jackgdn.github.io/post/bundle-%E6%97%A5%E5%BF%97/log-2024-08-06/</link>
      <pubDate>Tue, 06 Aug 2024 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E6%97%A5%E5%BF%97/log-2024-08-06/</guid>
      <description>After several days of work, I have completed the basic migration of my personal blog from Hexo to Hugo. I was using Hexo-Theme-Async theme previously. Both Hexo and Hugo have their own advantages and disadvantages. The advantage of Hexo is its simplicity. Without complex operations can anyone construct a pleasing blog with Hexo. Meanwhile, Hugo excels in speed of generation and high customization capabilities.&#xA;In terms of generation speed, running hugo server command is significantly faster than running hexo g and hexo s combined.</description>
    </item>
    <item>
      <title>About</title>
      <link>https://jackgdn.github.io/about/</link>
      <pubDate>Mon, 05 Aug 2024 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/about/</guid>
      <description>Undergraduate student at NEFU, majoring in CST.</description>
    </item>
    <item>
      <title>Python 课程设计项目报告</title>
      <link>https://jackgdn.github.io/post/python-%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Tue, 25 Jun 2024 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/python-%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/</guid>
      <description>项目情况 项目介绍 本项目为一个商品管理应用程序，主要功能是创建、编辑、存储商品信息，同时程序还支持图表视图浏览、密码保护、日志记录等功能。程序使用 Textual 模块创建 TUI（Text-based User Interface，基于文本的用户界面） 程序，用户使用 TUI 与程序交互。我们选择使用 TUI 的理由如下：&#xA;相比于 GUI 程序，TUI 程序可以在没有图形化界面的计算机系统内运行，有较强可移植性；相比于 CLI 程序，TUI 程序更易于用户操作。 用户只需键盘作为输入设备即可与程序交互，若用户使用鼠标则可以获得更佳交互体验。 使用 TUI 作为程序界面的人少之又少，而用于创建 TUI 程序的模块 Textual 的资料更是稀缺。因此，制作 TUI 程序可以体现作者完成这一项目的过程即是学习的过程。 作者个人情怀 程序功能的详细介绍如下：&#xA;权限异常提示。当用户以无读写文件权限的普通用户身份执行程序时，程序会通过 AlertModalScreen 类创建弹窗提醒用户权限不足。此外，为了确保数据安全，程序使用的数据文件、密码存储文件、日志文件的权限均设为 600。 登录模块。登录界面的会根据用户登录状态的不同而显示不同内容（登录界面的可复用性极强，下面三种不同状态下的登录界面都是基于 LoginModalScreen 类创建的）：用户首次登录时，由于没有可用账户，程序会提示用户创建新的账户；有可用账户时，程序会在运行时提示用户登录，登录成功后数据才会加载；用户登录成功后，可以修改密码，修改密码后下次登录使用旧密码则会登录失败。用户名和密码输入框都限制了无法输入空格。用户的用户名及密码使用 PBKDF2 与 SHA256 算法（通过 hashlib.pbkdf2_hmac() 函数实现）进行保护，并加入随机密码盐确保密码不会遭到彩虹表攻击。无论用户在何时注册或者修改密码，也无论用户使用何用户名密码，存储到 logininfo 密码文件中的数据几乎没有重复的可能性。 数据处理模块。这一部分是程序的核心部分。用户在登录后会自动加载已保存的数据并且以组件的形式显示在屏幕上。数据包含商品名称、商品单价、商品数量、商品分区以及商品编号，用户可以编辑每一个商品的相关信息或者删除这些信息。其中，商品名称一栏尽可填写大小写字母、数字以及空格；商品单价一栏仅可输入浮点类型或者整型数据，商品数量一栏仅可输入整型数据；商品分区为一个下拉菜单，其中有十种类别可以选择。编辑后的数据需要用户手动保存，数据存储为 TSV 格式。 日志模块。创建用户、登录、登录失败以及保存文件这四种操作及操作时间会被记录并存储到日志文件中。 以表格视图浏览数据。表格视图可以浏览用户实时编辑的数据而非从已保存的文件中读取数据。在表格视图中，用户可以以商品名称、商品单价、商品数量、商品分区以及商品编号为排序依据对数据进行排序。 切换亮/暗显示模式。 命令托盘。保存数据、修改密码、切换亮/暗显示模式、退出程序、联系作者等命令可以在命令托盘（Command Palette）中查找并执行。 显示时间。 程序运行截图 程序代码 1from textual.screen import ModalScreen, Screen 2from textual.widgets import Label, Button, Input, Select, Header, Footer, DataTable, RichLog 3from textual.</description>
    </item>
    <item>
      <title>远程控制一台在内网中的设备</title>
      <link>https://jackgdn.github.io/post/nat/</link>
      <pubDate>Sat, 15 Jun 2024 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/nat/</guid>
      <description>前段时间 wanqian 师傅添置了一台树莓派作为服务器连接到实验室的内网网络环境中。这台树莓派上安装了 Ubuntu 操作系统并装有一个摄像头模块，可以使用 fswebcam 命令控制摄像头拍照。不过遗憾的是，树莓派上没有图形化界面，如果想要查看图片就必须将图片传输到其他设备上；树莓派上的相机模块是反的，要是想正常查看需要将图片旋转 180°；树莓派在一个内网环境中，如果我想在宿舍里连接树莓派则需要每天交 1 元钱网费。&#xA;拍照、旋转、上传 wanqian 师傅出于安全性的考虑，不希望我使用内网穿透控制树莓派拍照。所以，我只能让树莓派与我的云服务器单线联系。因此我想到让树莓派检测云服务器上的某个端口是否开放，若开放则自动执行拍照上传等一系列命令，所以有了下面一个脚本（路径为 /home/gdn/gwc/agwc.sh。下文为便于叙述，树莓派用 R 表示，云服务器用 S 表示，个人计算机用 PC 表示）:&#xA;1#!/bin/bash 2CONN=&amp;#39;nc -zv IP_S 8963&amp;#39; 3while true 4do 5 if $CONN ; then 6 time=$(date +&amp;#34;%Y-%m-%d_%H-%M-%S&amp;#34;) 7 fswebcam --no-banner -r 1920x1080 /home/gdn/gwc/fagwc/$time.jpg 8 convert /home/gdn/gwc/fagwc/$time.jpg -rotate 180 /home/gdn/gwc/fagwc/$time.jpg 9 nc -v IP_S 8965 &amp;lt; /home/gdn/gwc/fagwc/$time.jpg 10 fi 11 sleep 10 12done 该脚本在 R 上运行，每隔十秒钟就会检测一次 S 的 8963 端口是否开放，如果开放，则使用 fswebcam 命令拍照，使用 convert 命令（在 ImageMagisk 工具集中）旋转图片并将图片使用 netcat 传输到 S 的 8965 端口上去。由于 netcat 连接特性，开放两个端口是必需的。另外，#!</description>
    </item>
    <item>
      <title>记一次 ARP 欺骗 &#43; DNS 劫持攻击的尝试</title>
      <link>https://jackgdn.github.io/post/mitm-attack/</link>
      <pubDate>Sun, 21 Apr 2024 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/mitm-attack/</guid>
      <description>前置知识 用较为生动的语言来讲，我们把网络类比成一间屋子，屋子里坐着的每一个人都是一台主机，每个人都有自己的编号（IP 地址）和位置（MAC 地址）。假如说屋子里的 A 需要和 B 通信，A 已知 B 的编号为 13 但是不知道 B 的位置，因此 A 无法和 B 通信。此时 A 会在屋子里大喊“谁的编号是 13”并等待 B 的回复。正常来说，除了 B 以外其他人会对 A 的请求视而不见，只有 B 收到 A 的请求后将自己的位置告诉 A，随后两人就可以开始通信。&#xA;但是，这是出现了一个不怀好意的 C，当 A 发送请求的时候，C 就拼命地给 A 回复“我就是 13 号”以至于 A 根本听不到 B 给他的回复，因此 A 就会把 C 当作 B 并与之通信，C 便可以借机充当中间人实施攻击。&#xA;动手尝试 攻击前准备 本次攻击尝试中，攻击机与靶机均为使用 NAT 模式连接物理机的虚拟机。这样既可以使两台虚拟机连接到外部网络，又不会在攻击过程中造成流量泄露。&#xA;攻击机配置&#xA;操作系统：Kali Linux IPv4 地址：192.168.107.135 MAC 地址：00:0c:29:62:a9:97 靶机配置&#xA;操作系统：Windows 10 IPv4 地址：192.168.107.139 MAC 地址：00:0C:29:B6:7E:52 网关配置</description>
    </item>
    <item>
      <title>逆向相关算法脚本（暂时停更）</title>
      <link>https://jackgdn.github.io/post/%E8%84%9A%E6%9C%AC%E5%BA%93/</link>
      <pubDate>Sat, 30 Mar 2024 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/%E8%84%9A%E6%9C%AC%E5%BA%93/</guid>
      <description>Base16 [已完成] Base32 [已完成] Base64 UUencode XXencode [已完成] Base58 (Python 实现) [已完成] TEA XTEA [已完成] XXTEA [已完成] RC4 [已完成] RC5 [队列中] SM4 [队列中] AES [队列中] DES 3DES [队列中] Blowfish [队列中] Chacha20 [队列中] Rabbit [队列中] RSA [队列中] MD5 [队列中] SHA256 [队列中] CRC32 [队列中] 有一个 IDA 插件叫做 Findcrypt, 其工作原理是寻找“关键值”，例如 TEA 加密的 DELTA、AES 加密的 S 盒、MD5 算法的状态变量。出于安全性的原因，这些值在算法里都是被规定好不能更改的。但是万恶的出题人可不管这些，如果这些值被修改，Findcrypt 就不好用了。因此我打算做这个脚本库。&#xA;除特别说明，本文中的脚本均使用 C++ 编写，使用 VC++ 编译器，以便于在遇到“魔改”算法题目时可直接修改。&#xA;编码 Base16 实际上 Base16 编码就是将每个字符的十六进制打印出来。但是既然是一种编码，就要考虑在题目中变表的可能。&#xA;编码脚本：&#xA;1#include &amp;lt;iostream&amp;gt; 2#include &amp;lt;cstring&amp;gt; 3#include &amp;lt;sstream&amp;gt; 4 5using namespace std; 6 7string dec2hex(int deci) 8{ 9&#x9;stringstream ss; 10&#x9;ss &amp;lt;&amp;lt; hex &amp;lt;&amp;lt; deci; 11&#x9;return ss.</description>
    </item>
    <item>
      <title>Proof of Vandermonde Matrix</title>
      <link>https://jackgdn.github.io/post/%E8%8C%83%E5%BE%B7%E8%92%99%E5%BE%B7%E8%A1%8C%E5%88%97%E5%BC%8F%E8%AF%81%E6%98%8E/</link>
      <pubDate>Thu, 14 Mar 2024 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/%E8%8C%83%E5%BE%B7%E8%92%99%E5%BE%B7%E8%A1%8C%E5%88%97%E5%BC%8F%E8%AF%81%E6%98%8E/</guid>
      <description>Vandermonde matrix：&#xA;$$ \begin{vmatrix}1 &amp;amp; 1 &amp;amp; \cdots &amp;amp; 1 \\ x_1 &amp;amp; x_2 &amp;amp; \cdots &amp;amp; x_n \\ x_1^2 &amp;amp; x_2^2 &amp;amp; \cdots &amp;amp; x_n^2 \\ \vdots &amp;amp; \vdots &amp;amp; \ddots &amp;amp; \vdots \\ x_1^{n-1} &amp;amp; x_2^{n-1} &amp;amp; \cdots &amp;amp; x_n^{n-1} \end{vmatrix} = \prod_{n \ge i &amp;gt; j \ge 1}(x_i-x_j) $$&#xA;The proof is as follows：&#xA;Starting at line $n$, subtract $x_1$ times the previous line from the subsequent line in the determinant to obtain the following equation:</description>
    </item>
    <item>
      <title>近期解题 2024.3.14</title>
      <link>https://jackgdn.github.io/post/bundle-wp/%E8%BF%91%E6%9C%9F%E8%A7%A3%E9%A2%98_20240314/</link>
      <pubDate>Thu, 14 Mar 2024 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-wp/%E8%BF%91%E6%9C%9F%E8%A7%A3%E9%A2%98_20240314/</guid>
      <description>[SWPU2019] ReverseMe 乍一看 main() 函数里没有什么东西。切到反汇编界面，我们看到了一位老朋友——SEH。&#xA;通过使用“广撒网”的打断点方式（在每一个可疑的 call 指令打断点），找到输入函数的位置：&#xA;紧接着下面就对输入内容的长度进行判定，输入内容的长度为 0x20。&#xA;继续调试，可以看到输入的内容在下面位置进行了异或操作：&#xA;最后在下面与密文进行比较：&#xA;根据此操作的特点，流程图模式中指向自己的代码块更可能是执行加密算法的部分。&#xA;提取数据后使用脚本解密：&#xA;1k1 = &amp;#39;SWPU_2019_CTF&amp;#39; 2k2 = [ 3 0x86, 0x0C, 0x3E, 0xCA, 0x98, 0xD7, 0xAE, 0x19, 0xE2, 0x77, 4 0x6B, 0xA6, 0x6A, 0xA1, 0x77, 0xB0, 0x69, 0x91, 0x37, 0x05, 5 0x7A, 0xF9, 0x7B, 0x30, 0x43, 0x5A, 0x4B, 0x10, 0x86, 0x7D, 6 0xD4, 0x28 7] 8k3 = [ 9 0xB3, 0x37, 0x0F, 0xF8, 0xBC, 0xBC, 0xAE, 0x5D, 0xBA, 0x5A, 10 0x4D, 0x86, 0x44, 0x97, 0x62, 0xD3, 0x4F, 0xBA, 0x24, 0x16, 11 0x0B, 0x9F, 0x72, 0x1A, 0x65, 0x68, 0x6D, 0x26, 0xBA, 0x6B, 12 0xC8, 0x67 13] 14 15for i in range(0x20): 16 print(chr(ord(k1[i % 13]) ^ k2[i] ^ k3[i]), end = &amp;#39;&amp;#39;) 17 18# output: flag{Y0uaretheB3st!</description>
    </item>
    <item>
      <title>PearlCTF 2024 WP</title>
      <link>https://jackgdn.github.io/post/bundle-wp/pearl2024/</link>
      <pubDate>Sun, 10 Mar 2024 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-wp/pearl2024/</guid>
      <description>I am so vegetable 我太菜了 :-(&#xA;b4by_jail 一道简单的 Python 沙箱逃逸（指连我都会做），题目附件如下：&#xA;1#!/usr/local/bin/python 2import time 3flag=&amp;#34;pearl{f4k3_fl4g}&amp;#34; 4blacklist=list(&amp;#34;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ~`![]{},&amp;lt;&amp;gt;/123456789&amp;#34;) 5def banner(): 6 file=open(&amp;#34;txt.txt&amp;#34;,&amp;#34;r&amp;#34;).read() 7 print(file) 8def check_blocklist(string): 9 for i in string: 10 if i in blacklist: 11 return(0) 12 return(1) 13def main(): 14 banner() 15 cmd=input(&amp;#34;&amp;gt;&amp;gt;&amp;gt; &amp;#34;) 16 time.sleep(1) 17 if(check_blocklist(cmd)): 18 try: 19 print(eval(cmd)) 20 except: 21 print(&amp;#34;Sorry no valid output to show.&amp;#34;) 22 else: 23 print(&amp;#34;Your sentence has been increased by 2 years for attempted escape.</description>
    </item>
    <item>
      <title>Python 内存相关学习记录</title>
      <link>https://jackgdn.github.io/post/bundle-python-%E5%AD%A6%E4%B9%A0/python-%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Thu, 07 Mar 2024 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-python-%E5%AD%A6%E4%B9%A0/python-%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</guid>
      <description>本文中交替出现 Python 的编译模式和交互模式代码块，为便于区分，带有 &amp;gt;&amp;gt;&amp;gt; 的 Python 代码块为交互模式，其余 Python 代码块为编译模式。&#xA;可变对象与不可变对象 可变对象 不可变对象 列表、字典、集合 整型、浮点型、布尔型、字符串、元组 简单来说，可变对象就是指在修改数据时，直接修改原来的数据对象；不可变对象则是创建一个新的对象，并且将变量的引用转移到新创建的对象上。&#xA;1dictnry = {&amp;#39;a&amp;#39;: 0, &amp;#39;b&amp;#39;: 1} # 字典对象为可变对象 2print(id(dictnry)) 3dictnry[&amp;#39;a&amp;#39;] = 1 4print(id(dictnry)) 5 6&amp;#39;&amp;#39;&amp;#39; 7output: 81570839226304 91570839226304 10&amp;#39;&amp;#39;&amp;#39; 下面是一个不可变对象的例子：&#xA;1string = &amp;#39;Hello, world?&amp;#39; 2print(id(string)) 3new_string = string.replace(&amp;#39;?&amp;#39;, &amp;#39;!&amp;#39;) # 因为字符串是不可变对象，因此在修改时需要一个新的变量接受修改后的字符串 4print(id(new_string)) 5print(string) 6print(new_string) 7 8&amp;#39;&amp;#39;&amp;#39; 9output: 101668896675760 111668896210864 12Hello, world? 13Hello, world! 14&amp;#39;&amp;#39;&amp;#39; 深拷贝与浅拷贝 浅拷贝：拷贝对象的引用。当原对象的数据改变时，拷贝的对象也会发生改变。 深拷贝：创建一个新的对象并将原数据存入新的对象。原对象数据改变不影响拷贝对象 在 Python 中，使用 copy() 函数实现浅拷贝，使用 copy.deepcopy() 函数实现深拷贝。&#xA;1# 浅拷贝 2&amp;gt;&amp;gt;&amp;gt; a = {&amp;#39;a&amp;#39;: [1, 2]} 3&amp;gt;&amp;gt;&amp;gt; b = a.</description>
    </item>
    <item>
      <title>Unicode 学习记录</title>
      <link>https://jackgdn.github.io/post/unicode-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Wed, 06 Mar 2024 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/unicode-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</guid>
      <description>前段时间有一道不是很难的 Python 沙箱逃逸问题，用到了 Unicode 的 NFKC。这一次详细记录一下 Unicode 里有点意思的特性。&#xA;NFKC 利用 NFKC 算是 Python 沙箱逃逸类题目里较为常用的一种方式。在编写攻击载荷时不得不用到某个字符，但是这个字符又被列入了检测的黑名单中，则会利用 Unicode 的 NFKC 标准化，而 Python 恰好也支持 NFKC，这不就巧了嘛！&#xA;简单来说，NFKC 可以让程序更好地理解一些字符，它将那些形状类似但是编码不同的字符归为一组字符。例如说在 Unicode 中合字 ﬃ (U+FB03) 在视觉上等同于 ffi 三个字符拼凑而成，因此需要计算机软件能够识别 ffi 三个字符等同于 ﬃ 合字字符，以便于用户检索。&#xA;因此在 Python 中就会有如下输出：&#xA;1print(&amp;#34;１&amp;#34; == &amp;#34;1&amp;#34;) # U+FF11 2print(int(&amp;#34;１&amp;#34;) == int(&amp;#34;1&amp;#34;)) 3 4# output: 5# 6# False 7# True 在下面两个网站里可以找到取代某个 ASCII 字符的 Unicode 字符：&#xA;Github - h13t0ry/UnicodeToy: Unicode fuzzer for various purposes&#xA;List of Unicode Characters of Bidirectional Class “European Number”</description>
    </item>
    <item>
      <title>2.19 解题记录</title>
      <link>https://jackgdn.github.io/post/bundle-wp/2.19/</link>
      <pubDate>Mon, 19 Feb 2024 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-wp/2.19/</guid>
      <description>CSGO 一个 Go 编写的程序，不过似乎没法调试（一调试就会卡住），尝试不使用调试器运行，然后 attach 到进程上去，这样才能动调。&#xA;先静态分析。&#xA;在 main_main() 函数 75 行处，fmt_Fscanf() 读取我们输入的内容；79-103 行对输入内容进行操作。104-125 行判断输入内容是否正确并给出答复。&#xA;如上图，值得注意的是，在第 88 行处出现 ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/，疑似是 Base64 编码。&#xA;现在在进入判断前的语句处打断点调试，发现如下字符串：&#xA;kx8skC4EXSgqkuQ5kQI4XAIEmCgqnuX/mR8EiB45mCoqjfU6oicqk/HsTi/=&#xA;看来这里使用的是 Base64 无疑了。不过这一串怎么看怎么不像正常编码编码出来的 flag。&#xA;尝试后也确实是这样。众所周知，正常 Base64 编码的 &#39;fla&#39; 三个字符是 &#39;Zmxh&#39;，这四个字符在编码表中的相对位置分别是 13、11、-16，而此编码前四个字符的相对位置也分别是 13、11、-16，因此我们大胆猜测换过的编码表只是将原先的编码表循环位移，根据偏移量知道换过的编码表为 &#39;LMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/ABCDEFGHIJK=&#39;&#xA;flag{y0u_f1nd_m3_you_r34lly_know_aBout_gO!!}&#xA;ezvm 程序相当简洁。程序读取输入的 34 个字节并存储到 program 中。fetch() 函数读取 program 中的操作码，eval() 函数则会根据操作码执行程序。虚拟机的核心，也就是虚拟机执行部分的伪代码如下：&#xA;1switch ( a1 ) 2{ 3 case 0: 4 ++dword_404024; 5 ++dword_408030; 6 result = dword_404024; 7 stack[dword_404024] = program[dword_408030]; 8 break; 9 case 1: 10 stack[++dword_404024] = program[++dword_408030]; 11 v3 = dword_404024--; 12 v12 = stack[v3]; 13 v4 = dword_404024--; 14 v11 = stack[v4]; 15 result = ++dword_404024; 16 stack[dword_404024] = v11 + v12; 17 break; 18 case 2: 19 v2 = dword_404024--; 20 result = stack[v2]; 21 break; 22 case 3: 23 running = 0; 24 result = puts(&amp;#34;done&amp;#34;); 25 break; 26 case 4: 27 stack[++dword_404024] = program[++dword_408030]; 28 v5 = dword_404024--; 29 v10 = stack[v5]; 30 v6 = dword_404024--; 31 v9 = stack[v6]; 32 result = ++dword_404024; 33 stack[dword_404024] = v10 ^ v9; 34 break; 35 case 5: 36 stack[++dword_404024] = program[++dword_408030]; 37 v7 = dword_404024--; 38 v8 = stack[v7]; 39 result = v8; 40 if ( v8 !</description>
    </item>
    <item>
      <title>NSSCTF Round#18 WP</title>
      <link>https://jackgdn.github.io/post/bundle-wp/nss18/</link>
      <pubDate>Wed, 14 Feb 2024 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-wp/nss18/</guid>
      <description>users &amp;amp; users_revenge 两道题可以用同一个脚本解。两道题区别就是题目 1 给出 200 个用户名，题目 2 给出 500 个用户名，密码为用户名的 MD5，其中有一个用户里有 flag，考虑使用 pwntools 连接。&#xA;1from pwn import * 2import hashlib 3 4usrlst = [] 5pwdlst = [] 6flaglst = [] 7sususrlst = [] 8suspwdlst = [] 9excptlst = [] 10&amp;#39;&amp;#39;&amp;#39; 11file_name = 12given_host = 13given_port = 14&amp;#39;&amp;#39;&amp;#39; 15with open(file_name, &amp;#39;r&amp;#39;) as wordlist: 16 for line in wordlist: 17 username = line.rstrip() # 去除换行符 18 usrlst.append(username) 19 pwdlst.append(hashlib.md5(username.encode()).hexdigest()) 20 21for i in range(len(usrlst)): 22 try: 23 print(i) 24 shell = ssh(host = given_host, port = given_port, user = usrlst[i], password = pwdlst[i]) # 题目使用 SSH 连接 25 sh = shell.</description>
    </item>
    <item>
      <title>修改 Overcooked! 2 存档</title>
      <link>https://jackgdn.github.io/post/%E4%B8%80%E5%B0%8F%E4%BC%99%E8%A7%89%E5%BE%97-overcooked-2-%E5%A4%AA%E9%9A%BE%E4%BA%8E%E6%98%AF%E4%BB%96/</link>
      <pubDate>Tue, 13 Feb 2024 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/%E4%B8%80%E5%B0%8F%E4%BC%99%E8%A7%89%E5%BE%97-overcooked-2-%E5%A4%AA%E9%9A%BE%E4%BA%8E%E6%98%AF%E4%BB%96/</guid>
      <description>这两天玩 Overcooked! 2 ，有的关卡因为没有攒够星星玩不了。我花钱买了游戏却不让我往后玩，那我自己改存档吧！&#xA;Overcooked! 2 存档位于 C:\Users\{username}\AppData\LocalLow\Team17\Overcooked2\{key}\ 文件夹下。username 是自己的用户名；key 是 Steam 账号的 17 位 SteamID，我的账号的 key 是 76561198849752742。&#xA;不难看出 Overcooked! 2 的存档都是以 .save 作为后缀。诸多游戏厂商都会把自家游戏存档存为 .save 格式。不过这并不是一种通用格式，不同厂商间存储的方式还不一样，有些使用文本文档或者 .json 格式明文存储（例如 Insurgency），有些使用序列化方式存储（例如 Arma3）。Overcooked! 2 的存储方式比较高级：&#xA;它加密了……&#xA;Overcooked! 2 是使用 Unity 引擎开发的游戏，这件事你一打开游戏就能知道。那我不妨把这游戏逆掉。&#xA;dnSpy，启动！&#xA;这样一款游戏，里边出现的类可以说是相当之多了。不过我只需要找到加密和解密存档的代码，因此我选择搜索 &amp;quot;save&amp;quot; 关键词来查找代码。不知道什么原因，开发人员没有使用 Unity 的 Mono Security 来保护代码，这也方便了我逆向。最终我在 GlobalSave 类里找到了极其可疑的代码：&#xA;相关加密解密代码如下：&#xA;1private byte[] Obfuscate(byte[] deobfuscatedText, int size, int start = 0, string salt = &amp;#34;jjo+Ffqil5bdpo5VG82kLj8Ng1sK7L/rCqFTa39Zkom2/baqf5j9HMmsuCr0ipjYsPrsaNIOESWy7bDDGYWx1eA==&amp;#34;, string hashFunction = &amp;#34;SHA1&amp;#34;, int keySize = 256) 2{ 3&#x9;if (deobfuscatedText == null || deobfuscatedText.</description>
    </item>
    <item>
      <title>BeginCTF 解题记录</title>
      <link>https://jackgdn.github.io/post/bundle-wp/beginctf-%E8%A7%A3%E9%A2%98%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Thu, 08 Feb 2024 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-wp/beginctf-%E8%A7%A3%E9%A2%98%E8%AE%B0%E5%BD%95/</guid>
      <description>题量大，题目难度适中，我挑选关键题目写写 WP&#xA;Misc Tupper 先把文件内容提取并拼接起来：&#xA;1txts = [] 2for i in range(0, 673, 4): 3 path = f&amp;#34;{i}.txt&amp;#34; 4 with open(path, &amp;#39;r&amp;#39;) as file: 5 txts.append(file.read()) 6txts = &amp;#39;&amp;#39;.join(txts) 7print(txts) 得到一段 Base64： MTQyNzgxOTM0MzI3MjgwMjYwNDkyOTg1NzQ1NzU1NTc1MzQzMjEwNjIzNDkzNTI1NDM1NjI2NTY3NjY0Njk3MDQwOTI4NzQ2ODgzNTQ2NzkzNzEyMTI0NDQzODIyOTg4MjEzNDIwOTM0NTAzOTg5MDcwOTY5NzYwMDI0NTg4MDc1OTg1MzU3MzUxNzIxMjY2NTc1MDQxMzExNzE2ODQ5MDcxNzMwODY2NTk1MDUxNDM5MjAzMDAwODU4MDg4MDk2NDcyNTY3OTAzODQzNzg1NTM3ODAyODI4OTQyMzk3NTE4OTg2MjAwNDExNDMzODMzMTcwNjQ3MjcxMzY5MDM2MzQ3NzA5MzYzOTg1MTg1NDc5MDA1MTI1NDg0MTk0ODYzNjQ5MTUzOTkyNTM5NDEyNDU5MTEyMDUyNjI0OTM1OTExNTg0OTc3MDgyMTkxMjY0NTM1ODc0NTY2MzczMDI4ODg3MDEzMDMzODIyMTA3NDg2Mjk4MDAwODE4MjE2ODQyODMxODczNjg1NDM2MDE1NTk3Nzg0MzE3MzUwMDY3OTQ3NjE1NDI0MTMwMDY2MjEyMTkyMDczMjI4MDg0NDkyMzIwNTA1Nzg4NTI0MzEzNjE2Nzg3NDUzNTU3NzY5MjExMzIzNTI0MTk5MzE5MDc4MzgyMDUwMDExODQ=&#xA;解码得到一串数：&#xA;14278193432728026049298574575557534321062349352543562656766469704092874688354679371212444382298821342093450398907096976002458807598535735172126657504131171684907173086659505143920300085808809647256790384378553780282894239751898620041143383317064727136903634770936398518547900512548419486364915399253941245911205262493591158497708219126453587456637302888701303382210748629800081821684283187368543601559778431735006794761542413006621219207322808449232050578852431361678745355776921132352419931907838205001184&#xD;根据题目名称可以知道与塔伯自指公式有关。用 Tupper&#39;s self-referential fomula 解一下：&#xA;where is crazyman 系列 三道社工题，前两道用谷歌识图可以直接找到地点；第三道的图片：&#xA;矿泉水瓶子上有 Boudl Apart&#39; Hotel 字样，根据提示在谷歌地图里找到在 Boudl Al Munsiyah 旁的 Starbucks。flag 在谷歌地图里这一家 Starbucks 的评论区里，按时间顺序查看能找到。&#xA;devil&#39;s word 一查是温州话，听音频把“魔鬼的语言”转成数字 0-9，最后十六进制转字符得到 flag。&#xA;发音 数字 leng 0 lia 2 sa 3 sii 4 ng 5 leu 6 cai 7 bo 8 jau 9 使用某些文本编辑器的 Ctrl+H 一键替换的时候注意，不要把 leng 里的 ng 替换成 5。</description>
    </item>
    <item>
      <title>近期解题 2024.2.16</title>
      <link>https://jackgdn.github.io/post/bundle-wp/%E8%BF%91%E6%9C%9F%E8%A7%A3%E9%A2%98_20240126/</link>
      <pubDate>Fri, 26 Jan 2024 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-wp/%E8%BF%91%E6%9C%9F%E8%A7%A3%E9%A2%98_20240126/</guid>
      <description>春秋杯 - upx2023 程序放进 Exeinfo，其实听名字就知道有壳，但是这个壳改过。&#xA;010 Editor 里看一眼，这个壳改得挺没品的，upx 段标识改回大写后，顺利脱壳。&#xA;进入 IDA 分析：&#xA;1int __fastcall main(int argc, const char **argv, const char **envp) 2{ 3 std::ostream *v3; // rax 4 char *v4; // rax 5 int v6[44]; // [rsp+20h] [rbp-60h] BYREF 6 char v7[16]; // [rsp+D0h] [rbp+50h] BYREF 7 char v8[16]; // [rsp+E0h] [rbp+60h] BYREF 8 char v9[20]; // [rsp+F0h] [rbp+70h] BYREF 9 int v10; // [rsp+104h] [rbp+84h] 10 unsigned int Seed; // [rsp+108h] [rbp+88h] 11 int i; // [rsp+10Ch] [rbp+8Ch] 12 13 _main(); 14 Seed = time(0i64); 15 srand(Seed); 16 std::string::string(v7); 17 std::operator&amp;lt;&amp;lt;&amp;lt;std::char_traits&amp;lt;char&amp;gt;&amp;gt;(&amp;amp;std::cout, Str); 18 std::operator&amp;gt;&amp;gt;&amp;lt;char&amp;gt;(&amp;amp;std::cin, v7); 19 std::string::string(v9, v7); 20 change(v8, v9); 21 std::string::operator=(v7, v8); 22 std::string::~string(v8); 23 std::string::~string(v9); 24 if ( std::string::length(v7) !</description>
    </item>
    <item>
      <title>近期解题 2024.1.13</title>
      <link>https://jackgdn.github.io/post/bundle-wp/%E8%BF%91%E6%9C%9F%E8%A7%A3%E9%A2%98_20230113/</link>
      <pubDate>Sat, 13 Jan 2024 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-wp/%E8%BF%91%E6%9C%9F%E8%A7%A3%E9%A2%98_20230113/</guid>
      <description>2024.1.4-2024.1.13&#xA;NEFU::CTF 反静态分析-1 反编译出 main() 函数如下：&#xA;敏锐察觉到 v9 数组的四个元素，疑似为 TEA 加密算法的 key。进入 sub_411523() -&amp;gt; sub_415100()，果然是一个 TEA 加密。&#xA;在 main() 函数中调用的 sub_411523() 有两个参数，第二个参数 v9 是 key，第一个参数 &amp;amp;v7 为 v7 数组。在变量声明的部分 int v7; // [esp+1D8h] [ebp-40h] BYREF 和 int v8; // [esp+1DCh] [ebp-3Ch] 可以看出 v7 与 v8 的地址相邻，实际上可以看作是一个数组。&#xA;写一个 TEA 解密的脚本，需要知道 v4（即 sum）的值是多少。通过打断点动态调试找到 v4 的值 0xC6EF3720。&#xA;上脚本&#xA;1#include &amp;lt;iostream&amp;gt; 2#include &amp;lt;cstdio&amp;gt; 3 4using namespace std; 5 6int key[4] = { 18,52,86,120 }; 7unsigned int num1 = 0x60FCDEF7; 8unsigned int num2 = 0x236DBEC; 9int sum = 0xC6EF3720; 10 11void tea() 12{ 13&#x9;for (int i = 0; i &amp;lt; 32; i++) 14&#x9;{ 15&#x9;num2 -= (key[3] + (num1 &amp;gt;&amp;gt; 5)) ^ (sum + num1) ^ (key[2] + 16 * num1); 16&#x9;num1 -= (key[1] + (num2 &amp;gt;&amp;gt; 5)) ^ (sum + num2) ^ (*key + 16 * num2); 17&#x9;sum += 0x61C88647; 18&#x9;} 19&#x9;cout &amp;lt;&amp;lt; num1 &amp;lt;&amp;lt; &amp;#39; &amp;#39; &amp;lt;&amp;lt; num2; 20} 21 22int main() 23{ 24&#x9;tea(); 25} 得到结果为 3 和 4，这与伪代码 main() 函数中 v8 = 4; 一致。运行程序，输入 3，确实进入了下一步骤。</description>
    </item>
    <item>
      <title>近期解题 2023.12.26</title>
      <link>https://jackgdn.github.io/post/bundle-wp/%E8%BF%91%E6%9C%9F%E8%A7%A3%E9%A2%98_20231226/</link>
      <pubDate>Tue, 26 Dec 2023 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-wp/%E8%BF%91%E6%9C%9F%E8%A7%A3%E9%A2%98_20231226/</guid>
      <description>擂台赛 - 123456789 题目源代码如下&#xA;1from secret import flag 2data = input(&amp;#39;&amp;gt; &amp;#39;) 3assert len(data) &amp;lt;= 9 and all(i not in &amp;#39;123456789&amp;#39; for i in data) and int(data) == 123456789 4print(flag) 看上去不是很麻烦。题目会在远程服务器上运行，secret 模块及其中的 flag 常量都存储在远程服务器上。 如果我们输入的 data 能够满足这个 assert 中的条件，flag 就会自己跳出来。&#xA;条件如下：&#xA;data 的长度小于等于 9&#xA;data 中不含 “123456789” 中的任意一个字符&#xA;data 转化为整型后与 123456789 相等&#xA;似乎条件 2、3 矛盾了，两个条件不可以同时实现。但是真的如此吗？&#xA;Unicode 编码归一化 文字处理软件在实现统一码字符串的搜索和排序时，须考虑到等价性的存在。如果没有此特性的话，用户在搜索时将无法找到在视觉上无法区分的字形。&#xA;通俗来讲，例如说在 Unicode 中合字 ﬃ (U+FB03) 在视觉上等同于 ffi 三个字符拼凑而成，因此需要计算机软件能够识别 ffi 三个字符等同于 ﬃ 合字字符，以便于用户检索。</description>
    </item>
    <item>
      <title>Search</title>
      <link>https://jackgdn.github.io/search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/search/</guid>
      <description></description>
    </item>
  </channel>
</rss>
