<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>2025 寒假算法练习 on &lt;jack-gdn/&gt;</title>
    <link>https://jackgdn.github.io/series/2025-%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/</link>
    <description>Recent content in 2025 寒假算法练习 on &lt;jack-gdn/&gt;</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Mon, 24 Feb 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://jackgdn.github.io/series/2025-%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>2025寒假算法练习——Week 8</title>
      <link>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025winter-week8/</link>
      <pubDate>Mon, 24 Feb 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025winter-week8/</guid>
      <description>前段时间做的搜索练习题&#xA;习题均来自 NEFU OJ Problem 784 | 白与黑-搜索 Description 有一间长方形的房子，地上铺了白色、黑色两种颜色的正方形瓷砖。你站在其中一块黑色的瓷砖上，只能向相邻的黑色瓷砖移动。请写一个程序，计算你总共能够到达多少块黑色的瓷砖。&#xA;Input 包括多个数据集合。每个数据集合的第一行是两个整数W 和H，分别表示x 方向 和y 方向瓷砖的数量。W 和H 都不超过20。在接下来的H 行中，每行包括W 个字符。 每个字符表示一块瓷砖的颜色，规则如下： 1）‘.’：黑色的瓷砖； 2）‘#’：白色的瓷砖； 3）‘@’：黑色的瓷砖，并且你站在这块瓷砖上。该字符在每个数据集合中唯一出现一次。 当在一行中读入的是两个零时，表示输入结束。&#xA;Output 对每个数据集合，分别输出一行，显示你从初始位置出发能到达的瓷砖数(记数时包括初始位置的瓷砖)。&#xA;Sample Input 16 9 2....#. 3.....# 4...... 5...... 6...... 7...... 8...... 9#@...# 10.#..#. 110 0 Sample Output 145 广搜找连通块。&#xA;1import java.util.Scanner; 2import java.util.Queue; 3import java.util.LinkedList; 4 5public class Main { 6 public static void main(String[] args) { 7 int[] directions = { 1, 0, -1, 0, 0, 1, 0, -1 }; 8 try (Scanner sc = new Scanner(System.</description>
    </item>
    <item>
      <title>2025寒假算法练习——Week 7</title>
      <link>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025winter-week7/</link>
      <pubDate>Sat, 22 Feb 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025winter-week7/</guid>
      <description>习题均来自 NEFU OJ Problem 1632 | 周末舞会-队列 Description 假设在周末舞会上，男士们和女士们进入舞厅时，各自排成一队。跳舞开始时，依次从男队和女队的队头上各出一人配成舞伴。规定每个舞曲只能有一对跳舞者。若两队初始人数不相同，则较长的那一队中未配对者等待下一轮舞曲。现要求写一个程序，模拟上述舞伴配对问题。&#xA;Input 第 1 行两个正整数，表示男士人数 m 和女士人数 n，1≤m，n≤1000； 第 2 行一个正整数，表示舞曲的数目 k，k≤1000。&#xA;Output 共 k 行，每行两个数，之间用一个空格隔开，表示配对舞伴的序号，男士在前，女士在后。&#xA;Sample Input 12 4 26 Sample Output 11 1 22 2 31 3 42 4 51 1 62 2 用队列反而时空消耗大，不如直接取模。&#xA;1import java.util.Scanner; 2 3public class Main { 4 public static void main(String[] args) { 5 try (Scanner sc = new Scanner(System.in)) { 6 int m = sc.</description>
    </item>
    <item>
      <title>2025寒假算法练习——Week 6</title>
      <link>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025winter-week6/</link>
      <pubDate>Fri, 21 Feb 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025winter-week6/</guid>
      <description>前段时间做 DP 有些头晕，今天做些水题。&#xA;习题均来自 NEFU OJ Problem 1624 | 栈-程序员输入问题 Description 程序员输入程序出现差错时，可以采取以下的补救措施：按错了一个键时，可以补按一个退格符“#”，以表示前一个字符无效；发现当前一行有错，可以按一个退行符“@”，以表示“@”与前一个换行符之间的字符全部无效。&#xA;Input 输入一行字符，个数不超过 100。&#xA;Output 输出一行字符，表示实际有效字符。&#xA;Sample Input 1sdfosif@for (ii#=1,#;i&amp;lt;.#=8;i+++#); Sample Output 1for (i=1;i&amp;lt;=8;i++); Hint 例子输入2：1234## 例子输出2：12&#xA;也许是不同语言对字符串的处理有差异，用 Java 会 WA。&#xA;1#include &amp;lt;iostream&amp;gt; 2#include &amp;lt;stack&amp;gt; 3#include &amp;lt;string&amp;gt; 4 5using namespace std; 6 7int main() { 8 string s; 9 getline(cin, s); 10 stack&amp;lt;char&amp;gt; st; 11 12 for (char ch : s) { 13 if (ch == &amp;#39;#&amp;#39;) { 14 st.</description>
    </item>
    <item>
      <title>2025寒假算法练习——Week 5</title>
      <link>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025winter-week5/</link>
      <pubDate>Sat, 15 Feb 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025winter-week5/</guid>
      <description>前几天出去旅游所以没咋做题。&#xA;习题均来自 NEFU OJ Problem 75 | 老鼠的旅行 Description 一只老鼠有M磅猫食，然后在N个房间里面用猫食换JavaBean，房间i中能用F[i]磅的猫食来换J[i]磅的JavaBean，而且老鼠可以在一个房间里根据一定比例a%来换取JavaBean. 现在他是这任务分配给你：告诉他，他的JavaBeans的获取能最多。&#xA;Input The input consists of multiple test cases. Each test case begins with a line containing two non-negative integers M and N. Then N lines follow, each contains two non-negative integers J[i] and F[i] respectively. The last test case is followed by two -1′s. All integers are not greater than 1000. M是开始时老鼠有的猫食！&#xA;Output For each test case, print in a single line a real number accurate up to 3 decimal places, which is the maximum amount of JavaBeans that FatMouse can obtain.</description>
    </item>
    <item>
      <title>2025寒假算法练习——Week 4</title>
      <link>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025winter-week4/</link>
      <pubDate>Thu, 06 Feb 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025winter-week4/</guid>
      <description>习题均来自 NEFU OJ Problem 1077 | 最大公约数和最小公倍数 Description 请计算2个数的最大公约数和最小公倍数；（最大公约数可以使用辗转相除法，最小公倍数=2个数的乘积/它们的最大公约数；）&#xA;Input 输入数据有多组，每组2个正整数a,b(2&amp;lt;a,b&amp;lt;1000)&#xA;Output 在一行内输出a和b的最大公约数和最小公倍数；&#xA;Sample Input 115 10 Sample Output 15 30 1import java.util.Scanner; 2 3public class Main { 4 public static void main(String[] args) { 5 Scanner scanner = new Scanner(System.in); 6 while (scanner.hasNextInt()) { 7 int a = scanner.nextInt(); 8 int b = scanner.nextInt(); 9 int d = gcd(a, b); 10 int m = a * b / d; 11 System.</description>
    </item>
    <item>
      <title>2025寒假算法练习——Week 3</title>
      <link>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025winter-week3/</link>
      <pubDate>Tue, 28 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025winter-week3/</guid>
      <description>习题均来自 NEFU OJ Problem 8 | 二倍的问题 Description 给定2到15个不同的正整数，你的任务是计算这些数里面有多少个数对满足：数对中一个数是另一个数的两倍。比如给定1 4 3 2 9 7 18 22，得到的答案是3，因为2是1的两倍，4是2个两倍，18是9的两倍。&#xA;Input 输入包括n组测试数据。每组数据包括一行，给出2到15个两两不同且小于100的正整数。每一行最后一个数是0，表示这一行的结束后，这个数不属于那2到15个给定的正整数。&#xA;Output 对每组输入数据，输出一行，给出有多少个数对满足其中一个数是另一个数的两倍。&#xA;Sample Input 13 21 4 3 2 9 7 18 22 0 32 4 8 10 0 47 5 11 13 1 3 0 Sample Output 13 22 30 简单题。唯一奇怪的是使用 bitset 比直接用 int* 的内存开销大。&#xA;1#define _CRT_SECURE_NO_WARNINGS 2 3#include &amp;lt;cstdio&amp;gt; 4#include &amp;lt;cstring&amp;gt; 5 6using namespace std; 7 8int max_value, i, value, n, cnt; 9int values[100]; 10 11int main() { 12 scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); 13 while (n--) { 14 memset(values, 0, sizeof(values)); 15 max_value = -1; 16 cnt = 0; 17 18 while (scanf(&amp;#34;%d&amp;#34;, &amp;amp;value) &amp;amp;&amp;amp; value !</description>
    </item>
    <item>
      <title>2025寒假算法练习——Week 2</title>
      <link>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025winter-week2/</link>
      <pubDate>Fri, 24 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025winter-week2/</guid>
      <description>习题均来自 NEFU OJ Problem 1481 | 谁考了第k名-排序 Description 在一次考试中，每个学生的成绩都不相同，现知道了每个学生的学号和成绩，求考第k名学生的学号和成绩。&#xA;Input 第一行有两个整数，分别是学生的人数n（1≤n≤100），和求第k名学生的k（1≤k≤n）。 其后有n行数据，每行包括一个学号（整数）和一个成绩（浮点数），中间用一个空格分隔。&#xA;Output 输出第k名学生的学号和成绩，中间用空格分隔。（注：请用%g输出成绩）&#xA;Sample Input 15 3 290788001 67.8 390788002 90.3 490788003 61 590788004 68.4 690788005 73.9 Sample Output 190788004 68.4 Source 奥赛一本通&#xA;这道题可以自己搓一个排序，也可以用结构体排序解决。&#xA;1#include &amp;lt;iostream&amp;gt; 2#include &amp;lt;algorithm&amp;gt; 3 4using namespace std; 5 6struct Student { 7 int id;z 8 float score; 9}; 10 11bool cmp(Student a, Student b) { 12 return a.score &amp;gt; b.score; 13} 14 15int main() { 16 Student students[100]; 17 int n, k; 18 cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k; 19 for (int i = 0; i &amp;lt; n; i++) { 20 cin &amp;gt;&amp;gt; students[i].</description>
    </item>
    <item>
      <title>2025寒假算法练习——Week 1</title>
      <link>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025winter-week1/</link>
      <pubDate>Sun, 19 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025winter-week1/</guid>
      <description>习题均来自 NEFU OJ Problem 357 | 天下无双 Description 太极生两仪,两仪生四象,四象生八卦,八卦生万物。天地初开，万物皆欲成双成对；芸芸丛生，谁愿孤苦伶仃。知音难觅，阳春白雪绕梁何久，千古一绝，神雕侠女驰骋九洲。 天下岂无双？千古绝唱为知音。情寄雨丝丝，述相思之意；梦随风万里，寻同道之人。共聚一堂，为梦想而努力；携手共进，为程序而疯狂！ 夜夜编程不漫长，只因与君共拼搏…… 给定n个数，其数值范围在1到n-1中，已知其中必有两个数是相同的，要求你找出并输出。（2&amp;lt;=n&amp;lt;=1，000,000）&#xA;Input 多组数据输入. 每组输入第一行一个数n。第二行n个数，其数值范围为1..n-1。&#xA;Output 每组输出一行一个数，即出现过两次的数。&#xA;Sample Input 15 22 3 1 4 2 38 47 6 1 2 3 5 4 7 Sample Output 12 27 第一眼看到这道题的时候，我想到了力扣两数之和，因而选择使用哈希表来解决这一问题：&#xA;1import java.util.Scanner; 2import java.util.Map; 3import java.util.HashMap; 4 5public class Main { 6 public static void main(String[] args) { 7 try (Scanner scanner = new Scanner(System.in)) { 8 while (scanner.hasNextInt()) { 9 Map&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); 10 int n = scanner.</description>
    </item>
  </channel>
</rss>
