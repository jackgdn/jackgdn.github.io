<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Reverse on &lt;jack-gdn/&gt;</title>
    <link>https://jackgdn.github.io/tags/reverse/</link>
    <description>Recent content in Reverse on &lt;jack-gdn/&gt;</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Sat, 30 Mar 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://jackgdn.github.io/tags/reverse/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>逆向相关算法脚本（暂时停更）</title>
      <link>https://jackgdn.github.io/post/%E8%84%9A%E6%9C%AC%E5%BA%93/</link>
      <pubDate>Sat, 30 Mar 2024 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/%E8%84%9A%E6%9C%AC%E5%BA%93/</guid>
      <description>Base16 [已完成] Base32 [已完成] Base64 UUencode XXencode [已完成] Base58 (Python 实现) [已完成] TEA XTEA [已完成] XXTEA [已完成] RC4 [已完成] RC5 [队列中] SM4 [队列中] AES [队列中] DES 3DES [队列中] Blowfish [队列中] Chacha20 [队列中] Rabbit [队列中] RSA [队列中] MD5 [队列中] SHA256 [队列中] CRC32 [队列中] 有一个 IDA 插件叫做 Findcrypt, 其工作原理是寻找“关键值”，例如 TEA 加密的 DELTA、AES 加密的 S 盒、MD5 算法的状态变量。出于安全性的原因，这些值在算法里都是被规定好不能更改的。但是万恶的出题人可不管这些，如果这些值被修改，Findcrypt 就不好用了。因此我打算做这个脚本库。&#xA;除特别说明，本文中的脚本均使用 C++ 编写，使用 VC++ 编译器，以便于在遇到“魔改”算法题目时可直接修改。&#xA;编码 Base16 实际上 Base16 编码就是将每个字符的十六进制打印出来。但是既然是一种编码，就要考虑在题目中变表的可能。&#xA;编码脚本：&#xA;1#include &amp;lt;iostream&amp;gt; 2#include &amp;lt;cstring&amp;gt; 3#include &amp;lt;sstream&amp;gt; 4 5using namespace std; 6 7string dec2hex(int deci) 8{ 9&#x9;stringstream ss; 10&#x9;ss &amp;lt;&amp;lt; hex &amp;lt;&amp;lt; deci; 11&#x9;return ss.</description>
    </item>
    <item>
      <title>近期解题 2024.3.14</title>
      <link>https://jackgdn.github.io/post/bundle-wp/%E8%BF%91%E6%9C%9F%E8%A7%A3%E9%A2%98_20240314/</link>
      <pubDate>Thu, 14 Mar 2024 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-wp/%E8%BF%91%E6%9C%9F%E8%A7%A3%E9%A2%98_20240314/</guid>
      <description>[SWPU2019] ReverseMe 乍一看 main() 函数里没有什么东西。切到反汇编界面，我们看到了一位老朋友——SEH。&#xA;通过使用“广撒网”的打断点方式（在每一个可疑的 call 指令打断点），找到输入函数的位置：&#xA;紧接着下面就对输入内容的长度进行判定，输入内容的长度为 0x20。&#xA;继续调试，可以看到输入的内容在下面位置进行了异或操作：&#xA;最后在下面与密文进行比较：&#xA;根据此操作的特点，流程图模式中指向自己的代码块更可能是执行加密算法的部分。&#xA;提取数据后使用脚本解密：&#xA;1k1 = &amp;#39;SWPU_2019_CTF&amp;#39; 2k2 = [ 3 0x86, 0x0C, 0x3E, 0xCA, 0x98, 0xD7, 0xAE, 0x19, 0xE2, 0x77, 4 0x6B, 0xA6, 0x6A, 0xA1, 0x77, 0xB0, 0x69, 0x91, 0x37, 0x05, 5 0x7A, 0xF9, 0x7B, 0x30, 0x43, 0x5A, 0x4B, 0x10, 0x86, 0x7D, 6 0xD4, 0x28 7] 8k3 = [ 9 0xB3, 0x37, 0x0F, 0xF8, 0xBC, 0xBC, 0xAE, 0x5D, 0xBA, 0x5A, 10 0x4D, 0x86, 0x44, 0x97, 0x62, 0xD3, 0x4F, 0xBA, 0x24, 0x16, 11 0x0B, 0x9F, 0x72, 0x1A, 0x65, 0x68, 0x6D, 0x26, 0xBA, 0x6B, 12 0xC8, 0x67 13] 14 15for i in range(0x20): 16 print(chr(ord(k1[i % 13]) ^ k2[i] ^ k3[i]), end = &amp;#39;&amp;#39;) 17 18# output: flag{Y0uaretheB3st!</description>
    </item>
    <item>
      <title>PearlCTF 2024 WP</title>
      <link>https://jackgdn.github.io/post/bundle-wp/pearl2024/</link>
      <pubDate>Sun, 10 Mar 2024 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-wp/pearl2024/</guid>
      <description>I am so vegetable 我太菜了 :-(&#xA;b4by_jail 一道简单的 Python 沙箱逃逸（指连我都会做），题目附件如下：&#xA;1#!/usr/local/bin/python 2import time 3flag=&amp;#34;pearl{f4k3_fl4g}&amp;#34; 4blacklist=list(&amp;#34;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ~`![]{},&amp;lt;&amp;gt;/123456789&amp;#34;) 5def banner(): 6 file=open(&amp;#34;txt.txt&amp;#34;,&amp;#34;r&amp;#34;).read() 7 print(file) 8def check_blocklist(string): 9 for i in string: 10 if i in blacklist: 11 return(0) 12 return(1) 13def main(): 14 banner() 15 cmd=input(&amp;#34;&amp;gt;&amp;gt;&amp;gt; &amp;#34;) 16 time.sleep(1) 17 if(check_blocklist(cmd)): 18 try: 19 print(eval(cmd)) 20 except: 21 print(&amp;#34;Sorry no valid output to show.&amp;#34;) 22 else: 23 print(&amp;#34;Your sentence has been increased by 2 years for attempted escape.</description>
    </item>
    <item>
      <title>2.19 解题记录</title>
      <link>https://jackgdn.github.io/post/bundle-wp/2.19/</link>
      <pubDate>Mon, 19 Feb 2024 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-wp/2.19/</guid>
      <description>CSGO 一个 Go 编写的程序，不过似乎没法调试（一调试就会卡住），尝试不使用调试器运行，然后 attach 到进程上去，这样才能动调。&#xA;先静态分析。&#xA;在 main_main() 函数 75 行处，fmt_Fscanf() 读取我们输入的内容；79-103 行对输入内容进行操作。104-125 行判断输入内容是否正确并给出答复。&#xA;如上图，值得注意的是，在第 88 行处出现 ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/，疑似是 Base64 编码。&#xA;现在在进入判断前的语句处打断点调试，发现如下字符串：&#xA;kx8skC4EXSgqkuQ5kQI4XAIEmCgqnuX/mR8EiB45mCoqjfU6oicqk/HsTi/=&#xA;看来这里使用的是 Base64 无疑了。不过这一串怎么看怎么不像正常编码编码出来的 flag。&#xA;尝试后也确实是这样。众所周知，正常 Base64 编码的 &#39;fla&#39; 三个字符是 &#39;Zmxh&#39;，这四个字符在编码表中的相对位置分别是 13、11、-16，而此编码前四个字符的相对位置也分别是 13、11、-16，因此我们大胆猜测换过的编码表只是将原先的编码表循环位移，根据偏移量知道换过的编码表为 &#39;LMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/ABCDEFGHIJK=&#39;&#xA;flag{y0u_f1nd_m3_you_r34lly_know_aBout_gO!!}&#xA;ezvm 程序相当简洁。程序读取输入的 34 个字节并存储到 program 中。fetch() 函数读取 program 中的操作码，eval() 函数则会根据操作码执行程序。虚拟机的核心，也就是虚拟机执行部分的伪代码如下：&#xA;1switch ( a1 ) 2{ 3 case 0: 4 ++dword_404024; 5 ++dword_408030; 6 result = dword_404024; 7 stack[dword_404024] = program[dword_408030]; 8 break; 9 case 1: 10 stack[++dword_404024] = program[++dword_408030]; 11 v3 = dword_404024--; 12 v12 = stack[v3]; 13 v4 = dword_404024--; 14 v11 = stack[v4]; 15 result = ++dword_404024; 16 stack[dword_404024] = v11 + v12; 17 break; 18 case 2: 19 v2 = dword_404024--; 20 result = stack[v2]; 21 break; 22 case 3: 23 running = 0; 24 result = puts(&amp;#34;done&amp;#34;); 25 break; 26 case 4: 27 stack[++dword_404024] = program[++dword_408030]; 28 v5 = dword_404024--; 29 v10 = stack[v5]; 30 v6 = dword_404024--; 31 v9 = stack[v6]; 32 result = ++dword_404024; 33 stack[dword_404024] = v10 ^ v9; 34 break; 35 case 5: 36 stack[++dword_404024] = program[++dword_408030]; 37 v7 = dword_404024--; 38 v8 = stack[v7]; 39 result = v8; 40 if ( v8 !</description>
    </item>
    <item>
      <title>NSSCTF Round#18 WP</title>
      <link>https://jackgdn.github.io/post/bundle-wp/nss18/</link>
      <pubDate>Wed, 14 Feb 2024 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-wp/nss18/</guid>
      <description>users &amp;amp; users_revenge 两道题可以用同一个脚本解。两道题区别就是题目 1 给出 200 个用户名，题目 2 给出 500 个用户名，密码为用户名的 MD5，其中有一个用户里有 flag，考虑使用 pwntools 连接。&#xA;1from pwn import * 2import hashlib 3 4usrlst = [] 5pwdlst = [] 6flaglst = [] 7sususrlst = [] 8suspwdlst = [] 9excptlst = [] 10&amp;#39;&amp;#39;&amp;#39; 11file_name = 12given_host = 13given_port = 14&amp;#39;&amp;#39;&amp;#39; 15with open(file_name, &amp;#39;r&amp;#39;) as wordlist: 16 for line in wordlist: 17 username = line.rstrip() # 去除换行符 18 usrlst.append(username) 19 pwdlst.append(hashlib.md5(username.encode()).hexdigest()) 20 21for i in range(len(usrlst)): 22 try: 23 print(i) 24 shell = ssh(host = given_host, port = given_port, user = usrlst[i], password = pwdlst[i]) # 题目使用 SSH 连接 25 sh = shell.</description>
    </item>
    <item>
      <title>修改 Overcooked! 2 存档</title>
      <link>https://jackgdn.github.io/post/%E4%B8%80%E5%B0%8F%E4%BC%99%E8%A7%89%E5%BE%97-overcooked-2-%E5%A4%AA%E9%9A%BE%E4%BA%8E%E6%98%AF%E4%BB%96/</link>
      <pubDate>Tue, 13 Feb 2024 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/%E4%B8%80%E5%B0%8F%E4%BC%99%E8%A7%89%E5%BE%97-overcooked-2-%E5%A4%AA%E9%9A%BE%E4%BA%8E%E6%98%AF%E4%BB%96/</guid>
      <description>这两天玩 Overcooked! 2 ，有的关卡因为没有攒够星星玩不了。我花钱买了游戏却不让我往后玩，那我自己改存档吧！&#xA;Overcooked! 2 存档位于 C:\Users\{username}\AppData\LocalLow\Team17\Overcooked2\{key}\ 文件夹下。username 是自己的用户名；key 是 Steam 账号的 17 位 SteamID，我的账号的 key 是 76561198849752742。&#xA;不难看出 Overcooked! 2 的存档都是以 .save 作为后缀。诸多游戏厂商都会把自家游戏存档存为 .save 格式。不过这并不是一种通用格式，不同厂商间存储的方式还不一样，有些使用文本文档或者 .json 格式明文存储（例如 Insurgency），有些使用序列化方式存储（例如 Arma3）。Overcooked! 2 的存储方式比较高级：&#xA;它加密了……&#xA;Overcooked! 2 是使用 Unity 引擎开发的游戏，这件事你一打开游戏就能知道。那我不妨把这游戏逆掉。&#xA;dnSpy，启动！&#xA;这样一款游戏，里边出现的类可以说是相当之多了。不过我只需要找到加密和解密存档的代码，因此我选择搜索 &amp;quot;save&amp;quot; 关键词来查找代码。不知道什么原因，开发人员没有使用 Unity 的 Mono Security 来保护代码，这也方便了我逆向。最终我在 GlobalSave 类里找到了极其可疑的代码：&#xA;相关加密解密代码如下：&#xA;1private byte[] Obfuscate(byte[] deobfuscatedText, int size, int start = 0, string salt = &amp;#34;jjo+Ffqil5bdpo5VG82kLj8Ng1sK7L/rCqFTa39Zkom2/baqf5j9HMmsuCr0ipjYsPrsaNIOESWy7bDDGYWx1eA==&amp;#34;, string hashFunction = &amp;#34;SHA1&amp;#34;, int keySize = 256) 2{ 3&#x9;if (deobfuscatedText == null || deobfuscatedText.</description>
    </item>
    <item>
      <title>BeginCTF 解题记录</title>
      <link>https://jackgdn.github.io/post/bundle-wp/beginctf-%E8%A7%A3%E9%A2%98%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Thu, 08 Feb 2024 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-wp/beginctf-%E8%A7%A3%E9%A2%98%E8%AE%B0%E5%BD%95/</guid>
      <description>题量大，题目难度适中，我挑选关键题目写写 WP&#xA;Misc Tupper 先把文件内容提取并拼接起来：&#xA;1txts = [] 2for i in range(0, 673, 4): 3 path = f&amp;#34;{i}.txt&amp;#34; 4 with open(path, &amp;#39;r&amp;#39;) as file: 5 txts.append(file.read()) 6txts = &amp;#39;&amp;#39;.join(txts) 7print(txts) 得到一段 Base64： MTQyNzgxOTM0MzI3MjgwMjYwNDkyOTg1NzQ1NzU1NTc1MzQzMjEwNjIzNDkzNTI1NDM1NjI2NTY3NjY0Njk3MDQwOTI4NzQ2ODgzNTQ2NzkzNzEyMTI0NDQzODIyOTg4MjEzNDIwOTM0NTAzOTg5MDcwOTY5NzYwMDI0NTg4MDc1OTg1MzU3MzUxNzIxMjY2NTc1MDQxMzExNzE2ODQ5MDcxNzMwODY2NTk1MDUxNDM5MjAzMDAwODU4MDg4MDk2NDcyNTY3OTAzODQzNzg1NTM3ODAyODI4OTQyMzk3NTE4OTg2MjAwNDExNDMzODMzMTcwNjQ3MjcxMzY5MDM2MzQ3NzA5MzYzOTg1MTg1NDc5MDA1MTI1NDg0MTk0ODYzNjQ5MTUzOTkyNTM5NDEyNDU5MTEyMDUyNjI0OTM1OTExNTg0OTc3MDgyMTkxMjY0NTM1ODc0NTY2MzczMDI4ODg3MDEzMDMzODIyMTA3NDg2Mjk4MDAwODE4MjE2ODQyODMxODczNjg1NDM2MDE1NTk3Nzg0MzE3MzUwMDY3OTQ3NjE1NDI0MTMwMDY2MjEyMTkyMDczMjI4MDg0NDkyMzIwNTA1Nzg4NTI0MzEzNjE2Nzg3NDUzNTU3NzY5MjExMzIzNTI0MTk5MzE5MDc4MzgyMDUwMDExODQ=&#xA;解码得到一串数：&#xA;14278193432728026049298574575557534321062349352543562656766469704092874688354679371212444382298821342093450398907096976002458807598535735172126657504131171684907173086659505143920300085808809647256790384378553780282894239751898620041143383317064727136903634770936398518547900512548419486364915399253941245911205262493591158497708219126453587456637302888701303382210748629800081821684283187368543601559778431735006794761542413006621219207322808449232050578852431361678745355776921132352419931907838205001184&#xD;根据题目名称可以知道与塔伯自指公式有关。用 Tupper&#39;s self-referential fomula 解一下：&#xA;where is crazyman 系列 三道社工题，前两道用谷歌识图可以直接找到地点；第三道的图片：&#xA;矿泉水瓶子上有 Boudl Apart&#39; Hotel 字样，根据提示在谷歌地图里找到在 Boudl Al Munsiyah 旁的 Starbucks。flag 在谷歌地图里这一家 Starbucks 的评论区里，按时间顺序查看能找到。&#xA;devil&#39;s word 一查是温州话，听音频把“魔鬼的语言”转成数字 0-9，最后十六进制转字符得到 flag。&#xA;发音 数字 leng 0 lia 2 sa 3 sii 4 ng 5 leu 6 cai 7 bo 8 jau 9 使用某些文本编辑器的 Ctrl+H 一键替换的时候注意，不要把 leng 里的 ng 替换成 5。</description>
    </item>
    <item>
      <title>近期解题 2024.2.16</title>
      <link>https://jackgdn.github.io/post/bundle-wp/%E8%BF%91%E6%9C%9F%E8%A7%A3%E9%A2%98_20240126/</link>
      <pubDate>Fri, 26 Jan 2024 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-wp/%E8%BF%91%E6%9C%9F%E8%A7%A3%E9%A2%98_20240126/</guid>
      <description>春秋杯 - upx2023 程序放进 Exeinfo，其实听名字就知道有壳，但是这个壳改过。&#xA;010 Editor 里看一眼，这个壳改得挺没品的，upx 段标识改回大写后，顺利脱壳。&#xA;进入 IDA 分析：&#xA;1int __fastcall main(int argc, const char **argv, const char **envp) 2{ 3 std::ostream *v3; // rax 4 char *v4; // rax 5 int v6[44]; // [rsp+20h] [rbp-60h] BYREF 6 char v7[16]; // [rsp+D0h] [rbp+50h] BYREF 7 char v8[16]; // [rsp+E0h] [rbp+60h] BYREF 8 char v9[20]; // [rsp+F0h] [rbp+70h] BYREF 9 int v10; // [rsp+104h] [rbp+84h] 10 unsigned int Seed; // [rsp+108h] [rbp+88h] 11 int i; // [rsp+10Ch] [rbp+8Ch] 12 13 _main(); 14 Seed = time(0i64); 15 srand(Seed); 16 std::string::string(v7); 17 std::operator&amp;lt;&amp;lt;&amp;lt;std::char_traits&amp;lt;char&amp;gt;&amp;gt;(&amp;amp;std::cout, Str); 18 std::operator&amp;gt;&amp;gt;&amp;lt;char&amp;gt;(&amp;amp;std::cin, v7); 19 std::string::string(v9, v7); 20 change(v8, v9); 21 std::string::operator=(v7, v8); 22 std::string::~string(v8); 23 std::string::~string(v9); 24 if ( std::string::length(v7) !</description>
    </item>
    <item>
      <title>近期解题 2024.1.13</title>
      <link>https://jackgdn.github.io/post/bundle-wp/%E8%BF%91%E6%9C%9F%E8%A7%A3%E9%A2%98_20230113/</link>
      <pubDate>Sat, 13 Jan 2024 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-wp/%E8%BF%91%E6%9C%9F%E8%A7%A3%E9%A2%98_20230113/</guid>
      <description>2024.1.4-2024.1.13&#xA;NEFU::CTF 反静态分析-1 反编译出 main() 函数如下：&#xA;敏锐察觉到 v9 数组的四个元素，疑似为 TEA 加密算法的 key。进入 sub_411523() -&amp;gt; sub_415100()，果然是一个 TEA 加密。&#xA;在 main() 函数中调用的 sub_411523() 有两个参数，第二个参数 v9 是 key，第一个参数 &amp;amp;v7 为 v7 数组。在变量声明的部分 int v7; // [esp+1D8h] [ebp-40h] BYREF 和 int v8; // [esp+1DCh] [ebp-3Ch] 可以看出 v7 与 v8 的地址相邻，实际上可以看作是一个数组。&#xA;写一个 TEA 解密的脚本，需要知道 v4（即 sum）的值是多少。通过打断点动态调试找到 v4 的值 0xC6EF3720。&#xA;上脚本&#xA;1#include &amp;lt;iostream&amp;gt; 2#include &amp;lt;cstdio&amp;gt; 3 4using namespace std; 5 6int key[4] = { 18,52,86,120 }; 7unsigned int num1 = 0x60FCDEF7; 8unsigned int num2 = 0x236DBEC; 9int sum = 0xC6EF3720; 10 11void tea() 12{ 13&#x9;for (int i = 0; i &amp;lt; 32; i++) 14&#x9;{ 15&#x9;num2 -= (key[3] + (num1 &amp;gt;&amp;gt; 5)) ^ (sum + num1) ^ (key[2] + 16 * num1); 16&#x9;num1 -= (key[1] + (num2 &amp;gt;&amp;gt; 5)) ^ (sum + num2) ^ (*key + 16 * num2); 17&#x9;sum += 0x61C88647; 18&#x9;} 19&#x9;cout &amp;lt;&amp;lt; num1 &amp;lt;&amp;lt; &amp;#39; &amp;#39; &amp;lt;&amp;lt; num2; 20} 21 22int main() 23{ 24&#x9;tea(); 25} 得到结果为 3 和 4，这与伪代码 main() 函数中 v8 = 4; 一致。运行程序，输入 3，确实进入了下一步骤。</description>
    </item>
    <item>
      <title>近期解题 2023.12.26</title>
      <link>https://jackgdn.github.io/post/bundle-wp/%E8%BF%91%E6%9C%9F%E8%A7%A3%E9%A2%98_20231226/</link>
      <pubDate>Tue, 26 Dec 2023 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-wp/%E8%BF%91%E6%9C%9F%E8%A7%A3%E9%A2%98_20231226/</guid>
      <description>擂台赛 - 123456789 题目源代码如下&#xA;1from secret import flag 2data = input(&amp;#39;&amp;gt; &amp;#39;) 3assert len(data) &amp;lt;= 9 and all(i not in &amp;#39;123456789&amp;#39; for i in data) and int(data) == 123456789 4print(flag) 看上去不是很麻烦。题目会在远程服务器上运行，secret 模块及其中的 flag 常量都存储在远程服务器上。 如果我们输入的 data 能够满足这个 assert 中的条件，flag 就会自己跳出来。&#xA;条件如下：&#xA;data 的长度小于等于 9&#xA;data 中不含 “123456789” 中的任意一个字符&#xA;data 转化为整型后与 123456789 相等&#xA;似乎条件 2、3 矛盾了，两个条件不可以同时实现。但是真的如此吗？&#xA;Unicode 编码归一化 文字处理软件在实现统一码字符串的搜索和排序时，须考虑到等价性的存在。如果没有此特性的话，用户在搜索时将无法找到在视觉上无法区分的字形。&#xA;通俗来讲，例如说在 Unicode 中合字 ﬃ (U+FB03) 在视觉上等同于 ffi 三个字符拼凑而成，因此需要计算机软件能够识别 ffi 三个字符等同于 ﬃ 合字字符，以便于用户检索。</description>
    </item>
  </channel>
</rss>
