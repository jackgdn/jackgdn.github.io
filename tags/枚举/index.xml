<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>枚举 on &lt;jack-gdn/&gt;</title>
    <link>https://jackgdn.github.io/tags/%E6%9E%9A%E4%B8%BE/</link>
    <description>Recent content in 枚举 on &lt;jack-gdn/&gt;</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Fri, 14 Mar 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://jackgdn.github.io/tags/%E6%9E%9A%E4%B8%BE/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>每日一题 3.10-3.16</title>
      <link>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-3.10-3.16/</link>
      <pubDate>Fri, 14 Mar 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-3.10-3.16/</guid>
      <description>题目来自 AcWing 刚说完上周题简单，这周一的题就给我干碎了……&#xA;5589. 哞语言逻辑 | 原题链接 首先用 Python 特有的 eval 来试一下：&#xA;1true, false = True, False 2n, q = map(int, input().strip().split()) 3exp = input().strip().split() 4 5ans = list() 6for _ in range(q): 7 a, b, bl = input().strip().split() 8 a = int(a) - 1 9 b = int(b) - 1 10 if eval(&amp;#39; &amp;#39;.join(exp[:a] + [&amp;#34;true&amp;#34;] + exp[b + 1:])) == eval(bl) or eval(&amp;#39; &amp;#39;.join(exp[:a] + [&amp;#34;false&amp;#34;] + exp[b + 1:])) == eval(bl): 11 ans.</description>
    </item>
    <item>
      <title>双指针、广搜与图论练习</title>
      <link>https://jackgdn.github.io/post/bundle-%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/algo-doublepointers&#43;bfs&#43;graphs/</link>
      <pubDate>Fri, 07 Mar 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/algo-doublepointers&#43;bfs&#43;graphs/</guid>
      <description>题目来自 AcWing 1238. 日志统计 | 原题链接 暴力做法：存储每个帖子在对应时间的点赞数，并计算前缀和，再遍历前缀和数组得到答案。时间复杂度和空间复杂度 $O(ND)$，可以通过 13/15 个测试点。&#xA;1from collections import defaultdict 2 3 4def check(nums, D, K): 5 prefs = [0] * int(1e5 + 1) 6 for i in range(1, int(1e5 + 1)): 7 prefs[i] = prefs[i - 1] + nums[i - 1] 8 if i &amp;gt;= D and prefs[i] - prefs[i - D] &amp;gt;= K: 9 return True 10 return False 11 12 13N, D, K = map(int, input().</description>
    </item>
    <item>
      <title>每日一题 2.24-3.2</title>
      <link>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-2.24-3.2/</link>
      <pubDate>Wed, 05 Mar 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-2.24-3.2/</guid>
      <description>上周忙着返校所以没来得及做题，这几天把上周的题目补上。&#xA;题目来自 AcWing 6131. 农夫约翰最喜欢的操作 | 原题链接 $M\mid a_i-x$ 对任意 $1\leq i\leq N$ 成立亦可以理解为对任意 $1\leq i,j\leq N$ 有 $a_i\equiv a_j\space(mod\space M)$。使原数列每一个数对 $m$ 取模得到模数列 $b$，再找一个数 $k$ 使得模数列中每一个值与 $k$ 的差的绝对值之和最小，即 $\sum^n_{i=1}|b_i-k|$ 最小，这个最小值就是题目要求的值。看起来这就是 货仓选址 的翻版，只要找到中位数即可。但情况真的如此吗？&#xA;实际情况是，由于 $a_i\equiv a_i\pm m\space(mod\space m)$，所有的同余类实际组成了一个环，在这个环上有 $n$ 中不同的取法，也就是说最多可能有 $n$ 个不同的中位数，而题目要求找到这 $n$ 中情况中找到最小的 $\sum^n_{i=1}|b_i-k|$。&#xA;如果将每种情况的模数列算出来，再遍历数列求出答案，时间复杂度为 $O(n^2)$ 必然超时。因此使用滑动窗口优化。首先找出最小的模数列，即每一项都小于 $m$，求出这一个模数列的最小 $\sum^n_{i=1}|b_i-k|$，这个值等于$中位数 \times 中位数左侧元素个数 - 中位数左侧元素之和 + 中位数右侧元素之和 - 中位数 \times 中位数右侧元素个数$。当窗口滑动时，中位数右移一位，中位数左右元素数量不变，而左右元素之和只需各自加减对应边界值。这样的时间复杂度为 $O(n)$。&#xA;1t = int(input().strip()) 2while t &amp;gt; 0: 3 n, m = map(int, input().</description>
    </item>
    <item>
      <title>枚举、模拟与排序练习</title>
      <link>https://jackgdn.github.io/post/bundle-%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/algo-enumeration&#43;simulation&#43;sorting/</link>
      <pubDate>Wed, 26 Feb 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/algo-enumeration&#43;simulation&#43;sorting/</guid>
      <description>题目来自 AcWing 1210. 连号区间数 | 原题链接 暴力枚举的做法就是遍历 l 和 r 并对区间排序，判断区间内的数字是否连续递增。这样做的时间复杂度是 $O(n^3logn)$， 而 $1\leq N\leq10^4$ 的范围显然不支持这样的算法。经过观察发现，一段连续递增的数列中，其最大值减去最小值一定与数列长度相等。利用这个特点，在遍历 l 与 r 时，只需要维护区间内最大值和最小值，然后随时做判断，这样做的时间复杂度为 $O(n^2)$，在 $N$ 的数据范围内够用。&#xA;1n = int(input().strip()) 2nums = tuple(map(int, input().strip().split())) 3 4count = 0 5for l in range(n): 6 max_val = nums[l] 7 min_val = nums[l] 8 for r in range(l, n): 9 if nums[r] &amp;gt; max_val: 10 max_val = nums[r] 11 elif nums[r] &amp;lt; min_val: 12 min_val = nums[r] 13 14 if max_val - min_val == r - l: 15 count += 1 16 17print(count) 1236.</description>
    </item>
    <item>
      <title>每日一题 2.17-2.23</title>
      <link>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-2.17-2.23/</link>
      <pubDate>Sun, 23 Feb 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-2.17-2.23/</guid>
      <description>题目来自 AcWing AcWing 6122. 农夫约翰的奶酪块 | 原题链接 最容易想到的是开一个三维数l组用于记录方块状态，如果此时需要判断是否有一整个 $1\times1\times N$ 的区域被挖空，则对三个方向分别求前缀和，当 $(N,y,z)=0$ 或 $(x,N,z)=0$ 或 $(z,y,N)=0$ 时，可以填充的砖块方案数 $+1$。&#xA;这样看来，能否填充砖块实际上只与 $x=N$ 或 $y=N$ 或 $z=N$ 处的前缀和有关，因此做出优化：用三个二维数组分别表示三个维度的前缀和，或者说对应位置的剩余方块数量，例如 yz_projection[0][1] 就表示 $y=0,\space z=1$ 区域中剩余方块数量。当一个区域中剩余方块数为 0 时，可以填充的砖块方案数 $+1$。&#xA;1n, q = map(int, input().strip().split(&amp;#34; &amp;#34;)) 2yz_projection = [[n for _ in range(n)] for _ in range(n)] 3xz_projection = [[n for _ in range(n)] for _ in range(n)] 4xy_projection = [[n for _ in range(n)] for _ in range(n)] 5 6count = 0 7for _ in range(q): 8 x, y, z = map(int, input().</description>
    </item>
    <item>
      <title>2025寒假算法练习——Week 3</title>
      <link>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025winter-week3/</link>
      <pubDate>Tue, 28 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025winter-week3/</guid>
      <description>习题均来自 NEFU OJ Problem 8 | 二倍的问题 Description 给定2到15个不同的正整数，你的任务是计算这些数里面有多少个数对满足：数对中一个数是另一个数的两倍。比如给定1 4 3 2 9 7 18 22，得到的答案是3，因为2是1的两倍，4是2个两倍，18是9的两倍。&#xA;Input 输入包括n组测试数据。每组数据包括一行，给出2到15个两两不同且小于100的正整数。每一行最后一个数是0，表示这一行的结束后，这个数不属于那2到15个给定的正整数。&#xA;Output 对每组输入数据，输出一行，给出有多少个数对满足其中一个数是另一个数的两倍。&#xA;Sample Input 13 21 4 3 2 9 7 18 22 0 32 4 8 10 0 47 5 11 13 1 3 0 Sample Output 13 22 30 简单题。唯一奇怪的是使用 bitset 比直接用 int* 的内存开销大。&#xA;1#define _CRT_SECURE_NO_WARNINGS 2 3#include &amp;lt;cstdio&amp;gt; 4#include &amp;lt;cstring&amp;gt; 5 6using namespace std; 7 8int max_value, i, value, n, cnt; 9int values[100]; 10 11int main() { 12 scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); 13 while (n--) { 14 memset(values, 0, sizeof(values)); 15 max_value = -1; 16 cnt = 0; 17 18 while (scanf(&amp;#34;%d&amp;#34;, &amp;amp;value) &amp;amp;&amp;amp; value !</description>
    </item>
  </channel>
</rss>
