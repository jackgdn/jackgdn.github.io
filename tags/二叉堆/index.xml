<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>二叉堆 on &lt;jack-gdn/&gt;</title>
    <link>https://jackgdn.github.io/tags/%E4%BA%8C%E5%8F%89%E5%A0%86/</link>
    <description>Recent content in 二叉堆 on &lt;jack-gdn/&gt;</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Sun, 30 Mar 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://jackgdn.github.io/tags/%E4%BA%8C%E5%8F%89%E5%A0%86/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>图论练习</title>
      <link>https://jackgdn.github.io/post/bundle-%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/algo-graphtheory/</link>
      <pubDate>Sun, 30 Mar 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/algo-graphtheory/</guid>
      <description>题目来自 AcWing 848. 有向图的拓扑序列 | 原题链接 拓扑排序已经做过好几遍了，而且这还是一道模板题。如果一个有向图中有环（自环也是环），那么它一定无法拓扑排序。如果一个图拓扑排序得到的节点数和图中的节点数不同，那么这个图无法被拓扑排序。又因为“有向图可以被拓扑排序”和“图是有向无环图”互为充要条件，所以，则这个图一定不是有向无环图。&#xA;1import sys 2from collections import defaultdict, deque 3 4data = sys.stdin.read().strip().splitlines() 5n, m = map(int, data[0].strip().split()) 6 7indegree = [0 for _ in range(n + 1)] 8graph = defaultdict(list) 9ans = list() 10 11for i in range(1, m + 1): 12 u, v = map(int, data[i].strip().split()) 13 graph[u].append(v) 14 indegree[v] += 1 15 16q = deque() 17for node in range(1, n + 1): 18 if indegree[node] == 0: 19 q.</description>
    </item>
    <item>
      <title>2025春季算法练习——Week 3</title>
      <link>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025spring-week3/</link>
      <pubDate>Wed, 26 Mar 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025spring-week3/</guid>
      <description>这些题看上去较简单，但是实操起来还有很多细节需要注意。&#xA;题目来自 AcWing 830. 单调栈 | 原题链接 遍历原数组中的每个数，然后作如下操作：&#xA;将栈顶元素出栈直到栈顶元素小于列表当前元素 将栈顶元素添加到答案列表中 将列表当前元素入栈 在栈中，如果一个元素小于前一个元素，那么这个元素后面所有元素的“左边第一个比它小的数”就不可能是当前这个元素前面的元素。&#xA;1from collections import deque 2 3n = int(input().strip()) 4nums = tuple(map(int, input().strip().split())) 5stack = deque() 6ans = list() 7for num in nums: 8 while stack and stack[-1] &amp;gt;= num: 9 stack.pop() 10 ans.append(-1 if not stack else stack[-1]) 11 stack.append(num) 12 13print(*ans) 154. 滑动窗口 | 原题链接 这道题像是上一道题的进阶版，区别是这道题只能在一个区间范围内找最大/最小值。解决这道题的流程如下：&#xA;将已经离开窗口的元素从队首弹出 确保队尾元素大于/小于列表当前元素，否则将元素从队尾出队 将列表当前元素入队 队首元素即为当前窗口的最大/最小值，将这个值添加到答案列表中 为了方便判断某个元素是否已经离开窗口，队列中存储的是元素的下标。&#xA;1from collections import deque 2 3n, k = map(int, input().</description>
    </item>
    <item>
      <title>2025寒假算法练习——Week 7</title>
      <link>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025winter-week7/</link>
      <pubDate>Sat, 22 Feb 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025winter-week7/</guid>
      <description>习题均来自 NEFU OJ Problem 1632 | 周末舞会-队列 Description 假设在周末舞会上，男士们和女士们进入舞厅时，各自排成一队。跳舞开始时，依次从男队和女队的队头上各出一人配成舞伴。规定每个舞曲只能有一对跳舞者。若两队初始人数不相同，则较长的那一队中未配对者等待下一轮舞曲。现要求写一个程序，模拟上述舞伴配对问题。&#xA;Input 第 1 行两个正整数，表示男士人数 m 和女士人数 n，1≤m，n≤1000； 第 2 行一个正整数，表示舞曲的数目 k，k≤1000。&#xA;Output 共 k 行，每行两个数，之间用一个空格隔开，表示配对舞伴的序号，男士在前，女士在后。&#xA;Sample Input 12 4 26 Sample Output 11 1 22 2 31 3 42 4 51 1 62 2 用队列反而时空消耗大，不如直接取模。&#xA;1import java.util.Scanner; 2 3public class Main { 4 public static void main(String[] args) { 5 try (Scanner sc = new Scanner(System.in)) { 6 int m = sc.</description>
    </item>
    <item>
      <title>动态规划练习（一）</title>
      <link>https://jackgdn.github.io/post/bundle-%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/algo-dp-1/</link>
      <pubDate>Fri, 21 Feb 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/algo-dp-1/</guid>
      <description>下面的题目来自洛谷题单【动态规划1】动态规划的引入&#xA;解决动态规划问题的三个核心：dp 数组含义、状态转移方程、初始值。&#xA;P1216 [IOI 1994] 数字三角形 Number Triangles 题目描述 观察下面的数字金字塔。&#xA;写一个程序来查找从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以走到左下方的点也可以到达右下方的点。&#xA;在上面的样例中，从 $7 \to 3 \to 8 \to 7 \to 5$ 的路径产生了最大权值。&#xA;输入格式 第一个行一个正整数 $r$ ,表示行的数目。&#xA;后面每行为这个数字金字塔特定行包含的整数。&#xA;输出格式 单独的一行,包含那个可能得到的最大的和。&#xA;输入输出样例 #1 输入 #1 15 27 33 8 48 1 0 52 7 4 4 64 5 2 6 5 输出 #1 130 说明/提示 【数据范围】 对于 $100%$ 的数据，$1\le r \le 1000$，所有输入在 $[0,100]$ 范围内。&#xA;题目翻译来自NOCOW。&#xA;USACO Training Section 1.5&#xA;IOI1994 Day1T1</description>
    </item>
    <item>
      <title>2025寒假算法练习——Week 2</title>
      <link>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025winter-week2/</link>
      <pubDate>Fri, 24 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025winter-week2/</guid>
      <description>习题均来自 NEFU OJ Problem 1481 | 谁考了第k名-排序 Description 在一次考试中，每个学生的成绩都不相同，现知道了每个学生的学号和成绩，求考第k名学生的学号和成绩。&#xA;Input 第一行有两个整数，分别是学生的人数n（1≤n≤100），和求第k名学生的k（1≤k≤n）。 其后有n行数据，每行包括一个学号（整数）和一个成绩（浮点数），中间用一个空格分隔。&#xA;Output 输出第k名学生的学号和成绩，中间用空格分隔。（注：请用%g输出成绩）&#xA;Sample Input 15 3 290788001 67.8 390788002 90.3 490788003 61 590788004 68.4 690788005 73.9 Sample Output 190788004 68.4 Source 奥赛一本通&#xA;这道题可以自己搓一个排序，也可以用结构体排序解决。&#xA;1#include &amp;lt;iostream&amp;gt; 2#include &amp;lt;algorithm&amp;gt; 3 4using namespace std; 5 6struct Student { 7 int id;z 8 float score; 9}; 10 11bool cmp(Student a, Student b) { 12 return a.score &amp;gt; b.score; 13} 14 15int main() { 16 Student students[100]; 17 int n, k; 18 cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k; 19 for (int i = 0; i &amp;lt; n; i++) { 20 cin &amp;gt;&amp;gt; students[i].</description>
    </item>
  </channel>
</rss>
