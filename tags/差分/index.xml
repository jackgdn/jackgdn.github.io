<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>差分 on &lt;jack-gdn/&gt;</title>
    <link>https://jackgdn.github.io/tags/%E5%B7%AE%E5%88%86/</link>
    <description>Recent content in 差分 on &lt;jack-gdn/&gt;</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Sat, 08 Mar 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://jackgdn.github.io/tags/%E5%B7%AE%E5%88%86/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>每日一题 3.3-3.9</title>
      <link>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-3.3-3.9/</link>
      <pubDate>Sat, 08 Mar 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-3.3-3.9/</guid>
      <description>题目来自 AcWing 感觉每日一题越来越简单，代码量也越来越短。第一周优化暴力枚举的题目兼具创新性和挑战性，而这周的题目几乎不需要“深度求索”。&#xA;5525. 炮弹 | 原题链接 只需要把情况模拟一下就行了。唯一要注意的是，如果 Bessie 陷入了死循环就直接输出。判断死循环的方式也特别简单，每次弹跳后将当前的位置、能量、方向存储进一个集合（in 关键字访问集合的时间复杂度为 $O(1)$），同时每次弹跳前查看此次弹跳是否已经被记录。&#xA;1N, S = map(int, input().strip().split()) 2field = [0] * N 3cate = [0] * N 4S -= 1 5targets = 0 6for i in range(N): 7 qi, vi = map(int, input().strip().split()) 8 cate[i] = qi 9 field[i] = vi 10 targets += qi 11 12memo = set() 13count = 0 14power = 1 15directions = {1: -1, -1: 1} 16d = 1 17while 0 &amp;lt;= S &amp;lt; N: 18 if cate[S] == 1: 19 if field[S] &amp;gt;= 0 and power &amp;gt;= field[S]: 20 field[S] = -1 21 count += 1 22 S += d * power 23 else: 24 power += field[S] 25 d = directions[d] 26 S += d * power 27 28 if (S, d, power) in memo: 29 break 30 memo.</description>
    </item>
    <item>
      <title>树状数组、线段树与差分练习</title>
      <link>https://jackgdn.github.io/post/bundle-%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/algo-segmenttree/</link>
      <pubDate>Mon, 03 Mar 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/algo-segmenttree/</guid>
      <description>Info&#xA;树状数组与线段树的适用范围是“单点修改，区间查询”。树状数组更适合用于动态维护前缀和，而线段树还可用于求区间最值 树状数组和线段树都是在线方法，支持动态修改与维护。&#xA;题目来自 AcWing 1264. 动态求连续区间和 | 原题链接 这是一道树状数组模板题。树状数组最基础的用法就是动态维护前缀和。下面出现的 lowbit add query 操作都是维护树状数组的基本函数。&#xA;1import sys 2 3 4def lowbit(x): 5 return x &amp;amp; -x 6 7 8def add(x, val): 9 while x &amp;lt;= n: 10 tree[x] += val 11 x += lowbit(x) 12 13 14def query(x): 15 res = 0 16 while x &amp;gt; 0: 17 res += tree[x] 18 x -= lowbit(x) 19 return res 20 21 22data = sys.</description>
    </item>
  </channel>
</rss>
