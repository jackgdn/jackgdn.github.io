<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>模拟 on &lt;jack-gdn/&gt;</title>
    <link>https://jackgdn.github.io/tags/%E6%A8%A1%E6%8B%9F/</link>
    <description>Recent content in 模拟 on &lt;jack-gdn/&gt;</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Sat, 05 Apr 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://jackgdn.github.io/tags/%E6%A8%A1%E6%8B%9F/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>2025春季算法练习——Week 5</title>
      <link>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025spring-week5/</link>
      <pubDate>Sat, 05 Apr 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025spring-week5/</guid>
      <description>题目来自 蓝桥云课 19714 数字诗意 | 原题链接 假设数字 $n$ 可以被表示为从 $a$ 到 $a+k-1$ 共 $k$ 个数字的和，则 $n=\frac{k(2a+k-1)}2$，通过观察不难发现，$n$ 一定有奇数因子。也就是说，如果一个数是 $2$ 的幂，那么它一定没有诗意。&#xA;令 $n=o\cdot e$，$o$ 为 $n$ 的奇数因子，$e$ 为 $n$ 的偶数因子。当 $o&amp;gt;e$ 时，令 $k=e$，则 $a=\frac{o+1-e}2$，此时 $a\in \mathbb{N_+}$；当 $o&amp;lt;e$ 时，令 $k=o$，则 $a=\frac{e+1-o}2$，此时 $a\in \mathbb{N_+}$。&#xA;因此当且仅当 $n\neq2^k$ 时，$n$ 有诗意。&#xA;1_ = int(input().strip()) 2nums = tuple(map(int, input().strip().split())) 3p2 = set() 4p = 1 5while p &amp;lt;= 1e16: 6 p2.add(p) 7 p *= 2 8count = 0 9for num in nums: 10 if num in p2: 11 count += 1 12print(count) 19715 回文数组 | 原题链接 模拟一下就行。</description>
    </item>
    <item>
      <title>每日一题 3.3-3.9</title>
      <link>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-3.3-3.9/</link>
      <pubDate>Sat, 08 Mar 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-3.3-3.9/</guid>
      <description>题目来自 AcWing 感觉每日一题越来越简单，代码量也越来越短。第一周优化暴力枚举的题目兼具创新性和挑战性，而这周的题目几乎不需要“深度求索”。&#xA;5525. 炮弹 | 原题链接 只需要把情况模拟一下就行了。唯一要注意的是，如果 Bessie 陷入了死循环就直接输出。判断死循环的方式也特别简单，每次弹跳后将当前的位置、能量、方向存储进一个集合（in 关键字访问集合的时间复杂度为 $O(1)$），同时每次弹跳前查看此次弹跳是否已经被记录。&#xA;1N, S = map(int, input().strip().split()) 2field = [0] * N 3cate = [0] * N 4S -= 1 5targets = 0 6for i in range(N): 7 qi, vi = map(int, input().strip().split()) 8 cate[i] = qi 9 field[i] = vi 10 targets += qi 11 12memo = set() 13count = 0 14power = 1 15directions = {1: -1, -1: 1} 16d = 1 17while 0 &amp;lt;= S &amp;lt; N: 18 if cate[S] == 1: 19 if field[S] &amp;gt;= 0 and power &amp;gt;= field[S]: 20 field[S] = -1 21 count += 1 22 S += d * power 23 else: 24 power += field[S] 25 d = directions[d] 26 S += d * power 27 28 if (S, d, power) in memo: 29 break 30 memo.</description>
    </item>
    <item>
      <title>每日一题 2.24-3.2</title>
      <link>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-2.24-3.2/</link>
      <pubDate>Wed, 05 Mar 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-2.24-3.2/</guid>
      <description>上周忙着返校所以没来得及做题，这几天把上周的题目补上。&#xA;题目来自 AcWing 6131. 农夫约翰最喜欢的操作 | 原题链接 $M\mid a_i-x$ 对任意 $1\leq i\leq N$ 成立亦可以理解为对任意 $1\leq i,j\leq N$ 有 $a_i\equiv a_j\space(mod\space M)$。使原数列每一个数对 $m$ 取模得到模数列 $b$，再找一个数 $k$ 使得模数列中每一个值与 $k$ 的差的绝对值之和最小，即 $\sum^n_{i=1}|b_i-k|$ 最小，这个最小值就是题目要求的值。看起来这就是 货仓选址 的翻版，只要找到中位数即可。但情况真的如此吗？&#xA;实际情况是，由于 $a_i\equiv a_i\pm m\space(mod\space m)$，所有的同余类实际组成了一个环，在这个环上有 $n$ 中不同的取法，也就是说最多可能有 $n$ 个不同的中位数，而题目要求找到这 $n$ 中情况中找到最小的 $\sum^n_{i=1}|b_i-k|$。&#xA;如果将每种情况的模数列算出来，再遍历数列求出答案，时间复杂度为 $O(n^2)$ 必然超时。因此使用滑动窗口优化。首先找出最小的模数列，即每一项都小于 $m$，求出这一个模数列的最小 $\sum^n_{i=1}|b_i-k|$，这个值等于$中位数 \times 中位数左侧元素个数 - 中位数左侧元素之和 + 中位数右侧元素之和 - 中位数 \times 中位数右侧元素个数$。当窗口滑动时，中位数右移一位，中位数左右元素数量不变，而左右元素之和只需各自加减对应边界值。这样的时间复杂度为 $O(n)$。&#xA;1t = int(input().strip()) 2while t &amp;gt; 0: 3 n, m = map(int, input().</description>
    </item>
    <item>
      <title>枚举、模拟与排序练习</title>
      <link>https://jackgdn.github.io/post/bundle-%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/algo-enumeration&#43;simulation&#43;sorting/</link>
      <pubDate>Wed, 26 Feb 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/algo-enumeration&#43;simulation&#43;sorting/</guid>
      <description>题目来自 AcWing 1210. 连号区间数 | 原题链接 暴力枚举的做法就是遍历 l 和 r 并对区间排序，判断区间内的数字是否连续递增。这样做的时间复杂度是 $O(n^3logn)$， 而 $1\leq N\leq10^4$ 的范围显然不支持这样的算法。经过观察发现，一段连续递增的数列中，其最大值减去最小值一定与数列长度相等。利用这个特点，在遍历 l 与 r 时，只需要维护区间内最大值和最小值，然后随时做判断，这样做的时间复杂度为 $O(n^2)$，在 $N$ 的数据范围内够用。&#xA;1n = int(input().strip()) 2nums = tuple(map(int, input().strip().split())) 3 4count = 0 5for l in range(n): 6 max_val = nums[l] 7 min_val = nums[l] 8 for r in range(l, n): 9 if nums[r] &amp;gt; max_val: 10 max_val = nums[r] 11 elif nums[r] &amp;lt; min_val: 12 min_val = nums[r] 13 14 if max_val - min_val == r - l: 15 count += 1 16 17print(count) 1236.</description>
    </item>
  </channel>
</rss>
