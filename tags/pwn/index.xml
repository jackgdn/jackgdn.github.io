<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Pwn on &lt;jack-gdn/&gt;</title>
    <link>https://jackgdn.github.io/tags/pwn/</link>
    <description>Recent content in Pwn on &lt;jack-gdn/&gt;</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Wed, 14 Feb 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://jackgdn.github.io/tags/pwn/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>NSSCTF Round#18 WP</title>
      <link>https://jackgdn.github.io/post/bundle-wp/nss18/</link>
      <pubDate>Wed, 14 Feb 2024 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-wp/nss18/</guid>
      <description>users &amp;amp; users_revenge 两道题可以用同一个脚本解。两道题区别就是题目 1 给出 200 个用户名，题目 2 给出 500 个用户名，密码为用户名的 MD5，其中有一个用户里有 flag，考虑使用 pwntools 连接。&#xA;1from pwn import * 2import hashlib 3 4usrlst = [] 5pwdlst = [] 6flaglst = [] 7sususrlst = [] 8suspwdlst = [] 9excptlst = [] 10&amp;#39;&amp;#39;&amp;#39; 11file_name = 12given_host = 13given_port = 14&amp;#39;&amp;#39;&amp;#39; 15with open(file_name, &amp;#39;r&amp;#39;) as wordlist: 16 for line in wordlist: 17 username = line.rstrip() # 去除换行符 18 usrlst.append(username) 19 pwdlst.append(hashlib.md5(username.encode()).hexdigest()) 20 21for i in range(len(usrlst)): 22 try: 23 print(i) 24 shell = ssh(host = given_host, port = given_port, user = usrlst[i], password = pwdlst[i]) # 题目使用 SSH 连接 25 sh = shell.</description>
    </item>
    <item>
      <title>近期解题 2024.1.13</title>
      <link>https://jackgdn.github.io/post/bundle-wp/%E8%BF%91%E6%9C%9F%E8%A7%A3%E9%A2%98_20230113/</link>
      <pubDate>Sat, 13 Jan 2024 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-wp/%E8%BF%91%E6%9C%9F%E8%A7%A3%E9%A2%98_20230113/</guid>
      <description>2024.1.4-2024.1.13&#xA;NEFU::CTF 反静态分析-1 反编译出 main() 函数如下：&#xA;敏锐察觉到 v9 数组的四个元素，疑似为 TEA 加密算法的 key。进入 sub_411523() -&amp;gt; sub_415100()，果然是一个 TEA 加密。&#xA;在 main() 函数中调用的 sub_411523() 有两个参数，第二个参数 v9 是 key，第一个参数 &amp;amp;v7 为 v7 数组。在变量声明的部分 int v7; // [esp+1D8h] [ebp-40h] BYREF 和 int v8; // [esp+1DCh] [ebp-3Ch] 可以看出 v7 与 v8 的地址相邻，实际上可以看作是一个数组。&#xA;写一个 TEA 解密的脚本，需要知道 v4（即 sum）的值是多少。通过打断点动态调试找到 v4 的值 0xC6EF3720。&#xA;上脚本&#xA;1#include &amp;lt;iostream&amp;gt; 2#include &amp;lt;cstdio&amp;gt; 3 4using namespace std; 5 6int key[4] = { 18,52,86,120 }; 7unsigned int num1 = 0x60FCDEF7; 8unsigned int num2 = 0x236DBEC; 9int sum = 0xC6EF3720; 10 11void tea() 12{ 13&#x9;for (int i = 0; i &amp;lt; 32; i++) 14&#x9;{ 15&#x9;num2 -= (key[3] + (num1 &amp;gt;&amp;gt; 5)) ^ (sum + num1) ^ (key[2] + 16 * num1); 16&#x9;num1 -= (key[1] + (num2 &amp;gt;&amp;gt; 5)) ^ (sum + num2) ^ (*key + 16 * num2); 17&#x9;sum += 0x61C88647; 18&#x9;} 19&#x9;cout &amp;lt;&amp;lt; num1 &amp;lt;&amp;lt; &amp;#39; &amp;#39; &amp;lt;&amp;lt; num2; 20} 21 22int main() 23{ 24&#x9;tea(); 25} 得到结果为 3 和 4，这与伪代码 main() 函数中 v8 = 4; 一致。运行程序，输入 3，确实进入了下一步骤。</description>
    </item>
  </channel>
</rss>
