<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>递归 on &lt;jack-gdn/&gt;</title>
    <link>https://jackgdn.github.io/tags/%E9%80%92%E5%BD%92/</link>
    <description>Recent content in 递归 on &lt;jack-gdn/&gt;</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Sat, 22 Feb 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://jackgdn.github.io/tags/%E9%80%92%E5%BD%92/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>2025寒假算法练习——Week 7</title>
      <link>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025winter-week7/</link>
      <pubDate>Sat, 22 Feb 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E5%91%A8%E7%BB%83/2025winter-week7/</guid>
      <description>习题均来自 NEFU OJ Problem 1632 | 周末舞会-队列 Description 假设在周末舞会上，男士们和女士们进入舞厅时，各自排成一队。跳舞开始时，依次从男队和女队的队头上各出一人配成舞伴。规定每个舞曲只能有一对跳舞者。若两队初始人数不相同，则较长的那一队中未配对者等待下一轮舞曲。现要求写一个程序，模拟上述舞伴配对问题。&#xA;Input 第 1 行两个正整数，表示男士人数 m 和女士人数 n，1≤m，n≤1000； 第 2 行一个正整数，表示舞曲的数目 k，k≤1000。&#xA;Output 共 k 行，每行两个数，之间用一个空格隔开，表示配对舞伴的序号，男士在前，女士在后。&#xA;Sample Input 12 4 26 Sample Output 11 1 22 2 31 3 42 4 51 1 62 2 用队列反而时空消耗大，不如直接取模。&#xA;1import java.util.Scanner; 2 3public class Main { 4 public static void main(String[] args) { 5 try (Scanner sc = new Scanner(System.in)) { 6 int m = sc.</description>
    </item>
    <item>
      <title>递归与递推练习</title>
      <link>https://jackgdn.github.io/post/bundle-%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/algo-recursion&#43;iteration/</link>
      <pubDate>Sat, 08 Feb 2025 00:00:00 +0000</pubDate>
      <guid>https://jackgdn.github.io/post/bundle-%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/algo-recursion&#43;iteration/</guid>
      <description>题目来自 AcWing 92. 递归实现指数型枚举 | 原题链接 使用 AcWing 上的挑战模式做题，所以码风看上去比较乱。&#xA;1n = int(input()) 2nums = list(range(1, n + 1)) 3 4def dfs(current, nums): 5 if len(nums) == 0: 6 print(&amp;#34; &amp;#34;.join(current)) 7 return 8 9 dfs(current, nums[1:]) 10 dfs(current + [str(nums[0])], nums[1:]) 11 12dfs(list(), nums) 94. 递归实现排列型枚举 | 原题链接 全排列，一般做法：&#xA;1n = int(input()) 2nums = {k: True for k in range(1, n + 1)} 3result = list() 4 5def dfs(current): 6 if not any(nums.</description>
    </item>
  </channel>
</rss>
